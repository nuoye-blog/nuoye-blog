<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Linux内核设计与实现》 | nuoye's blog</title><meta name="description" content="Linux内核设计与实现操作系统和内核简介处理器上任何指定时间点上的活动必然概况为下列三者之一（当CPU空闲时，相当于运行一个空间程，运行于内核空间）：  内核开发特点 无libc库也无标准头文件 没有内存保护机制 不要轻易在内核中使用浮点数 容积小而固定的栈 同步和并发  进程管理进程进程就是处于执行器的程序，并包括其资源（如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映"><meta name="keywords" content="笔记,linux,kernel"><meta name="author" content="nuoye"><meta name="copyright" content="nuoye"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="_pyFdIcmaCRoz088kKiZz3MCJ6t3M4uYNi090bltUBI"/><meta name="baidu-site-verification" content="BLwscaTvpI"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Linux内核设计与实现》"><meta name="twitter:description" content="Linux内核设计与实现操作系统和内核简介处理器上任何指定时间点上的活动必然概况为下列三者之一（当CPU空闲时，相当于运行一个空间程，运行于内核空间）：  内核开发特点 无libc库也无标准头文件 没有内存保护机制 不要轻易在内核中使用浮点数 容积小而固定的栈 同步和并发  进程管理进程进程就是处于执行器的程序，并包括其资源（如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《Linux内核设计与实现》"><meta property="og:url" content="https://nuoye-blog.github.io/2020/05/09/4475e869/"><meta property="og:site_name" content="nuoye's blog"><meta property="og:description" content="Linux内核设计与实现操作系统和内核简介处理器上任何指定时间点上的活动必然概况为下列三者之一（当CPU空闲时，相当于运行一个空间程，运行于内核空间）：  内核开发特点 无libc库也无标准头文件 没有内存保护机制 不要轻易在内核中使用浮点数 容积小而固定的栈 同步和并发  进程管理进程进程就是处于执行器的程序，并包括其资源（如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-08T16:00:00.000Z"><meta property="article:modified_time" content="2020-06-10T13:49:40.103Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://nuoye-blog.github.io/2020/05/09/4475e869/"><link rel="prev" title="《程序员的自我修养》" href="https://nuoye-blog.github.io/2020/05/09/f557d42c/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7024541a1af4db0c8c6fecf9353cb259";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://nuoye-blog.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="nuoye's blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux内核设计与实现"><span class="toc-number">1.</span> <span class="toc-text">Linux内核设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统和内核简介"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统和内核简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核开发特点"><span class="toc-number">1.1.1.</span> <span class="toc-text">内核开发特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程管理"><span class="toc-number">1.2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程描述符及任务结构"><span class="toc-number">1.2.2.</span> <span class="toc-text">进程描述符及任务结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分配进程描述符"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">分配进程描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#进程状态"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置当前进程状态"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">设置当前进程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#进程上下文"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">进程上下文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程创建"><span class="toc-number">1.2.3.</span> <span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-与exec"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">fork()与exec()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写时拷贝"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">写时拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vfork"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">vfork()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程在Linux中的实现"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程在Linux中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建线程"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核线程"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">内核线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程终结"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">进程终结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#删除进程描述符"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">删除进程描述符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#孤儿进程的解决"><span class="toc-number">1.2.4.3.2.</span> <span class="toc-text">孤儿进程的解决</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程调度"><span class="toc-number">1.3.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多任务"><span class="toc-number">1.3.1.</span> <span class="toc-text">多任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux的进程调度"><span class="toc-number">1.3.2.</span> <span class="toc-text">Linux的进程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#策略"><span class="toc-number">1.3.3.</span> <span class="toc-text">策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O消耗性和处理器消耗型进程"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">I&#x2F;O消耗性和处理器消耗型进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程优化级"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">进程优化级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间片"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">时间片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度策略活动"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">调度策略活动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux调度算法"><span class="toc-number">1.3.4.</span> <span class="toc-text">Linux调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调度器类"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">调度器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平调度"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">公平调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux调度的实现"><span class="toc-number">1.3.5.</span> <span class="toc-text">Linux调度的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间记账"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">时间记账</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#调度器实体结构"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">调度器实体结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#虚拟实时"><span class="toc-number">1.3.5.1.2.</span> <span class="toc-text">虚拟实时</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程选择"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">进程选择</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#挑选下一个任务"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">挑选下一个任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#向树中加入进程"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">向树中加入进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从树中删除进程"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">从树中删除进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调度器入口"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">调度器入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#睡眠和唤醒"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">睡眠和唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#等待队列"><span class="toc-number">1.3.5.4.1.</span> <span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#唤醒"><span class="toc-number">1.3.5.4.2.</span> <span class="toc-text">唤醒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占和上下文切换"><span class="toc-number">1.3.6.</span> <span class="toc-text">抢占和上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户抢占"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">用户抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核抢占"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">内核抢占</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实时调度策略"><span class="toc-number">1.3.7.</span> <span class="toc-text">实时调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与调度相关的系统调用"><span class="toc-number">1.3.8.</span> <span class="toc-text">与调度相关的系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统调用"><span class="toc-number">1.4.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与内核通信"><span class="toc-number">1.4.1.</span> <span class="toc-text">与内核通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API、POSIX和C库"><span class="toc-number">1.4.2.</span> <span class="toc-text">API、POSIX和C库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#系统调用号"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">系统调用号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统调用的性能"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">系统调用的性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用处理程序"><span class="toc-number">1.4.4.</span> <span class="toc-text">系统调用处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指定恰当的系统调用"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">指定恰当的系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数传递"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用的实现"><span class="toc-number">1.4.5.</span> <span class="toc-text">系统调用的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用上下文"><span class="toc-number">1.4.6.</span> <span class="toc-text">系统调用上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#绑定一个系统调用的步骤"><span class="toc-number">1.4.6.0.1.</span> <span class="toc-text">绑定一个系统调用的步骤</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核数据结构"><span class="toc-number">1.5.</span> <span class="toc-text">内核数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">1.5.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">1.5.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射"><span class="toc-number">1.5.3.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">1.5.4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自平衡二叉搜索树"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">自平衡二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#红黑树"><span class="toc-number">1.5.4.2.1.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rbtree"><span class="toc-number">1.5.4.2.2.</span> <span class="toc-text">rbtree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法复杂度"><span class="toc-number">1.5.5.</span> <span class="toc-text">算法复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断和中断处理"><span class="toc-number">1.6.</span> <span class="toc-text">中断和中断处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中断"><span class="toc-number">1.6.1.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异常"><span class="toc-number">1.6.1.0.1.</span> <span class="toc-text">异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断处理程序"><span class="toc-number">1.6.2.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上半部与下半部的对比"><span class="toc-number">1.6.3.</span> <span class="toc-text">上半部与下半部的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册中断处理程序"><span class="toc-number">1.6.4.</span> <span class="toc-text">注册中断处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断处理程序标志"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">中断处理程序标志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#释放中断处理程序"><span class="toc-number">1.6.5.</span> <span class="toc-text">释放中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断上下文"><span class="toc-number">1.6.6.</span> <span class="toc-text">中断上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断处理机制的实现"><span class="toc-number">1.6.7.</span> <span class="toc-text">中断处理机制的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-interrupts"><span class="toc-number">1.6.8.</span> <span class="toc-text">&#x2F;proc&#x2F;interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断控制"><span class="toc-number">1.6.9.</span> <span class="toc-text">中断控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止和激活中断"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">禁止和激活中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下半部和推后执行的工作"><span class="toc-number">1.7.</span> <span class="toc-text">下半部和推后执行的工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#下半部"><span class="toc-number">1.7.1.</span> <span class="toc-text">下半部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#下半部的起源——bottom-half-BH"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">下半部的起源——bottom half(BH)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任务队列"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">任务队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软中断和tasklet"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">软中断和tasklet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作队列"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">工作队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核定时器"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">内核定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软中断"><span class="toc-number">1.7.2.</span> <span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#软中断的实现"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">软中断的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#软中断处理程序"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">软中断处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#执行软中断"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">执行软中断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用软中断"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">使用软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分配索引"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">分配索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#注册处理程序"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">注册处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#触发软中断"><span class="toc-number">1.7.2.2.3.</span> <span class="toc-text">触发软中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet"><span class="toc-number">1.7.3.</span> <span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tasklet的实现"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">tasklet的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tasklet结构体"><span class="toc-number">1.7.3.1.1.</span> <span class="toc-text">tasklet结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#调度tasklet"><span class="toc-number">1.7.3.1.2.</span> <span class="toc-text">调度tasklet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用tasklet"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">使用tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#声明一个tasklet"><span class="toc-number">1.7.3.2.1.</span> <span class="toc-text">声明一个tasklet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#编写tasklet处理程序"><span class="toc-number">1.7.3.2.2.</span> <span class="toc-text">编写tasklet处理程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#调度tasklet-1"><span class="toc-number">1.7.3.2.3.</span> <span class="toc-text">调度tasklet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ksoftirqd"><span class="toc-number">1.7.3.2.4.</span> <span class="toc-text">ksoftirqd</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老的BH机制"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">老的BH机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作队列-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作队列的实现"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">工作队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#表示线程的数据结构"><span class="toc-number">1.7.4.1.1.</span> <span class="toc-text">表示线程的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#表示工作的数据结构"><span class="toc-number">1.7.4.1.2.</span> <span class="toc-text">表示工作的数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用工作队列"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">使用工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建推后的工作"><span class="toc-number">1.7.4.2.1.</span> <span class="toc-text">创建推后的工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#工作队列处理函数"><span class="toc-number">1.7.4.2.2.</span> <span class="toc-text">工作队列处理函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对工作进程调度"><span class="toc-number">1.7.4.2.3.</span> <span class="toc-text">对工作进程调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#刷新操作"><span class="toc-number">1.7.4.2.4.</span> <span class="toc-text">刷新操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建新的工作队列"><span class="toc-number">1.7.4.2.5.</span> <span class="toc-text">创建新的工作队列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核同步介绍"><span class="toc-number">1.8.</span> <span class="toc-text">内核同步介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区和条件竞争"><span class="toc-number">1.8.1.</span> <span class="toc-text">临界区和条件竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁"><span class="toc-number">1.8.2.</span> <span class="toc-text">加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">1.8.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#争用和扩展性"><span class="toc-number">1.8.4.</span> <span class="toc-text">争用和扩展性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核同步方法"><span class="toc-number">1.9.</span> <span class="toc-text">内核同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作"><span class="toc-number">1.9.1.</span> <span class="toc-text">原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子整数操作"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">原子整数操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64位原子操作"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">64位原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原子位操作"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">原子位操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁"><span class="toc-number">1.9.2.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁方法"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">自旋锁方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他针对自旋锁的操作"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">其他针对自旋锁的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁和下半部"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">自旋锁和下半部</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读-写自旋锁"><span class="toc-number">1.9.3.</span> <span class="toc-text">读-写自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量"><span class="toc-number">1.9.4.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计数信号量和二值信号量"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">计数信号量和二值信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和初始化信号量"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">创建和初始化信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用信号量"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">使用信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读-写信号量"><span class="toc-number">1.9.5.</span> <span class="toc-text">读-写信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥体"><span class="toc-number">1.9.6.</span> <span class="toc-text">互斥体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完成变量"><span class="toc-number">1.9.7.</span> <span class="toc-text">完成变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKL：大内核锁"><span class="toc-number">1.9.8.</span> <span class="toc-text">BKL：大内核锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序锁"><span class="toc-number">1.9.9.</span> <span class="toc-text">顺序锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁止抢占"><span class="toc-number">1.9.10.</span> <span class="toc-text">禁止抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序和屏障"><span class="toc-number">1.9.11.</span> <span class="toc-text">顺序和屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时器和时间管理"><span class="toc-number">1.10.</span> <span class="toc-text">定时器和时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内核中的时间概念"><span class="toc-number">1.10.1.</span> <span class="toc-text">内核中的时间概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节拍率：HZ"><span class="toc-number">1.10.2.</span> <span class="toc-text">节拍率：HZ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jiffies"><span class="toc-number">1.10.3.</span> <span class="toc-text">Jiffies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户空间和HZ"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">用户空间和HZ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬时钟和定时器"><span class="toc-number">1.10.4.</span> <span class="toc-text">硬时钟和定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实时时钟"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">实时时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统定时器"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">系统定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时钟中断处理程序"><span class="toc-number">1.10.5.</span> <span class="toc-text">时钟中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际时间"><span class="toc-number">1.10.6.</span> <span class="toc-text">实际时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器"><span class="toc-number">1.10.7.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用定时器"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">使用定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定时器竞争条件"><span class="toc-number">1.10.7.2.</span> <span class="toc-text">定时器竞争条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现定时器"><span class="toc-number">1.10.7.3.</span> <span class="toc-text">实现定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟执行"><span class="toc-number">1.10.8.</span> <span class="toc-text">延迟执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#忙等待"><span class="toc-number">1.10.8.1.</span> <span class="toc-text">忙等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#短延迟"><span class="toc-number">1.10.8.2.</span> <span class="toc-text">短延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#schedule-timeout"><span class="toc-number">1.10.8.3.</span> <span class="toc-text">schedule_timeout()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#schedule-timeout-的实现"><span class="toc-number">1.10.8.3.1.</span> <span class="toc-text">schedule_timeout()的实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">1.11.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#页"><span class="toc-number">1.11.1.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区"><span class="toc-number">1.11.2.</span> <span class="toc-text">区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获得页"><span class="toc-number">1.11.3.</span> <span class="toc-text">获得页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmalloc"><span class="toc-number">1.11.4.</span> <span class="toc-text">kmalloc()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gfp-mask标志"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">gfp_mask标志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#行为修饰符"><span class="toc-number">1.11.4.1.1.</span> <span class="toc-text">行为修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#区修饰"><span class="toc-number">1.11.4.1.2.</span> <span class="toc-text">区修饰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类型"><span class="toc-number">1.11.4.1.3.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kfree"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">kfree()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmalloc"><span class="toc-number">1.11.5.</span> <span class="toc-text">vmalloc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slab层"><span class="toc-number">1.11.6.</span> <span class="toc-text">slab层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#slab层的设计"><span class="toc-number">1.11.6.0.1.</span> <span class="toc-text">slab层的设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab分配器接口"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">slab分配器接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在栈上的静态分配"><span class="toc-number">1.11.7.</span> <span class="toc-text">在栈上的静态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单页内核栈"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">单页内核栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高端内存的映射"><span class="toc-number">1.11.8.</span> <span class="toc-text">高端内存的映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#永久映射"><span class="toc-number">1.11.8.1.</span> <span class="toc-text">永久映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#临时映射"><span class="toc-number">1.11.8.2.</span> <span class="toc-text">临时映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每个CPU的分配"><span class="toc-number">1.11.9.</span> <span class="toc-text">每个CPU的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新的每个CPU接口"><span class="toc-number">1.11.9.1.</span> <span class="toc-text">新的每个CPU接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟文件系统"><span class="toc-number">1.12.</span> <span class="toc-text">虚拟文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统抽象层"><span class="toc-number">1.12.1.</span> <span class="toc-text">文件系统抽象层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix文件系统"><span class="toc-number">1.12.2.</span> <span class="toc-text">Unix文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VFS对象及其数据结构"><span class="toc-number">1.12.3.</span> <span class="toc-text">VFS对象及其数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超级块对象"><span class="toc-number">1.12.4.</span> <span class="toc-text">超级块对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超级块操作"><span class="toc-number">1.12.5.</span> <span class="toc-text">超级块操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引节点对象"><span class="toc-number">1.12.6.</span> <span class="toc-text">索引节点对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引节点操作"><span class="toc-number">1.12.7.</span> <span class="toc-text">索引节点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录项对象"><span class="toc-number">1.12.8.</span> <span class="toc-text">目录项对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#目录项状态"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">目录项状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目录项缓存"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">目录项缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录项操作"><span class="toc-number">1.12.9.</span> <span class="toc-text">目录项操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件对象"><span class="toc-number">1.12.10.</span> <span class="toc-text">文件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件操作"><span class="toc-number">1.12.11.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和文件系统相关的数据结构"><span class="toc-number">1.12.12.</span> <span class="toc-text">和文件系统相关的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和进程相关的数据结构"><span class="toc-number">1.12.13.</span> <span class="toc-text">和进程相关的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#块I-O层"><span class="toc-number">1.13.</span> <span class="toc-text">块I&#x2F;O层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#剖析一个块设备"><span class="toc-number">1.13.1.</span> <span class="toc-text">剖析一个块设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区与缓冲区头"><span class="toc-number">1.13.2.</span> <span class="toc-text">缓冲区与缓冲区头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bio结构体"><span class="toc-number">1.13.3.</span> <span class="toc-text">bio结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O向量"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">I&#x2F;O向量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求队列"><span class="toc-number">1.13.4.</span> <span class="toc-text">请求队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O调度程序"><span class="toc-number">1.13.5.</span> <span class="toc-text">I&#x2F;O调度程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O调度程序的工作"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">I&#x2F;O调度程序的工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linus电梯"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">Linus电梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最终期限I-O调度程序"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">最终期限I&#x2F;O调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#预测I-O调度程序"><span class="toc-number">1.13.5.4.</span> <span class="toc-text">预测I&#x2F;O调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完全公正的排队I-O调度程序-CFQ"><span class="toc-number">1.13.5.5.</span> <span class="toc-text">完全公正的排队I&#x2F;O调度程序(CFQ)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空操作的I-O调度程序"><span class="toc-number">1.13.5.6.</span> <span class="toc-text">空操作的I&#x2F;O调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O调度程序的选择"><span class="toc-number">1.13.5.7.</span> <span class="toc-text">I&#x2F;O调度程序的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程地址空间"><span class="toc-number">1.14.</span> <span class="toc-text">进程地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间"><span class="toc-number">1.14.1.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存描述符"><span class="toc-number">1.14.2.</span> <span class="toc-text">内存描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分配内存描述符"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">分配内存描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#撤销内存描述符"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">撤销内存描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mm-struct与内核线程"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">mm_struct与内核线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存区域"><span class="toc-number">1.14.3.</span> <span class="toc-text">虚拟内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VMA标志"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">VMA标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VMA操作"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">VMA操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存区域的树型结构和内存区域的链表结构"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">内存区域的树型结构和内存区域的链表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实际中使用的内存区域文件"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">实际中使用的内存区域文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作内存区域"><span class="toc-number">1.14.4.</span> <span class="toc-text">操作内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-和do-mmap-创建地址区间"><span class="toc-number">1.14.5.</span> <span class="toc-text">mmap()和do_mmap():创建地址区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mummap-和do-mummap-：删除地址区间"><span class="toc-number">1.14.5.1.</span> <span class="toc-text">mummap()和do_mummap()：删除地址区间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">1.14.6.</span> <span class="toc-text">页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页高速缓存和页回写"><span class="toc-number">1.15.</span> <span class="toc-text">页高速缓存和页回写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存手段"><span class="toc-number">1.15.1.</span> <span class="toc-text">缓存手段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#写缓存"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">写缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存回收"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">缓存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#最近最少使用"><span class="toc-number">1.15.1.2.1.</span> <span class="toc-text">最近最少使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双链策略"><span class="toc-number">1.15.1.2.2.</span> <span class="toc-text">双链策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux页高速缓存"><span class="toc-number">1.15.2.</span> <span class="toc-text">Linux页高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#address-space对象"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">address_space对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#address-spcae操作"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">address_spcae操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基树"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">基树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区高速缓存"><span class="toc-number">1.15.3.</span> <span class="toc-text">缓冲区高速缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flusher线程"><span class="toc-number">1.15.4.</span> <span class="toc-text">flusher线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#膝上型计算机模式"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">膝上型计算机模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备与模块"><span class="toc-number">1.16.</span> <span class="toc-text">设备与模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设备类型"><span class="toc-number">1.16.1.</span> <span class="toc-text">设备类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块"><span class="toc-number">1.16.2.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hello-World"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">Hello, World!</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构建模块"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">构建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#放在内核源代码树中"><span class="toc-number">1.16.2.2.1.</span> <span class="toc-text">放在内核源代码树中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#放在内核代码外"><span class="toc-number">1.16.2.2.2.</span> <span class="toc-text">放在内核代码外</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装模块"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">安装模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#产生模块依赖性"><span class="toc-number">1.16.2.4.</span> <span class="toc-text">产生模块依赖性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#载入模块"><span class="toc-number">1.16.2.5.</span> <span class="toc-text">载入模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卸载模块"><span class="toc-number">1.16.2.6.</span> <span class="toc-text">卸载模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管理配置选项"><span class="toc-number">1.16.2.7.</span> <span class="toc-text">管理配置选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块参数"><span class="toc-number">1.16.2.8.</span> <span class="toc-text">模块参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导出符号表"><span class="toc-number">1.16.2.9.</span> <span class="toc-text">导出符号表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设备模型"><span class="toc-number">1.16.3.</span> <span class="toc-text">设备模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kobject"><span class="toc-number">1.16.3.0.1.</span> <span class="toc-text">kobject</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ktype"><span class="toc-number">1.16.3.1.</span> <span class="toc-text">ktype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kset"><span class="toc-number">1.16.3.2.</span> <span class="toc-text">kset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管理和操作kobject"><span class="toc-number">1.16.3.3.</span> <span class="toc-text">管理和操作kobject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数"><span class="toc-number">1.16.3.4.</span> <span class="toc-text">引用计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysfs"><span class="toc-number">1.16.4.</span> <span class="toc-text">sysfs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sysfs中添加和删除kobject"><span class="toc-number">1.16.4.1.</span> <span class="toc-text">sysfs中添加和删除kobject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向sysfs中添加文件"><span class="toc-number">1.16.4.2.</span> <span class="toc-text">向sysfs中添加文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#默认属性"><span class="toc-number">1.16.4.2.1.</span> <span class="toc-text">默认属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建新属性和删除新属性"><span class="toc-number">1.16.4.2.2.</span> <span class="toc-text">创建新属性和删除新属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysfs约定"><span class="toc-number">1.16.4.2.3.</span> <span class="toc-text">sysfs约定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核事件层"><span class="toc-number">1.16.5.</span> <span class="toc-text">内核事件层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试"><span class="toc-number">1.17.</span> <span class="toc-text">调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printk"><span class="toc-number">1.17.1.</span> <span class="toc-text">printk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#日志等级"><span class="toc-number">1.17.1.1.</span> <span class="toc-text">日志等级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记录缓冲区"><span class="toc-number">1.17.1.2.</span> <span class="toc-text">记录缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syslogd和klogd"><span class="toc-number">1.17.1.3.</span> <span class="toc-text">syslogd和klogd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oops"><span class="toc-number">1.17.2.</span> <span class="toc-text">oops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ksymoops"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">ksymoops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kallsyms"><span class="toc-number">1.17.2.2.</span> <span class="toc-text">kallsyms</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核调试配置选项"><span class="toc-number">1.17.3.</span> <span class="toc-text">内核调试配置选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引发bug并打印信息"><span class="toc-number">1.17.4.</span> <span class="toc-text">引发bug并打印信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统请求键"><span class="toc-number">1.17.5.</span> <span class="toc-text">系统请求键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核调试器"><span class="toc-number">1.17.6.</span> <span class="toc-text">内核调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gdb"><span class="toc-number">1.17.6.1.</span> <span class="toc-text">gdb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kgdb"><span class="toc-number">1.17.6.2.</span> <span class="toc-text">kgdb</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#探测系统"><span class="toc-number">1.17.7.</span> <span class="toc-text">探测系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可移植性"><span class="toc-number">1.18.</span> <span class="toc-text">可移植性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可移植性操作系统"><span class="toc-number">1.18.1.</span> <span class="toc-text">可移植性操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字长和数据类型"><span class="toc-number">1.18.2.</span> <span class="toc-text">字长和数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据对齐"><span class="toc-number">1.18.3.</span> <span class="toc-text">数据对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节顺序"><span class="toc-number">1.18.4.</span> <span class="toc-text">字节顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间"><span class="toc-number">1.18.5.</span> <span class="toc-text">时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页长度"><span class="toc-number">1.18.6.</span> <span class="toc-text">页长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理器排序"><span class="toc-number">1.18.7.</span> <span class="toc-text">处理器排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMP、内核抢占、高端内存"><span class="toc-number">1.18.8.</span> <span class="toc-text">SMP、内核抢占、高端内存</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">nuoye's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Linux内核设计与实现》</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-10 21:49:40"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">24.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 77 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Linux内核设计与实现"><a href="#Linux内核设计与实现" class="headerlink" title="Linux内核设计与实现"></a>Linux内核设计与实现</h1><h2 id="操作系统和内核简介"><a href="#操作系统和内核简介" class="headerlink" title="操作系统和内核简介"></a>操作系统和内核简介</h2><p>处理器上任何指定时间点上的活动必然概况为下列三者之一（当CPU空闲时，相当于运行一个空间程，运行于内核空间）：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1585145258.jpg" alt="应用程序、内核和硬件的关系"></p>
<h3 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h3><ol>
<li>无libc库也无标准头文件</li>
<li>没有内存保护机制</li>
<li>不要轻易在内核中使用浮点数</li>
<li>容积小而固定的栈</li>
<li>同步和并发</li>
</ol>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程就是处于执行器的程序，并包括其资源（如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或一个的执行线程，还有数据段等）。</p>
<p>执行线程，简称线程。每个线程都拥有一个独立的程序计算器、进程栈和一组进程寄存器。内核调度的对象是线程而非进程。</p>
<p>进程是处于执行期的程序以及相关的资源的总称。</p>
<h3 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h3><p>内核把进程的列表存放在叫做任务队列的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构（定义在&lt;linux/sched.h&gt;文件中）</p>
<h4 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h4><p>linux通过slab分配器分配task_struct结构。</p>
<p>struct thread_info在文件&lt;asm/thread_info.h&gt;中定义。</p>
<p>内核通过一个唯一的进程标识值或PID来标识每个进程。</p>
<p>系统管理员可通过修改/proc/sys/kernel/pid_max来提高进程最大数目的上限。</p>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>进程描述符中的state域描述了进程的当前状态。每个进程都必然处于五种进程状态中的一种：</p>
<p>TASK_RUNNING（运行）——进程是可执行的；它或正在执行，或在运行队列中等待执行。这是进程在用户控件中执行的唯一可能状态；该状态也可以应用到内核空间中正在执行的进程。</p>
<p>TASK_INTERRUPTLBLE（可中断）——进程正在睡眠（即阻塞），等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。</p>
<p>TASK_UNINTERRUPTLBLE（不可中断）——除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。</p>
<p>_TASK_TRACED——被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</p>
<p>_TASK_STOPPED（停止）——进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号时。此外，在调试期间接收到任何信号，都会使进程进入这种状态。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1585215912.png" alt="进程状态转化"></p>
<h5 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_task_state(task, state);</span><br><span class="line">set_current_state(state);<span class="comment">//等同于set_task_state(current, state);</span></span><br></pre></td></tr></table></figure>

<h5 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h5><p>即当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出时，程序恢复，在用户空间会继续执行。</p>
<p>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><h4 id="fork-与exec"><a href="#fork-与exec" class="headerlink" title="fork()与exec()"></a>fork()与exec()</h4><p>fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID和某些资源和统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。</p>
<h4 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h4><p>Linux的fork()使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p>只有在需要写入时，数据才会被复制，从而使各个进程拥有各自的拷贝。</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>Linux通过clone()系统调用实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要的共享资源。fork()、vfork()、和__clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。</p>
<p>do_fork的定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程开始运行。copy_process()函数的工作如下：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。</li>
<li>检查并确保新创建的这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</li>
<li>子进程中的进程描述符内的许多成员都要被清0或设为初始值。主要是统计信息。task_struct中的大多数数据都依然未被修改。</li>
<li>子进程的状态被设置为TASK_UNINTERRUPTLBLE，以保证它不会投入运行。</li>
<li>copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0.表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。</li>
<li>调用alloc_pid()为新进程分配一个有效的PID。</li>
<li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针。</li>
</ol>
<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其投入运行，内核有意选择子进程先执行。（因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销。）</p>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h4><p>除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。</p>
<p>vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的。</p>
<ol>
<li>在调用copy_process()时，task_struct的vfork_done成员被设置为NULL。</li>
<li>在执行do_fork()时，如果给定特别标志，则vfork_done会指向一个特定地址。</li>
<li>子进程先开始执行后，父进程不是马上恢复执行，而是一直等到，直到子进程通过vfork_done指针向他发送信号。</li>
<li>在调用mm_release()时，该函数用于进程退出内存地址空间，并且检查vfork_done是否为空，如果不为空，则会向父进程发送信号。</li>
<li>回到do_fork()，父进程醒来并返回。</li>
</ol>
<h3 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>一个普通的fork()的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>其中SIGCHLD为参数标志，在&lt;linux/sched.h&gt;中定义了clone()用到的参数标志及其作用。</p>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核线程——独立运行在内核空间的标准线程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，仅在内核空间运行，从来不切换到用户空间去。</p>
<p>内核线程只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在&lt;linux/kthread.h&gt;中申明有接口。从现有内核线程中创建一个新的内核线程的方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *kthread_create(int (*threadfn)(void *data)), void *data, const char namefmt[], ...)</span><br></pre></td></tr></table></figure>

<p>新的任务是由kthread内核进程通过clone()系统调用而创建的。新的进程将允许threadfn函数，给其传递的参数为data。进程名为namefmt，接受可变参数列表类似于printf()的格式化参数。新创建的进程处于不可运行状态，需通过wake_upprocess()明确唤醒它。</p>
<p>创建一个进程并让它运行起来，可以通过调用kthread_run()来达到：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *kthread_run(int (*threadfn)(void *data)), void *data, const char namefmt[], ...)</span><br></pre></td></tr></table></figure>

<p>该例程以宏实现，仅简单地调用了kthread_create()和wake_up_process()。</p>
<p>内核线程启动后就一直运行知道调用do_exit()退出，或者内核的其他部分调用kthread_stop()退出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中k为kthread_create返回的task_struct结构。</p>
<h4 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h4><p>一般来说，进程的析构是自身引起的。它发生在进程调用exit()系统调用时（既可能显式调用这个系统调用，也可能隐式地从某个程序的主函数返回）。当进程接受到它既不能处理也不能忽略的信号或异常时，它还可能被动终结。但不管如何终结的，任务大部分都要靠do_exit()（定义于&lt;kernel/exit.c&gt;中）来完成：</p>
<ol>
<li>将task_struct中的标志成员设置为PF_EXITNG。</li>
<li>调用del_timer_sync()删除任一内核定时器。根据返回结果，确保没有定时器在排队，也没有定时器处理程序在运行。</li>
<li>如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记账信息。</li>
<li>然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（即没有被共享），就彻底释放。</li>
<li>接下来调用sem_exit()函数。如果进程排队等候IPC信号，则离开队列。</li>
<li>调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。若其中某个引用计数的数值降为0，那么就代表没有进程在使用相应的资源，此时可以释放。</li>
<li>接着把存放在task_struct的exit_code成员中的任务退出代码置为exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。</li>
<li>调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态（存放在task_struct结构的exit_state中）设置成EXIT_ZOMBIE。</li>
<li>do_exit()调用schedule()切换到新的进程（因为EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回）。</li>
</ol>
<p>至此，进程所占用的所有内存就是内核栈、thread_info结构和task_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，由进程所持有的剩余内存被释放，归还给系统使用。</p>
<h5 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h5><p>进程终结时所需的清理工作和进程描述符的删除被分开执行。</p>
<p>wait()这一族函数都是通过唯一的一个系统调用wait4()来实现的。其标准动作是挂起调用它的进程，直到其中一个子进程退出，此时函数会返回该子进程的PID。此时，调用该函数时提供的指针会包含子函数退出时的退出代码。</p>
<p>当最终需要释放进程描述符时，release_task()会被调用：</p>
<ol>
<li>它调用__exit_signal()，该函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程。</li>
<li>__exit_signal()释放目前僵死进程所使用是所有剩余资源，并进行最终统计和记录。</li>
<li>如果这个进程是线程组最后一个进程，并且领头进程以及死掉，那么release_task()就要通知僵死的领头进程父进程。</li>
<li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占用的slab高速缓存。</li>
</ol>
<h5 id="孤儿进程的解决"><a href="#孤儿进程的解决" class="headerlink" title="孤儿进程的解决"></a>孤儿进程的解决</h5><p>对于孤儿进程退出时处于僵死状态白白浪费内存放问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。</p>
<ol>
<li>在do_exit()中会调用exi_notify()，该函数会调用forget_original_parent()，而后者会调用find_new_reaper来执行寻父过程。</li>
<li>当找到合适的养父进程时，只需要遍历所有子进程并为它们设置新的父进程。</li>
<li>然后调用ptrace_exit_finish()，同样进行新的寻父进程，不过这次是给ptraced的子进程寻找父亲。</li>
</ol>
<p>一旦系统为进程找到并设置了新的父进程，就不会再出现驻留僵死进程的情况。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>多任务系统可以划分为两类：非抢占式多任务和抢占式多任务。</p>
<p>Linux提供了抢占式多任务模式。此模式下，由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行的机会。这个强制的挂起动作叫做抢占。</p>
<p>在非抢占式多任务模式下，除非进程自己主动退出，否则它会一直执行。进程主动挂起自己的操作称为让步。</p>
<h3 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h3><p>O(l)调度器</p>
<ol>
<li>静态时间片算法</li>
<li>运行队列</li>
<li>反转楼梯最后期限调度算法(RSDL)</li>
<li>完全公平调度算法(CFS)</li>
</ol>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><h4 id="I-O消耗性和处理器消耗型进程"><a href="#I-O消耗性和处理器消耗型进程" class="headerlink" title="I/O消耗性和处理器消耗型进程"></a>I/O消耗性和处理器消耗型进程</h4><p>I/O消耗型进程指进程的大部分时间用来提交I/O请求或者等待I/O请求。这样的进程经常处于可运行状态，但通常都是运行短短一会儿。</p>
<p>处理器消耗型进程大部分时间都在执行代码上，除非被抢占，否则它们通常都一直不停地运行，因为它们没有太多的I/O需求。对于这类进程，调度策略往往是尽量降低它们的调度频率，而延长其运行时间。</p>
<p>调度策略通常要在两个矛盾的目标中间寻求平衡：进程响应迅速和最大系统利用率。Linux为了保证交互应用和桌面系统的性能，所以对进程的响应做了优化，更倾向于优先调度I/O消耗型进程。</p>
<h4 id="进程优化级"><a href="#进程优化级" class="headerlink" title="进程优化级"></a>进程优化级</h4><p>Linux采用两种不同的优先级范围：</p>
<ol>
<li>第一种是nice值，范围从-20到+19，默认值为0，越大的nice值意味着更低的优先级。在Linux中，nice值代表时间片的比例。可以通过ps -el命令查看，NI值即为nice值。</li>
<li>第二种是实时优先级，默认情况下变化范围是0到99。越高的实时优化级意味着进程优先级越高。任何实时进程的优先级都高于普通的进程。可用ps -eo state,uid,pid,ppid,rtprio,time,comm查看，其中rtprio为实时优先级，若为”-“,则说明不是实时进程。</li>
</ol>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。</p>
<p>Linux下，是否要将一个进程立刻投入运行，是完全由进程优先级和是否有时间片决定的。在新的CFS调度器中，其抢占时机取决于心底 可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行。</p>
<h4 id="调度策略活动"><a href="#调度策略活动" class="headerlink" title="调度策略活动"></a>调度策略活动</h4><h3 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h3><h4 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h4><p>linux调度器是以模块方式提供的。这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义在kernel/sched.c文件中。它会安装优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类生出，去选择下面要执行的那个程序。</p>
<p>完全公平调度(CFS)是一个针对普通进程的调度类，在Linux中称为SCHED_NORMAL，定义在kernel/sched_fair.c中。</p>
<h4 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h4><p>CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将能获得1/n的处理器时间。同时，完美可以调度给它们无限小的时间周期，所以在任何可测量周期内，我们给予n个进程中每个进程同样多的运行时间。</p>
<p>CFS允许每个进程运行一段时间、循环轮转、选择运行时间最少的程序作为下一个运行程序。nice值在CFS中被作为进程获得的处理器运行比重。</p>
<p>CFS引入了每个进程获得的时间片底线，这个底线称为最小粒度。默认情况下这个值是1ms。</p>
<h3 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h3><h4 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h4><h5 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h5><p>CFS使用调度器实体结构（定义在&lt;linux/sched.h&gt;的struct_sched_entity中）来追踪进程运行记账。</p>
<p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符内。</p>
<h5 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h5><p>vruntime变量存放进程的虚拟运行时间，该运行时间（花在运行商的时间和）的计算是经过了所有可运行进程总数的标准化。虚拟时间是以ns为单位的。CFS用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p>
<p>在kernel/sched_fair.c中的update_curr()函数实现了该记账功能。</p>
<p>update_curr()计算了当前进程的执行时间，并且将其存放在变量delta_exec中。然后又将运行时间传递给了__update_curr()，由后者再根据当前可运行进程总数对运行时间进程加权计算。最终将上述的权重值与当前运行进程的vruntime相加。</p>
<p>update_curr()是由系统定时器周期性调用的。</p>
<h4 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h4><p>CFS调度算法的核心：选择具有最小vruntime的任务。</p>
<p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。</p>
<h5 id="挑选下一个任务"><a href="#挑选下一个任务" class="headerlink" title="挑选下一个任务"></a>挑选下一个任务</h5><p>实现这一过程的函数是__pick_next_entity()，它定义在kernel/sched_fair.c中。</p>
<h5 id="向树中加入进程"><a href="#向树中加入进程" class="headerlink" title="向树中加入进程"></a>向树中加入进程</h5><p>CFS将进程加入红黑树以及缓存最左叶子节点的过程发送在进程变为可执行状态（被唤醒）或者是通过fork()调用第一次创建进程时。</p>
<p>enqueue_entity()函数实现了这一目的。该函数更新运行时间和其他一些统计数据，然后调用__enqueue_entity()进程繁重的插入操作，把数据项真正插入到红黑树中。</p>
<h5 id="从树中删除进程"><a href="#从树中删除进程" class="headerlink" title="从树中删除进程"></a>从树中删除进程</h5><p>删除动作发送在进程堵塞或者终止时。</p>
<p>dequeue_entity()函数实现了这一目的。和添加进程一样，实际工作是由辅助函数__dequeue_entity()完成的。</p>
<h4 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h4><p>进程调度的主要入口点是函数schedule()，定义在kernel/sched.c中。schedule()通常需要和一个具体的调度类相关联。该函数唯一重要的事是调用pick_next_task()，用以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程。</p>
<h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>休眠（被堵塞）的进程处于一个特殊的不可执行状态。内核对于进程休眠的操作如下：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程则恰好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。</p>
<h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核用wake_queue_head_t来代表等待队列。</p>
<p>等待队列可以通过DECLARE_WAITQUEU()静态创建，也可以由init_waitqueue_head()动态创建。</p>
<p>进程通过执行以下步骤将自己加入到一个等待队列中：</p>
<ol>
<li>调用宏DEFINE_WAIT()创建一个等待队列的项。</li>
<li>调用add_wait_queue()把自己加入到队列中。该队列会在进程等待的条件满足时唤醒它。</li>
<li>调用prepare_to_wait()方法将进程的装填变更为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。而且该函数如果有必要的话会将进程加回到等待队列，这是在接下来循环遍历中需要的。</li>
<li>如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程。</li>
<li>当进程被唤醒时，它会再次检查条件是否为真。。如果是，它就退出循环；如果不是，它再次调用schedule()并一直重复这步操作。</li>
<li>当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己移出等待队列。</li>
</ol>
<p>函数inotify_read()位于fs/notify/inotify/inotify_user.c中，负责从通知文件描述符中读取信息。</p>
<h5 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h5><p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。它调用函数try_to_wake_up()，该函数负责将进程设置为TASK_RUNNING状态，调用enqueue_task()将进程放入红黑树，若唤醒的进程优先级比当前正在执行的进程优先级高，还要设置need_resched标志。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1585640196.png" alt="休眠与唤醒"></p>
<h3 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h3><p>上下文奇幻，也就是从一个可执行进程切换到另一个可执行进程，由定义在kernel/sched.c中的context_switch()函数负责。它完成了两项基本工作：</p>
<ol>
<li>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新进程中。</li>
<li>调用声明在&lt;asm/system.h&gt;中的switch_to()，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。</li>
</ol>
<p>内核提供了一个need_resched标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，scheduler_tick()就会设置这个标志：当一个优先级高的进程进入可执行状态的时候，try_to_wake_up()也会设置这个标志，内核检查该标志，确认其被设置，调用schedule()来切换到一个新的进程。</p>
<p>在返回用户空间以及从中断返回的时候，内核也会检查need_resched标志。如果已被设置，内核会在继续执行之前调用调度程序。</p>
<h4 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h4><p>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。用户抢占发生在以下情况时：</p>
<ul>
<li>从系统调用返回用户空间时。</li>
<li>从中断处理程序返回用户空间时。</li>
</ul>
<p>从中断处理程序或者系统系统调用返回的返回路径都是跟体系结构相关的，在entry.s（此文件包含内核入口部分以及内核退出部分的程序）文件中通过汇编语言来实现。</p>
<h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><p>Linux完整地支持内核抢占。只要重新调度是安全的（即没有持有锁），内核可以在任何时间抢占正在执行的任务。</p>
<p>锁是非抢占区域的标志。当使用锁的时候，thread_info中的preempt_count计数器（初始值为0）数值加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。</p>
<p>如果内核中的进程被阻塞了，或者它显式地调用了schedule()，内核抢占也会显式地发生。</p>
<p>内核抢占会发生在：</p>
<ul>
<li>中断处理程序正在执行，且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。</li>
<li>如果内核中的任务显式地调用schedule()。</li>
<li>如果内核中的任务阻塞。</li>
</ul>
<h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。普通的、非实时的调度策略是SCHED_NORMAL。具体实现定义在kernel/sched_rt.c中。</p>
<p>SCHED_FIFO实现了简单的、先入先出的调度算法。处于可运行状态的SCHED_FIFO级进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个SCHED_FIFO进程处于可执行状态，就会一直执行，知道它自己受阻塞或显式地释放处理器为止。只有更高优先级的SCHED_FIFO或SCHED_RR任务才可以抢占它。若有两个或多个同优先级的SCHED_FIFO级进程，它们会轮流执行，但依然只有它们愿意让出处理器时才会退出。</p>
<p>SCHED_RR与SCHED_FIFO大体相同。但SCHED_RR级的进程在耗尽事先分配给他的时间后就不能继续执行了。</p>
<p>实时优先级范围从0到MAX_RT_PRIO减1。SCHED_NORMAL级进程的nice值共享了这个取值空间：从MAX_RT_PRIO到MAX_RT_PRIO+40。即nice从-20到+19直接对应100到139的实时优先级范围。</p>
<h3 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h3><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h3><h3 id="API、POSIX和C库"><a href="#API、POSIX和C库" class="headerlink" title="API、POSIX和C库"></a>API、POSIX和C库</h3><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h4><p>内核记录了系统调用表中所有已注册过的系统调用的列表，存储在sys_call_talbe中。x86-64体系中，定义于arch/i386/kernel/syscall_64.c中。这个表位每一个有效的系统调用指定了唯一的系统调用号。</p>
<h4 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h4><h3 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h3><p>应用程序以某种方式通知系统，从而使系统切换到内核态，从而内核代表应用程序在内核空间执行系统调用。</p>
<p>通知内核机制是通过软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序即为系统调用处理程序。</p>
<h4 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h4><p>在x86上，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做笔记来检查其有效性。如果大于或等于NR_syscalls，该函数返回-ENOSYS。否则，就执行相应的系统调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *sys_call_table(,%rax,8);</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1585746738.jpg" alt="调用系统调用处理程序以执行一个系统调用"></p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><h3 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h3><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的进程。</p>
<p>在进程上下文中，内核可以休眠并且可以被抢占。</p>
<h5 id="绑定一个系统调用的步骤"><a href="#绑定一个系统调用的步骤" class="headerlink" title="绑定一个系统调用的步骤"></a>绑定一个系统调用的步骤</h5><ol>
<li>首先，在系统调用表的最后加入一个表项（计数从0开始）。每种支持该系统调用的硬件体系都必须做这样的工作。</li>
<li>对于所支持的各种体系结构，系统调用号都必须定义于&lt;asm/unistd.h&gt;中。</li>
<li>系统调用必须被编译进内核映像（不能被编译成模块）。即放入kernel/下的一个相关文件中就可以了。</li>
</ol>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>单向链表和双向链表</p>
<p>环形链表</p>
<p>Linux内核的标准链表就是采用环形双向链表形式实现的。</p>
<p>定义于&lt;linux/list.h&gt;</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列为FIFO。</p>
<p>定义于&lt;linux/kfifo.h&gt;</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>Linux内核提供了简单、有效的映射数据结构，但并非一个通用的映射，因为它的目标是：映射一个唯一的标识数(UID)到一个指针。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h4 id="自平衡二叉搜索树"><a href="#自平衡二叉搜索树" class="headerlink" title="自平衡二叉搜索树"></a>自平衡二叉搜索树</h4><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><h5 id="rbtree"><a href="#rbtree" class="headerlink" title="rbtree"></a>rbtree</h5><p>Linux实现的红黑树叫rbtree，定义于lib/rbtree.c中，声明在&lt;linux/rbtree.h&gt;中。</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><h2 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器。</p>
<p>中断本质上是一种特殊的电信号，由硬件设备发向处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。内核随时可能因为新到来的中断而被打断。</p>
<p>中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>异常与中断不同，它在产生时必须考虑与处理器时钟同步。实际上，异常也常常称为同步中断。许多处理器体系结构处理异常与处理中断的方式类似，因此内核对它们的处理也很类似。</p>
<p>在x86体系结构上，通过软中断实现系统调用，那就是陷入内存，然后引起一种特殊的异常——系统调用处理程序异常。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在响应一个特定中断的时候，内核会执行一个函数，该函数叫做中断处理程序或中断服务例程。一个设备的中断处理程序是它设备驱动程序的一部分——设备驱动程序是用于对设备进行管理的内核代码。</p>
<p>中断处理程序与其他内核函数的区别在于：中断处理程序是被内核调用来响应中断的，而它们运行于我们称之为中断上下文的特殊上下文中。中断上下文也称作原子上下文，该上下文中的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>中断处理程序是上半部——接收到一个中断，它就立即开始执行，但只做有严格时限的工作，例如对接受的中断进行应答或复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。</p>
<h3 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h3><p>驱动程序可以通过request_irq()函数注册一个中断处理程序（声明在&lt;linux/interrupt.h&gt;中）。</p>
<h4 id="中断处理程序标志"><a href="#中断处理程序标志" class="headerlink" title="中断处理程序标志"></a>中断处理程序标志</h4><p>定义于&lt;linux/interrupt.h&gt;中。</p>
<h3 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h3><p>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><h3 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1585836310.png" alt="中断从硬件到内核的路径"></p>
<h3 id="proc-interrupts"><a href="#proc-interrupts" class="headerlink" title="/proc/interrupts"></a>/proc/interrupts</h3><p>该文件存放的是系统中与中断相关的统计信息。</p>
<p>procfs代码位于fs/proc中。</p>
<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><h4 id="禁止和激活中断"><a href="#禁止和激活中断" class="headerlink" title="禁止和激活中断"></a>禁止和激活中断</h4><p>禁止：local_irq_disable();</p>
<p>激活：local_irq_enable();</p>
<h2 id="下半部和推后执行的工作"><a href="#下半部和推后执行的工作" class="headerlink" title="下半部和推后执行的工作"></a>下半部和推后执行的工作</h2><p>中断处理流程被分为两部分：第一部分是中断处理程序，内核通过对它的异步执行完成对硬件中断的即时响应；另一部分即为下半部。</p>
<h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><h4 id="下半部的起源——bottom-half-BH"><a href="#下半部的起源——bottom-half-BH" class="headerlink" title="下半部的起源——bottom half(BH)"></a>下半部的起源——bottom half(BH)</h4><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><h4 id="软中断和tasklet"><a href="#软中断和tasklet" class="headerlink" title="软中断和tasklet"></a>软中断和tasklet</h4><p>软中断是一组静态定义的下半部接口，有32个，可以在所有处理器上同时执行——即使两个类型相同也可以。必须在编译期间就进行静态注册。</p>
<p>tasklet是一种基于软中断实现的灵活性强、动态创建的下半部实现机制。两个不同类型的tasklet可以在不同的处理器上同时执行，但相同类型的tasklet不能同时执行。可以通过代码进行动态注册。</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><h4 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h4><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断的代码位于kernel/softirq.c中。</p>
<h4 id="软中断的实现"><a href="#软中断的实现" class="headerlink" title="软中断的实现"></a>软中断的实现</h4><p>软中断是在编译期间静态分配的。</p>
<h5 id="软中断处理程序"><a href="#软中断处理程序" class="headerlink" title="软中断处理程序"></a>软中断处理程序</h5><p>软中断处理程序action的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">softirq_handler</span><span class="params">(struct softirq_action *)</span></span></span><br></pre></td></tr></table></figure>

<p>当内核运行一个软中断处理程序的时候，它就会执行这个action函数，其唯一的参数为指向相应softirq_action结构体的指针。</p>
<h5 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h5><p>一个注册的软中断必须在被标记后才会执行，。这被称作触发软中断。通常，中断处理程序会在返回前标记它的软中断。</p>
<p>在下列地方，待处理的软中断会被检查和执行：</p>
<ul>
<li>从一个硬件中断代码处返回时</li>
<li>在ksoftirqd内核线程中</li>
<li>在显示检查和执行待处理的软中断的代码中。如网络子系统</li>
</ul>
<p>不管什么办法唤起，软中断都要在do_softirq()中执行。</p>
<h4 id="使用软中断"><a href="#使用软中断" class="headerlink" title="使用软中断"></a>使用软中断</h4><p>软中断保留给系统中对时间要求最严格以及最重要的下半部使用。</p>
<h5 id="分配索引"><a href="#分配索引" class="headerlink" title="分配索引"></a>分配索引</h5><p>索引号小的软中断在索引号大的软中断之前执行。</p>
<p>建立一个新的软中断必须在&lt;linux/interrupt.h&gt;中定义的一个枚举类型中加入新的项。</p>
<h5 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h5><p>通过调用open_softirq()注册软中断处理程序，该函数含两个参数：软中断的索引号和处理函数。</p>
<p>软中断处理程序执行时，允许响应中断，但它自己不能休眠。在一个处理程序运行的时候，当前处理器上的软中断被禁止，但其他的处理器仍可以执行别的软中断。</p>
<h5 id="触发软中断"><a href="#触发软中断" class="headerlink" title="触发软中断"></a>触发软中断</h5><p>raise_softirq()函数可以将一个软中断设置为挂起状态，让它在下次调用do_softirq()函数时投入运行。</p>
<h3 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h3><h4 id="tasklet的实现"><a href="#tasklet的实现" class="headerlink" title="tasklet的实现"></a>tasklet的实现</h4><h5 id="tasklet结构体"><a href="#tasklet结构体" class="headerlink" title="tasklet结构体"></a>tasklet结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中state只能在0、TASKLET_STATE_SCHED（已被调度，正准备投入运行）和TASKLET_STATE_RUN（正在运行）之间取值。</p>
<p>若count不为0，则tasklet被禁止，不允许执行。当count为0时，tasklet被激活，并且在设置为挂起状态时，该tasklet才能够执行。</p>
<h5 id="调度tasklet"><a href="#调度tasklet" class="headerlink" title="调度tasklet"></a>调度tasklet</h5><p>已调度的tasklet存放在两个单处理器数据结构：tasklet_vec（普通）和tasklet_hi_vec（高优先级）。这两个数据结构都是由tasklet_struct结构体构成的量表。链表中每个tasklet_struct代表一个不同的tasklet。</p>
<p>tasklet由tasklet_schedule()和tasklet_hi_scheduler()函数进行调度。</p>
<p>tasklet_schedule()的执行步骤：</p>
<ol>
<li>检查tasklet的状态是否为TASKLET_STATE_SCHED。如果是，说明tasklet已被调度过了，函数立即返回。</li>
<li>调用_tasklet_schedule()。</li>
<li>保存中断状态，然后禁止本地中断。</li>
<li>把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或tasklet_hi_vec链表的表头上去。</li>
<li>唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</li>
<li>恢复中断到原状态并返回。</li>
</ol>
<p>tasklet_action()和tasklet_hi_action()：</p>
<ol>
<li>禁止中断，并为当前处理器检索tasklet_vec或tasklet_hig_vec链表。</li>
<li>将当前处理器上的该链表设置为NULL，达到清空的效果。</li>
<li>允许响应中断。</li>
<li>循环遍历获得链表上的每一个待处理的tasklet。</li>
<li>如果是多处理器系统，通过检查TASKLET_STATE_RUN来判断这个tasklet是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理器的tasklet去。</li>
<li>如果当前这个tasklet没有执行，将其状态设置为TASKLET_STATE_RUN。</li>
<li>检查count值是否为0，确保tasklet没有被禁止；如果被禁止了，则跳转到下一个挂起的tasklet去。</li>
<li>执行tasklet的处理器程序。</li>
<li>tasklet运行完毕，清楚state域的TASK_STATE_RUN状态标志。</li>
<li>重复执行下一个tasklet，直至没有剩余等待处理的tasklet。</li>
</ol>
<h4 id="使用tasklet"><a href="#使用tasklet" class="headerlink" title="使用tasklet"></a>使用tasklet</h4><h5 id="声明一个tasklet"><a href="#声明一个tasklet" class="headerlink" title="声明一个tasklet"></a>声明一个tasklet</h5><p>静态创建（&lt;linux/interruot.h&gt;中定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name, func, data);	<span class="comment">//count = 0</span></span><br><span class="line">DECLARE_TASKLET_DISABLED(name, func, data);	<span class="comment">//count = 1</span></span><br></pre></td></tr></table></figure>

<p>动态创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_init(t, tasklet_handler, dev);</span><br></pre></td></tr></table></figure>

<h5 id="编写tasklet处理程序"><a href="#编写tasklet处理程序" class="headerlink" title="编写tasklet处理程序"></a>编写tasklet处理程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="调度tasklet-1"><a href="#调度tasklet-1" class="headerlink" title="调度tasklet"></a>调度tasklet</h5><p>一个tasklet总在调度它的处理器上执行，以希望能更好地利用处理器的高速缓存。</p>
<p>可以调用tasklet_disable()来禁止某个指定的tasklet（若该tasklet正在执行，这个函数会等到它执行完毕再返回）。tasklet_disable_nosync()函数也可以用来禁止，无须在返回前等待tasklet执行完毕。</p>
<p>tasklet_enable()可以激活一个tasklet。</p>
<p>tasklet_kill()函数可以从挂起的队列中去掉一个tasklet。这个函数首先等待该tasklet执行完毕，然后再将它移去。</p>
<h5 id="ksoftirqd"><a href="#ksoftirqd" class="headerlink" title="ksoftirqd"></a>ksoftirqd</h5><p>每个cpu上都分配有一个ksoftirqd/n线程。一旦该线程被初始化，会执行死循环（优先级较低）。只要有待处理的软中断，ksoftirqd就会调用do_softirq()去处理。当所有需要执行的操作都完成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。</p>
<p>只要do_softirq()函数发现一家执行过的内核线程重新出发了它自己，软中断内核线程就会被唤醒。</p>
<h4 id="老的BH机制"><a href="#老的BH机制" class="headerlink" title="老的BH机制"></a>老的BH机制</h4><h3 id="工作队列-1"><a href="#工作队列-1" class="headerlink" title="工作队列"></a>工作队列</h3><p>工作队列可以把工作推后，交由一个内核线程去执行。工作队列允许重新调度甚至是睡眠。</p>
<h4 id="工作队列的实现"><a href="#工作队列的实现" class="headerlink" title="工作队列的实现"></a>工作队列的实现</h4><p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。创建的这些内核线程称作工作者线程。</p>
<h5 id="表示线程的数据结构"><a href="#表示线程的数据结构" class="headerlink" title="表示线程的数据结构"></a>表示线程的数据结构</h5><p>工作者线程的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_strcut</span> <span class="title">cpu_wq</span>[<span class="title">NR_CPUS</span>];</span>	<span class="comment">//定义在kernel/workqueue.c中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> sinqlethread;</span><br><span class="line">	<span class="keyword">int</span> freezeable;</span><br><span class="line">	<span class="keyword">int</span> rt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="表示工作的数据结构"><a href="#表示工作的数据结构" class="headerlink" title="表示工作的数据结构"></a>表示工作的数据结构</h5><p>工作用&lt;linux/workqueue.h&gt;中定义的work_struct结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>worker_thread()：</p>
<ol>
<li>线程将自己设置为休眠状态，并把自己加入到等待队列中。</li>
<li>如果工作链表是空的，线程调用schedule()函数进入睡眠状态。</li>
<li>如果链表中有对象，线程不会睡眠，它将自己设置成TASK_RUNNING，脱离等待队列。</li>
<li>如果链表非空，调用run_workqueue()函数执行被推后的工作。</li>
</ol>
<p>run_workqueue()函数遍历链表上每个待处理的工作，执行链表每个节点上的workqueue_struct中的func成员。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1586338843.png" alt="工作、工作队列和工作者线程之间的关系"></p>
<h4 id="使用工作队列"><a href="#使用工作队列" class="headerlink" title="使用工作队列"></a>使用工作队列</h4><h5 id="创建推后的工作"><a href="#创建推后的工作" class="headerlink" title="创建推后的工作"></a>创建推后的工作</h5><p>静态创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(name, <span class="keyword">void</span> (*func) (<span class="keyword">void</span> *), <span class="keyword">void</span> *data);</span><br></pre></td></tr></table></figure>

<p>动态创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(struct work_struct *work, <span class="keyword">void</span>(*func) (<span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span><br></pre></td></tr></table></figure>

<h5 id="工作队列处理函数"><a href="#工作队列处理函数" class="headerlink" title="工作队列处理函数"></a>工作队列处理函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work_handler</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="对工作进程调度"><a href="#对工作进程调度" class="headerlink" title="对工作进程调度"></a>对工作进程调度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule_work(&amp;work);	<span class="comment">//立即执行</span></span><br><span class="line"></span><br><span class="line">schedule_delayed_work(&amp;work, <span class="built_in">delay</span>);	<span class="comment">//延迟执行</span></span><br></pre></td></tr></table></figure>

<h5 id="刷新操作"><a href="#刷新操作" class="headerlink" title="刷新操作"></a>刷新操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>执行后函数会一直等到，直到队列中所有对象都被执行以后才返回。</p>
<p>注：该函数并不取消任何延迟执行任务。取消延迟执行工作应调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_delayed_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="创建新的工作队列"><a href="#创建新的工作队列" class="headerlink" title="创建新的工作队列"></a>创建新的工作队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delat_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work,unsignde <span class="keyword">long</span> <span class="built_in">delay</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>刷新：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_workqueue(struct workqueue_struct *wq);</span><br></pre></td></tr></table></figure>

<h2 id="内核同步介绍"><a href="#内核同步介绍" class="headerlink" title="内核同步介绍"></a>内核同步介绍</h2><h3 id="临界区和条件竞争"><a href="#临界区和条件竞争" class="headerlink" title="临界区和条件竞争"></a>临界区和条件竞争</h3><p>临界区就是访问和操作共享数据的代码段。</p>
<p>避免并发和防止条件竞争称为同步。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>内核中造成并发执行的原因：</p>
<ul>
<li>中断</li>
<li>软中断和tasklet</li>
<li>内核抢占</li>
<li>睡眠及用户空间的同步</li>
<li>对称多处理</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="争用和扩展性"><a href="#争用和扩展性" class="headerlink" title="争用和扩展性"></a>争用和扩展性</h3><p>锁的争用（简称争用），是指当锁正在被占用时，有其他线程试图获得该锁。</p>
<h2 id="内核同步方法"><a href="#内核同步方法" class="headerlink" title="内核同步方法"></a>内核同步方法</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作即不能被分割的指令。</p>
<h4 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h4><p>针对整数的原子操作只能对atomic_t类型的数据进行处理。atomic_t类型定义在&lt;linux/types.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>

<p>原子整数操作的声明都在&lt;asm/atomic.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic_set(&amp;v,<span class="number">4</span>);	<span class="comment">//v = 4;</span></span><br><span class="line">atomic_add(<span class="number">2</span>,&amp;v);	<span class="comment">//v = v + 2;</span></span><br><span class="line">atomic_inc(&amp;v);		<span class="comment">//v = v + 1;</span></span><br></pre></td></tr></table></figure>

<p>可用atomic_read()将atomic_t转换为int型。</p>
<h4 id="64位原子操作"><a href="#64位原子操作" class="headerlink" title="64位原子操作"></a>64位原子操作</h4><p>atomic64_t：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic64_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h4><p>定义在&lt;asm/bitops.h&gt;中。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁最多只能被一个可执行线程持有。</p>
<p>一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋。</p>
<h4 id="自旋锁方法"><a href="#自旋锁方法" class="headerlink" title="自旋锁方法"></a>自旋锁方法</h4><p>自旋锁的实现与体系结构密切相关，与体系结构相关的代码定义在&lt;asm/spinlock.h&gt;中，接口定义在&lt;linux/spinlock.h&gt;中。自旋锁的基本使用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line">spin_lock(&amp;mr_lock);</span><br><span class="line">...</span><br><span class="line">spin_unlock(&amp;mr_lock);</span><br></pre></td></tr></table></figure>

<p>自旋锁可以使用在中断处理程序中。所以在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">spin_lock_irqsave(&amp;mr_lock, flags);</span><br><span class="line">...</span><br><span class="line">spin_unlock_irqrestore(&amp;mr_lock, flags);</span><br></pre></td></tr></table></figure>

<h4 id="其他针对自旋锁的操作"><a href="#其他针对自旋锁的操作" class="headerlink" title="其他针对自旋锁的操作"></a>其他针对自旋锁的操作</h4><h4 id="自旋锁和下半部"><a href="#自旋锁和下半部" class="headerlink" title="自旋锁和下半部"></a>自旋锁和下半部</h4><h3 id="读-写自旋锁"><a href="#读-写自旋锁" class="headerlink" title="读-写自旋锁"></a>读-写自旋锁</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>Linux中的信号量是一种睡眠锁：如果有一个任务试图获得一个不可用（已被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。当持有的信号量可用（被释放）后，处于等待队列中 的那个任务将被唤醒，并获得该信号量。</p>
<h4 id="计数信号量和二值信号量"><a href="#计数信号量和二值信号量" class="headerlink" title="计数信号量和二值信号量"></a>计数信号量和二值信号量</h4><p>二值信号量又称互斥信号量。</p>
<h4 id="创建和初始化信号量"><a href="#创建和初始化信号量" class="headerlink" title="创建和初始化信号量"></a>创建和初始化信号量</h4><p>信号量的实现与体系结构相关，具体定义在&lt;asm/semaphore.h&gt;。</p>
<h4 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h4><h3 id="读-写信号量"><a href="#读-写信号量" class="headerlink" title="读-写信号量"></a>读-写信号量</h3><p>定义在文件&lt;linux/rwsem.h&gt;中。</p>
<p>所有的读-写信号量都是互斥信号量。</p>
<h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><h3 id="完成变量"><a href="#完成变量" class="headerlink" title="完成变量"></a>完成变量</h3><p>完成变量由结构completion表示，定义在&lt;linux/completion.h&gt;中。</p>
<h3 id="BKL：大内核锁"><a href="#BKL：大内核锁" class="headerlink" title="BKL：大内核锁"></a>BKL：大内核锁</h3><p>BKL的一些特性：</p>
<ul>
<li><p>持有BKL的任务仍然可睡眠。</p>
</li>
<li><p>BKL是一种递归锁。</p>
</li>
<li><p>BKL只可以用在进程上下文中。</p>
</li>
<li><p>新的用户不允许使用BKL</p>
</li>
</ul>
<p>BKL在被持有时同样会禁止内核抢占。</p>
<h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><h3 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h3><h3 id="顺序和屏障"><a href="#顺序和屏障" class="headerlink" title="顺序和屏障"></a>顺序和屏障</h3><p>rmb()方法提供了一个“读”内存屏障，它确保跨越rmb()的载入动作不会发生重排序。</p>
<p>wmb()方式提供是一个“写”内存屏障，区别仅仅是它是针对存储而非载入——它确保跨越屏障的存储不发生重排序。</p>
<p>mb()方法既提供了读屏障也提供了写屏障。载入和存储动作都不会跨越屏障重新排序。</p>
<h2 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h2><p>系统定时器是一种可编程硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断。</p>
<h3 id="内核中的时间概念"><a href="#内核中的时间概念" class="headerlink" title="内核中的时间概念"></a>内核中的时间概念</h3><h3 id="节拍率：HZ"><a href="#节拍率：HZ" class="headerlink" title="节拍率：HZ"></a>节拍率：HZ</h3><p>内核在&lt;asm/param.h&gt;中定义了这个值</p>
<h3 id="Jiffies"><a href="#Jiffies" class="headerlink" title="Jiffies"></a>Jiffies</h3><p>全局变量jiffies用来记录自系统启动以来产生的节拍总数。启动时，内核将该变量初始化为0。</p>
<p>定义在&lt;linux/jiffies.h&gt;中。</p>
<h4 id="用户空间和HZ"><a href="#用户空间和HZ" class="headerlink" title="用户空间和HZ"></a>用户空间和HZ</h4><h3 id="硬时钟和定时器"><a href="#硬时钟和定时器" class="headerlink" title="硬时钟和定时器"></a>硬时钟和定时器</h3><h4 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h4><p>实时时钟(RTC)是用来持久存放系统时间的设备，即便系统关闭后，它也可以靠主板上的微型电池提供的电力保持系统的计时。在PC体系结构中，RTC和CMOS集成在一起，而且RTC的运行和BIOS的保持设置都是通过一个电池供电的。</p>
<h4 id="系统定时器"><a href="#系统定时器" class="headerlink" title="系统定时器"></a>系统定时器</h4><p>在x86体系结构中，主要采用可编程中断时钟(PIT)。PIT在PC机器中普遍存在。内核在启动时对PIT进行编程初始化，使其能够以HZ/秒的频率产生时钟中断。</p>
<h3 id="时钟中断处理程序"><a href="#时钟中断处理程序" class="headerlink" title="时钟中断处理程序"></a>时钟中断处理程序</h3><p>时钟中断处理程序可以划分为两个部分：体系结构相关部分和体系结构无关部分。</p>
<p>与体系结构相关的例程作为系统定时器的中断处理程序而注册到内核中，以便在产生时钟中断时，它能够相应地运行：</p>
<ul>
<li>获得xtime_lock锁，以便对访问jiffies_64和墙上时间xtime进行保护。</li>
<li>需要时应答或重新设置系统时钟。</li>
<li>周期性地使用墙上时间更新实时时钟。</li>
<li>调用体系结构无关的时钟例程：tick_periodic()。</li>
</ul>
<p>中断处理程序主要通过调用与体系结构无关的例程，tick_periodic()执行下面更多工作：</p>
<ul>
<li>给jiffies_64变量加一。</li>
<li>更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。</li>
<li>执行已经到期的动态定时器。</li>
<li>执行sheduler_tick()函数。</li>
<li>更新墙上时间，该时间存放在xtime变量中。</li>
<li>计算平均负载值。</li>
</ul>
<h3 id="实际时间"><a href="#实际时间" class="headerlink" title="实际时间"></a>实际时间</h3><p>当前实际时间（墙上时间）定义在文件kernel/time/timekeeping.c中。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h4><p>当前节拍计数等于或大于指定超时时，内核就开始执行定时器处理函数。</p>
<p>当del_timer()返回后，可以保证的只是将来不会再被激活，但是在多处理器机器上的定时器中断可能已经在其他处理器上运行了。</p>
<h4 id="定时器竞争条件"><a href="#定时器竞争条件" class="headerlink" title="定时器竞争条件"></a>定时器竞争条件</h4><h4 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h4><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><h4 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h4><p>忙等待（忙循环）的实现很简单——在循环中不断旋转直到希望的时钟节拍数耗尽。</p>
<h4 id="短延迟"><a href="#短延迟" class="headerlink" title="短延迟"></a>短延迟</h4><h4 id="schedule-timeout"><a href="#schedule-timeout" class="headerlink" title="schedule_timeout()"></a>schedule_timeout()</h4><p>该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量使睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新放回运行队列。</p>
<p>在调用该方法前，必须首先将任务设置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE两种状态之一，否则任务不会睡眠。</p>
<h5 id="schedule-timeout-的实现"><a href="#schedule-timeout-的实现" class="headerlink" title="schedule_timeout()的实现"></a>schedule_timeout()的实现</h5><p>该函数用原始的名字timer创建了一个定时器timer，然后设置超时时间timeout，设置超时执行函数process_timeout()；接着激活定时器而且调用schedule()。因为任务标识为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE，所以调度程序不会再选择该任务投入运行，而会选择其他新任务运行。</p>
<p>当定时器超时时，process_timeout()函数会被调用，将任务设置为TASK_RUNNING状态，然后将其放入运行队列。</p>
<p>如果任务提前被唤醒（如收到信号），那么定时器被撤销，process_timeout()函数返回剩余的时间。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>内核把物理页作为内存管理的基本单位。</p>
<p>内核用struct page结构表示系统中的每个物理页，该结构位于&lt;linux/mm_types.h&gt;：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;	<span class="comment">//存放页的状态，定义在&lt;linux/page-flags.h&gt;中</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _count;	<span class="comment">//存放页的引用计数</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount	</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			u16 inuse;</span><br><span class="line">			u16 objects;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">	    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NR_CPUS &gt;= CONFIG_SPLIT_PTLOCK_CPUS</span></span><br><span class="line">	    <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">pgoff_t</span> index;</span><br><span class="line">		<span class="keyword">void</span> *freelist;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;	<span class="comment">//即页的虚拟地址。		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_MEM_RES_CTLR</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> page_cgroup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个页可也由页缓存使用（这时，mapping域指向这个页关联的address_space对象），或者作为私有数据（由private指向），或者作为进程页表中的映射。</p>
<p>page结构与物理页相关，因此，该结构对页的描述只是短暂的。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>Linux主要使用了四种区：</p>
<p>ZONE_DMA——这个区包含的页能用来执行DMA操作。</p>
<p>ZONE_DMA32——这个区与ZONE_DMA不同之处在于这些页面只能被32位设备访问。</p>
<p>ZONE_NORMAL——这个区包含的都是能正常映射的页。</p>
<p>ZONE_HIGHEM——这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</p>
<p>这些区定义在&lt;linux/mmzone.h&gt;中。</p>
<p>每个区都用struct zone表示，定义在&lt;linux/mmzone.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		pages_min, pages_low, pages_high;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>	*<span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>	<span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;	<span class="comment">//防止并发访问</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">active_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">inactive_list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_scan_active;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_scan_inactive;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		pages_scanned;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">int</span> prev_priority;</span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	* wait_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_hash_nr_entries;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_bits;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核启动期间初始化name值，代码位于mm/page_alloc.c中。</p>
<h3 id="获得页"><a href="#获得页" class="headerlink" title="获得页"></a>获得页</h3><p>内核提供了请求内存的底层机制，并提供了对它进行访问的几个接口，所有接口都以页为单位分配内存，定义于&lt;linux/gfp.h&gt;中。</p>
<h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc()"></a>kmalloc()</h3><p>所分配的内存在物理上是连续的。</p>
<p>kmalloc()在&lt;linux/slab.h&gt;中声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="gfp-mask标志"><a href="#gfp-mask标志" class="headerlink" title="gfp_mask标志"></a>gfp_mask标志</h4><p>这些标志可以分为三类：行为修饰符、区修饰符及类型。</p>
<p>所有标志在&lt;linux/gfp.h&gt;中声明。</p>
<h5 id="行为修饰符"><a href="#行为修饰符" class="headerlink" title="行为修饰符"></a>行为修饰符</h5><p>表示内核应当如何分配所需的内存。</p>
<h5 id="区修饰"><a href="#区修饰" class="headerlink" title="区修饰"></a>区修饰</h5><p>表示从哪儿分配内存。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>组合了行为修饰和区修饰，将各种组合归纳为不同类型。</p>
<h4 id="kfree"><a href="#kfree" class="headerlink" title="kfree()"></a>kfree()</h4><p>kfree(NULL)是安全的。</p>
<h3 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc()"></a>vmalloc()</h3><p>该函数工作方式类似于kmalloc()，只不过分配的内存虚拟地址连续，而物理地址则无须连续。</p>
<p>vmalloc()函数声明在&lt;linux/vmalloc.h&gt;中，定义在&lt;mm/vmalloc.c&gt;中。</p>
<p>获得的内存可用vfree()释放。</p>
<h3 id="slab层"><a href="#slab层" class="headerlink" title="slab层"></a>slab层</h3><h5 id="slab层的设计"><a href="#slab层的设计" class="headerlink" title="slab层的设计"></a>slab层的设计</h5><p>每个高速缓存可用由多个slab组成，slab由一个或多个物理上连续的页组成。每个slab都包含一些对象成员。每个slab处于三种状态之一：满、部分满或空。</p>
<p>当内核的某一部分需要一个新的对象时，先从部分满的slab中进行分配；如果没有部分满的slab，就从空的slab中进行分配；如果没有空的slab，就要创建一个slab了。</p>
<p>例如，struct inode就由inode_cachep高速缓存进行分配，这种高速缓存由一个或多个slab组成，每个slab包含尽可能多的struct inode对象。</p>
<p>每个高速缓存都使用kmem_cache结构来表示，这个结构包含三个链表：slabs_full、slabs_partial和slabs_empty，均存放在kmem_list3结构内，该结构在mm/slab.c中定义。这些链表包含的高速缓存中的所有slab。</p>
<p>slab描述符struct slab用来描述每个slab：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;</span><br><span class="line">	<span class="keyword">void</span> *s_mem;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;</span><br><span class="line">	<span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slab描述符要么在slab之外另行分配，要么就放在slab自身开始的地方。如果slab很小，或者slab内存有足够的空间容纳slab描述符，那么描述符就存放在slab里面。</p>
<p>slab分配器可以创建新的slab，这是通过__get_free_pages()低级内核页分配器进行的。</p>
<p>只有在下列情况下才会调用释放函数：当可用内存变得紧缺时，系统试图释放出更多内存以供使用；或者当高速缓存显式地被撤销时。</p>
<h4 id="slab分配器接口"><a href="#slab分配器接口" class="headerlink" title="slab分配器接口"></a>slab分配器接口</h4><h3 id="在栈上的静态分配"><a href="#在栈上的静态分配" class="headerlink" title="在栈上的静态分配"></a>在栈上的静态分配</h3><h4 id="单页内核栈"><a href="#单页内核栈" class="headerlink" title="单页内核栈"></a>单页内核栈</h4><p>中断栈为每个进程提供一个用于中断处理程序的栈。</p>
<h3 id="高端内存的映射"><a href="#高端内存的映射" class="headerlink" title="高端内存的映射"></a>高端内存的映射</h3><h4 id="永久映射"><a href="#永久映射" class="headerlink" title="永久映射"></a>永久映射</h4><p>要映射一个给定的page结构到内核地址空间，可以使用定义在文件&lt;linux/highmem.h&gt;中的这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap</span><span class="params">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以睡眠，因此只能用在进程上下文中。</p>
<p>解除映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kunmap</span><span class="params">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="临时映射"><a href="#临时映射" class="headerlink" title="临时映射"></a>临时映射</h4><p>临时银蛇可以用在不能睡眠的地方，因为获取映射时绝不会阻塞，同时禁止内核抢占：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page, <span class="keyword">enum</span> km_type type)</span></span>;</span><br></pre></td></tr></table></figure>



<p>参数type描述了临时映射的目的，定义于&lt;asm/kmap_types.h&gt;中。</p>
<p>取消映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kunmap_atomic</span><span class="params">(<span class="keyword">void</span> *kvaddr, <span class="keyword">enum</span> km_type type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除非激活了内核抢占，否则kunmap_atomic()无须做什么实际的事情，只有在下一个临时映射到来前上一个临时映射才有效。下一个原子映射将自动覆盖前一个映射。</p>
<h3 id="每个CPU的分配"><a href="#每个CPU的分配" class="headerlink" title="每个CPU的分配"></a>每个CPU的分配</h3><h4 id="新的每个CPU接口"><a href="#新的每个CPU接口" class="headerlink" title="新的每个CPU接口"></a>新的每个CPU接口</h4><p>&lt;linux/percpu.h&gt;中声明了所有接口操作例程，可以在mm/slab.c和&lt;asm/percpu.h&gt;中找到定义。</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>VFS使得用户可以直接使用open()、read()和write()这样的系统调用而无须考虑具体文件系统和实际物理介质。</p>
<h3 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h3><p>VFS提供了一个通用文件系统模型，该模型囊括了任何文件系统的常用功能集合行文。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1586854070.jpg" alt="从用户控件的write调用到数据被写入磁盘介质"></p>
<h3 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h3><p>Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点。</p>
<p>在Unix中，文件系统被安装在一个特定的安装点上，该安装点在全局层次结构中被称作命名空间，所有的已安装文件系统都作为根文件系统树的枝叶出现在系统中。</p>
<p>Unix系统将文件的相关信息和文件本身这两个概念加以区分。文件相关信息有时被称作文件的元数据，被存储在一个单独的数据结构中，该结构被称为索引节点。</p>
<p>文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构。</p>
<h3 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h3><p>VFS中有四个主要的对象类型：</p>
<ul>
<li>超级块对象——它代表一个具体的已安装的文件系统。</li>
<li>索引节点对象——它代表一个具体文件。</li>
<li>目录项对象——它代表一个目录项，是路径的一个组成部分。</li>
<li>文件对象——它代表由进程打开的文件。</li>
</ul>
<p>每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：</p>
<ul>
<li>super_operations对象，其中包括内核针对特定文件系统所能调用的方法，如write_inode()和sysnc_fs()等方法。</li>
<li>inode_operations对象，其中包括内核针对特定文件所能调用的方法，比如create()和link()等方法。</li>
<li>dentry_operations对象，其中包括内核针对特定目录所能调用的方法，比如d_compare()和d_delete等方法。</li>
<li>file_operations对象，其中包括针对针对已打开文件所能调用的方法，比如read()和write()等方法。</li>
</ul>
<p>操作对象作为一个结构体指针来实现，此结构体重包含指向操作其父对象的函数指针。</p>
<h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>该对象用于存储特定文件系统的信息，通常对应于存放在磁盘待定扇区中的文件系统超级块或文件系统控制块。</p>
<p>超级块对象由super_block结构体表示，定义在&lt;linux/fs.h&gt;中。</p>
<p>创建、管理和撤销超级快对象的代码位于文件fs/super.c中。</p>
<h3 id="超级块操作"><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h3><p>操作块对象中的s_op域指向超级块的操作函数表。超级块操作函数表又super_operations结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<p>超级块操作函数都是由VFS在进程上下文中调用。除了dirty_inode()，其他函数在必要时都可以阻塞。</p>
<p>如果VFS发现操作函数指针是NULL，那么它要么就会调用通用函数执行相应操作，要么什么也不做。</p>
<h3 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h3><p>索引节点对象包含了内核在操作文件或目录时需要的全部信息。</p>
<p>索引节点对象由inode结构体表示，它定义在文件&lt;linux/fs.h&gt;中。</p>
<p>索引节点仅当文件被访问时，才在内存中创建。</p>
<h3 id="索引节点操作"><a href="#索引节点操作" class="headerlink" title="索引节点操作"></a>索引节点操作</h3><p>索引节点对象中用i_op(inode_operations)来存储操作函数表，该结构体定义在文件&lt;linux/fs.h&gt;中。</p>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>目录项对象由dentry结构体表示，定义在&lt;linux/dcache.h&gt;中。</p>
<h4 id="目录项状态"><a href="#目录项状态" class="headerlink" title="目录项状态"></a>目录项状态</h4><p>目录项对象有三种有效状态：被使用、未被使用和负状态。</p>
<p>一个被使用的目录项对应一个有效的索引节点，并且表明该对象存在一个或多个使用者（d_count为正值）。一个目录项处于被使用状态，意味着它正被VFS使用并且指向有效的数据，因此不能被丢弃。</p>
<p>一个被使用的目录项对应一个有效的索引节点，但是d_count为0,。该目录表项仍然指向一个有效对象，而且被保留在缓存中以便需要时使用它。</p>
<p>一个负状态的目录项没有对应的有效索引节点（d_inode为NULL），因为索引节点已被删除，或路径不再正确，但是目录项仍然保留，以便快速解析以后的路径查询。</p>
<h4 id="目录项缓存"><a href="#目录项缓存" class="headerlink" title="目录项缓存"></a>目录项缓存</h4><p>内核将目录项对象缓存在目录项缓存（dcache）中。目录项缓存包括三个主要部分：</p>
<ul>
<li>“被使用的”目录项链表。将链表通过所以节点对象中的i_dentry项链接相关的索引节点。</li>
<li>“最近被使用的”双向链表。该链表含有未被使用和负状态的目录项对象。因为该链表总是在头部插入目录项，故链头节点的数据总比链尾节点的数据要新。删除时，从链尾删除节点项。</li>
<li>散列表和相应的散列函数用来快速地将给定路径解析为相关目录项对象。</li>
</ul>
<p>散列表由数组dentry_hashtable表示，其中每个元素都是一个指向具有相同键值的目录项对象链表指针。</p>
<p>实际的散列值由d_hash()函数计算。</p>
<p>查找散列表要通过d_lookup()函数。</p>
<h3 id="目录项操作"><a href="#目录项操作" class="headerlink" title="目录项操作"></a>目录项操作</h3><p>dentry_operation结构体指明了VFS操作目录项的所有方法，该结构体定义在文件&lt;linux/dcache.h&gt;中。</p>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象表示进程已打开的文件。</p>
<p>文件对象由file结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<p>文件对象通过f_dentry指针指向相关的目录项对象。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件对象的操作由file_operations结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<h3 id="和文件系统相关的数据结构"><a href="#和文件系统相关的数据结构" class="headerlink" title="和文件系统相关的数据结构"></a>和文件系统相关的数据结构</h3><p>file_system_type——该结构用来描述各种特定文件系统类型，如ext3、ext4或UDF。</p>
<p>vfsmount——用来描述一个安装文件系统的实例。</p>
<p>file_system_type定义在&lt;linux/fs.h&gt;中。</p>
<p>每种文件系统，不管有多少实例安装到系统中，还是根本没有安装到系统中，都只有一个file_system_type结构。</p>
<p>当文件系统被实际安装时，将有一个vfsmount结构体在安装点被创建。vfsmount结构被定义在&lt;linux/mount.h&gt;中。</p>
<p>vfsmount保存了安装时指定的标志信息，存储在mnt_flages域中。标志信息定义在&lt;linux/mount.h&gt;中。</p>
<h3 id="和进程相关的数据结构"><a href="#和进程相关的数据结构" class="headerlink" title="和进程相关的数据结构"></a>和进程相关的数据结构</h3><p>有三个数据结构将VFS层和系统的进程联系在一起，分别是：file_struct、fs_struct和namespace结构体。</p>
<p>file_struct结构体定义在&lt;linux/fdtable.h&gt;中。该结构体由进程描述符中的files目录项指向。所有与单个进程相关的信息都包含在其中。</p>
<p>fs_struct结构体定义在&lt;linus/fs_struct.h&gt;中。该结构体由进程描述符的fs域指向。它包含文件系统和进程相关的信息。</p>
<p>namespace结构体定义在&lt;linux/mmt_namespace.h&gt;中。由进程描述符中的mmt_namespace域指向。单进程命名空间使得每一个进程在系统中都看的唯一的安装文件系统——不仅是唯一的根目录，而且是唯一的文件系统层次结构。</p>
<p>默认情况下，所有进程共享同一命名空间。只有在clone()操作时使用CLONE_NEWS标志，才会给进程一个唯一的命名空间结构体的拷贝。</p>
<h2 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h2><p>系统中能随机（不按顺序）访问固定大小数据片的硬件设备称作块设备。这些固定大小的数据片就称作块。</p>
<p>字符设备按照字符流的方式被有序访问。</p>
<h3 id="剖析一个块设备"><a href="#剖析一个块设备" class="headerlink" title="剖析一个块设备"></a>剖析一个块设备</h3><p>块设备中最小的可寻址单元是扇区（有时也称作“硬扇区”、“设备块”）。</p>
<p>块（也称作“文件块”或“I/O块”）是最小逻辑可寻址单元，块是文件系统的一种抽象——只能基于块来访问文件系统。块只能数倍于扇区大小。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1586921047.png" alt="扇区与缓冲区之间的关系"></p>
<h3 id="缓冲区与缓冲区头"><a href="#缓冲区与缓冲区头" class="headerlink" title="缓冲区与缓冲区头"></a>缓冲区与缓冲区头</h3><p>当一个块被调入内存时（即在读入后或等待写出时），它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当与是磁盘块在内存中的表示。</p>
<p>每一个缓冲区都有一个对应的描述，该描述符用buffer_head结构体表示，称作缓冲区头定义在文件&lt;linux/buffer_head.h&gt;中，它包含了内核操作缓冲区所需要的全部信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span></span><br><span class="line">	<span class="keyword">sector_t</span> b_blocknr;</span><br><span class="line">	<span class="keyword">size_t</span> b_size;</span><br><span class="line">	<span class="keyword">char</span> *b_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span></span><br><span class="line">	<span class="keyword">bh_end_io_t</span> *b_end_io;</span><br><span class="line"> 	<span class="keyword">void</span> *b_private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> b_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中b_state表示缓冲区状态。合法标志存放在bh_state_bits枚举中，该枚举在&lt;linux/buffer_head.h&gt;中定义。</p>
<p>b_count域表示缓冲区的使用计数，可以通过两个定义在文件&lt;linux/buffer_head.h&gt;中的内联函数对此域进行增减。</p>
<p>与缓冲区对应的磁盘物理块由b_blocknr-th域索引，该值是b_bdev域指明的块设备中的逻辑块号。</p>
<p>与缓冲区对应的内存物理页由b_page域表示。另外，b_data域直接指向相应的块，块的大小由b_size域表示。</p>
<p>缓冲头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。</p>
<h3 id="bio结构体"><a href="#bio结构体" class="headerlink" title="bio结构体"></a>bio结构体</h3><p>内核中块I/O操作的基本容器由bio结构体表示，定义在&lt;linux/bio.h&gt;中。该结构代表了正在现场的（活动的）以及片段链表形式组织的块I/O操作。一个片段是一小块连续的内存缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">	<span class="keyword">sector_t</span>		bi_sector;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span>		*<span class="title">bi_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">bi_bdev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bi_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bi_rw;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_vcnt;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_idx;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_phys_segments;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_hw_segments;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_hw_front_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_hw_back_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_max_vecs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>		*<span class="title">bi_io_vec</span>;</span></span><br><span class="line">	<span class="keyword">bio_end_io_t</span>		*bi_end_io;</span><br><span class="line">	<span class="keyword">atomic_t</span>		bi_cnt;</span><br><span class="line">	<span class="keyword">void</span>			*bi_private;</span><br><span class="line">	<span class="keyword">bio_destructor_t</span>	*bi_destructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1586931445.png" alt="bio结构体、bio_vec结构体和page结构体之间的关系"></p>
<h4 id="I-O向量"><a href="#I-O向量" class="headerlink" title="I/O向量"></a>I/O向量</h4><p>bi_io_vec域指向一个bio_vec结构体数组，该结构体链表包含了一个特定I/O操作所需要使用到的片段。每个bio_vec结构都是一个形式为&lt;page,offset,len&gt;的向量，它描述的是一个特定的片段：片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度。整个bio_io_vec结构体数组表示了一个完成的缓冲区。bio_vec结构定义在&lt;linux/bio.h&gt;中。</p>
<p>bi_cnt域用来描述bi_io_vec所指向的bio_vec数组中的向量数目。当块I/O操作执行完毕后，bi_idx域指向数组的当前索引。</p>
<p>bi_cnt若为0，则应该撤销该bio结构体，并释放它占用的内存。</p>
<p>bi_private域是属于拥有者（即创建者）的私有域，只有创建了bio结构的拥有者可以读写该域。</p>
<h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>块设备将它们挂起的块I/O请求保存在请求队列中，该队列由reques_queue结构体表示，定义在&lt;linux/blkdev.h&gt;中，包含一个双向请求链表以及相关控制信息。</p>
<p>请求队列表中每一项都是一个单独的请求，由结构体request表示，定义在文件&lt;linux/blkdev.h&gt;中。每个请求可以由多个bio结构体组成。</p>
<h3 id="I-O调度程序"><a href="#I-O调度程序" class="headerlink" title="I/O调度程序"></a>I/O调度程序</h3><p>内核中负责请求I/O请求的子系统称为I/O调度程序。</p>
<p>I/O调度程序将磁盘I/O资源分配给系统中所有挂起的块I/O请求。具体地说，这种资源分配是通过请求队列中挂起的请求合并和排序来完成的。</p>
<h4 id="I-O调度程序的工作"><a href="#I-O调度程序的工作" class="headerlink" title="I/O调度程序的工作"></a>I/O调度程序的工作</h4><p>I/O调度程序的工作是管理设备的请求队列。它决定队列中的请求排序顺序以及在什么时刻派发请求到块设备。</p>
<p>I/O调度程序通过两种方法减少磁盘寻址时间：合并与排序。</p>
<p>合并指将两个或多个请求结合成一个新请求。</p>
<p>整个请求队列将按扇区增长方向有序排列。该排序算法类似于电梯调度。所以I/O程序（或这种排序算法）称作电梯调度。</p>
<h4 id="Linus电梯"><a href="#Linus电梯" class="headerlink" title="Linus电梯"></a>Linus电梯</h4><p>Linus电梯能执行合并与排序预处理。</p>
<p>当一个请求加入队列中时，有可能发生四种操作：</p>
<ol>
<li>如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求。</li>
<li>如果队列中存在一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生。</li>
<li>如果队列中以扇区方向为序而存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排列的。</li>
<li>如果队列中不存在合适的请求插入位置，请求将被插入到队列尾部。</li>
</ol>
<h4 id="最终期限I-O调度程序"><a href="#最终期限I-O调度程序" class="headerlink" title="最终期限I/O调度程序"></a>最终期限I/O调度程序</h4><p>在最后期限I/O调度程序中，每个请求都有一个超时时间。</p>
<p>最后期限I/O调度请求以磁盘物理位置为次序维护请求队列，这个队列称为排序队列。读请求按次序被插入到特定的读FIFO队列中，写请求被插入到特定的写FIFO队列中。</p>
<p>对于普通操作来说，最后期限I/O调度程序将请求从排序队列头部取下，再推入到派发队列中，然后派发队列将请求提交给磁盘驱动，从而保证了最小化的请求寻址。</p>
<p>如果在写FIFO队列头，或是读FIFO队列头的请求超时，那么最后期限I/O调度程序便从FIFO队列中提取请求进行服务。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1586935266.jpg" alt="最后期限I/O调度程序的三个队列"></p>
<p>最后期限I/O调度程序的实现在block/deadline-iosched.c中。</p>
<h4 id="预测I-O调度程序"><a href="#预测I-O调度程序" class="headerlink" title="预测I/O调度程序"></a>预测I/O调度程序</h4><p>预测I/O调度程序也实现了三个队列（加上一个派发队列），并为每个请求设置了超时时间。同时还增加了预测启发能力。</p>
<p>预测I/O调度程序在请求提交后并不直接返回处理其他请求，而是会有意空闲片刻（可设置，默认6ms）。这个空闲时间内，任何对相邻磁盘位置操作的请求都会立刻得到处理。在等待时间结束后，预测I/O调度程序重新返回原来的位置，继续执行以前剩下的请求。</p>
<p>预测I/O调度程序的实现在文件内核源代码树的block/as-iosched.c中。</p>
<h4 id="完全公正的排队I-O调度程序-CFQ"><a href="#完全公正的排队I-O调度程序-CFQ" class="headerlink" title="完全公正的排队I/O调度程序(CFQ)"></a>完全公正的排队I/O调度程序(CFQ)</h4><p>CFQ I/O调度程序把进入I/O请求放入特定的队列中，这种队列是根据引起I/O请求的进程组织的。每个队列中，刚进入的请求与相邻请求合并在一起，并进行插入分类。队列由此按扇区方式分类。</p>
<p>CFQ I/O调度程序以时间片轮转调度队列，每个队列中选取请求数，然后进行下一轮调度。</p>
<p>完全公正的排队I/O调度程序位于block/cfg-iosched.c。</p>
<h4 id="空操作的I-O调度程序"><a href="#空操作的I-O调度程序" class="headerlink" title="空操作的I/O调度程序"></a>空操作的I/O调度程序</h4><p>空操作(Noop)I/O调度程序不进行排序，也不进行其他形式的预寻址操作。但仍执行合并操作：当一个新的请求提交到队列时，就把它与任一相邻的请求合并，它只是维护请求队列以近乎FIFO的顺序排列，块设备驱动程序便可以从这种队列中摘取请求。</p>
<p>空操作i/o调度程序位于block/noop-iosched.c，它是专为随机访问设备而设计的。</p>
<h4 id="I-O调度程序的选择"><a href="#I-O调度程序的选择" class="headerlink" title="I/O调度程序的选择"></a>I/O调度程序的选择</h4><p>可以通过命令行选项：elevator=foo来启用foo（有效而激活的I/O调度程序）给所有的块设备。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>进程地址空间由进程可寻址的虚拟内存组成。每一个进程都有一个32或64位的平坦(flat)地址空间，空间的具体大小取决于体系结构。平坦指的是地址空间范围是一个独立的连续区间。</p>
<p>一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干，我们称这样的进程为线程。</p>
<p>可被访问的合法地址空间称为内存区域。通过内核，进程可以给自己的地址空间动态地添加或减少内存区域。</p>
<p>进程只能访问有效内存区域内的内存地址。</p>
<h3 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h3><p>内核使用内存描述符结构体表示进程的地址空间。内存描述符由mm_struct结构体表示，定义在&lt;linux/mm_types.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line">	<span class="keyword">void</span> (*unmap_area) (struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;</span><br><span class="line">	<span class="keyword">pgd_t</span> * pgd;</span><br><span class="line">	<span class="keyword">atomic_t</span> mm_users;</span><br><span class="line">	<span class="keyword">atomic_t</span> mm_count;</span><br><span class="line">	<span class="keyword">int</span> map_count;</span><br><span class="line">	<span class="keyword">int</span> core_waiters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> page_table_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span></span><br><span class="line">	<span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">	<span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE];</span><br><span class="line">	<span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line">	<span class="keyword">mm_context_t</span> context;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">core_startup_done</span>, <span class="title">core_done</span>;</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		ioctx_list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kioctx</span>		*<span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mm_users域记录正在使用该地址的进程数目。mm_count域是mm_struct结构体的主引用计数。如果mm_users减为0，则mm_count减1。若mm_count为0，则说明没有任何指向该mm_struct结构体的引用了，这时该结构体会被撤销。当内核在一个地址空间上操作，并需要使用与该地址相关联的引用计数时，内核便增加mm_count。</p>
<p>mmap和mm_rb这两个不同的数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但mmap以链表形式存放，而mm_rb以红-黑树形式存放。</p>
<p>所有的mm_struct结构体都通过自身的mmlist域链接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。</p>
<h4 id="分配内存描述符"><a href="#分配内存描述符" class="headerlink" title="分配内存描述符"></a>分配内存描述符</h4><p>在进程的进程描述符中的mm预存放着该进程使用的内存描述符。</p>
<h4 id="撤销内存描述符"><a href="#撤销内存描述符" class="headerlink" title="撤销内存描述符"></a>撤销内存描述符</h4><p>当进程退出时，内核会调用定义在kernel/exit.c中的exit_mm()函数，该函数执行一些常规的撤销工作，同时更新一些统计量。</p>
<h4 id="mm-struct与内核线程"><a href="#mm-struct与内核线程" class="headerlink" title="mm_struct与内核线程"></a>mm_struct与内核线程</h4><p>内核线程没有进程地址空间，也没有相关的内存描述符，所以内核线程对应的进程描述符中的mm域为空。</p>
<p>为了避免内核线程为内存描述符合页表浪费内存，也为了当新内核线程运行时，避免浪费处理器周期向新地址空间进行切换，内核将直接使用前一个进程的内存描述符。</p>
<h3 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h3><p>内存区域由vm_area_struct结构体表示，定义在&lt;linux/mm_types.h&gt;中。内存区域在Linux内核中也经常被称作虚拟内存区域（VMAS）。</p>
<p>vm_area_struct结构体描述了指定地址空间内连续区间上的一个独立内存范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;	<span class="comment">//指向区间的首地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;	<span class="comment">//指向区间的尾地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *parent;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">		&#125; vm_set;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">	&#125; shared;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">atomic_t</span> vm_usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个内存描述符都对应于进程地址空间中的唯一区间。</p>
<p>vm_mm域指向和VMA相关的mm_struct结构体。注：每个VMA对其相关的mm_struct结构体来说都是唯一的。</p>
<h4 id="VMA标志"><a href="#VMA标志" class="headerlink" title="VMA标志"></a>VMA标志</h4><p>VMA标志是一种位标志，定义在&lt;linux/mm.h&gt;中。其包含在vm_flags域内，标志了内存区域所包含的页面的行为和信息。</p>
<h4 id="VMA操作"><a href="#VMA操作" class="headerlink" title="VMA操作"></a>VMA操作</h4><p>vm_ops域指向与指定内存区域相关的操作函数表，内核使用表中的方法操作VMA。</p>
<p>操作函数表由vm_operations_struct结构体表示，定义在文件&lt;linux/mm.h&gt;中。</p>
<h4 id="内存区域的树型结构和内存区域的链表结构"><a href="#内存区域的树型结构和内存区域的链表结构" class="headerlink" title="内存区域的树型结构和内存区域的链表结构"></a>内存区域的树型结构和内存区域的链表结构</h4><p>mmap域使用单独链表连接所有的内存区域对象。每一个vm_area_struct结构体通过自身的vm_next域被连入链表，所有区域按地址增长的方向排序，mmap域指向链表中第一个内存区域，链表中最后一个结构体指针指向空。</p>
<p>mm_rb域使用红-黑树连接所有的内存区域对象。mm_rb域指向红-黑树的根节点，地址空间中每一个vm_area_struct结构体通过自身的vm_rb域连接到树中。</p>
<h4 id="实际中使用的内存区域文件"><a href="#实际中使用的内存区域文件" class="headerlink" title="实际中使用的内存区域文件"></a>实际中使用的内存区域文件</h4><p>可以使用/proc文件系统和pmmap工具查看给定进程的内存空间和其中所包含的内存区域。</p>
<p>/proc/&lt;pid&gt;/maps的输出显示了进程地址空间中的全部内存区域。</p>
<p>没有映射文件的内存区域的设备标志位00:00，索引节点标志也为0，这个区域就是零页——零页映射的内存全为0。如果零页映射到可写的内存区域，那么该区域将全被初始化为0。</p>
<h3 id="操作内存区域"><a href="#操作内存区域" class="headerlink" title="操作内存区域"></a>操作内存区域</h3><p>为方便执行对内存区域的操作，内核定义了许多辅助函数，它们都声明在&lt;linux/mm.h&gt;中。</p>
<h3 id="mmap-和do-mmap-创建地址区间"><a href="#mmap-和do-mmap-创建地址区间" class="headerlink" title="mmap()和do_mmap():创建地址区间"></a>mmap()和do_mmap():创建地址区间</h3><p>内核使用do_mmap()函数创建一个新的线性地址区间。</p>
<p>do_mmap()函数定义在文件&lt;linux/mm.h&gt;中。</p>
<p>如果系统调用do_mmap()的参数中有无效参数，那么它返回一个负值；否则，它会在虚拟内存中分配一个合适的新内存区域。如果有可能的话，将新区域和邻近区域进行合并，否则内核从vm_area_cachep长字节(slab)缓存中分配一个vm_area_struct结构体，并使用vm_link()函数将新分配的内存区域添加到地址空间的内存区域链表和红-黑树中，随后还要更新内存描述符中的total_vm域，然后才返回新分配的地址区间的初始地址。</p>
<p>在用户空间可以通过mmap()系统调用获取内核函数do_mmap()的功能。</p>
<h4 id="mummap-和do-mummap-：删除地址区间"><a href="#mummap-和do-mummap-：删除地址区间" class="headerlink" title="mummap()和do_mummap()：删除地址区间"></a>mummap()和do_mummap()：删除地址区间</h4><p>do_mummap()函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件&lt;linux/mm.h&gt;中。</p>
<p>系统调用mummap()给用户空间提供了一种从自身地址空间中删除指定地址区间的方法。该系统调用定义在文件mm/map.c中，它是对do_mummap()函数的一个简单的封装。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>当用程序访问一个虚拟地址时，首先必须将虚拟地址转化为物理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成。</p>
<p>Linux中使用三级页表完成地址转换：</p>
<ol>
<li>顶级页表是页全局目录（PGD），它包含一个pgd_t类型数组，多数体系结构中pgd_t类型等同于无符号长整型类型。PGD中的表项指向二级页目录中的表项：PMD。</li>
<li>二级页表是中间页目录（PMD），它是个pmd_t类型数组，其中的表项指向PTE中的表项。</li>
<li>最后一级的页表简称页表，其中包含了pte_t类型的页表项，该页表项指向物理页面。</li>
</ol>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./img/1587021913.jpg" alt="虚拟——物理地址查询"></p>
<p>每个进程都有自己的页表（线程会共享页表），内存描述符的pgd域指向的就是进程的页全局目录。</p>
<p>页表对应的结构体依赖于具体的体系结构，定义在&lt;asm/page.h&gt;中。</p>
<p>为了加快搜索，多数体系结构都实现了一个翻译后缓冲器（TLB）。TLB作为一个将虚拟地址映射到物理地址的硬件缓存，当请求访问一个虚拟地址时，处理器首先检查TLB中是否缓存了该虚拟地址到物理地址的映射，如果在缓存中直接命中，物理地址立刻返回；否则，就需要再通过页表搜索需要的物理地址。</p>
<h2 id="页高速缓存和页回写"><a href="#页高速缓存和页回写" class="headerlink" title="页高速缓存和页回写"></a>页高速缓存和页回写</h2><p>页高速缓存是Linux内核实现磁盘缓存。主要用来减少对磁盘I/O操作。</p>
<h3 id="缓存手段"><a href="#缓存手段" class="headerlink" title="缓存手段"></a>缓存手段</h3><p>页高速缓存是由内存中的物理页面组成的，其内容对应磁盘上的物理块。页高速缓存大小能动态调整，我们称正被缓存的存储设备为后备存储。</p>
<h4 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h4><p>缓存一般被实现下面三种策略之一：</p>
<p>第一种策略，不缓存，即高速缓存不去缓存任何写操作。</p>
<p>第二种策略，写操作自动更新内存缓冲，同时也更新磁盘文件，这种方式，通常称为写透缓存。</p>
<p>第三种策略，也是Linux所采用的，称为“回写”。这种策略下，程序执行写操作直接写到缓存中，后端存储不会立刻直接更新，而是将页高速缓存中被写入的页面标记成“赃”，并且被加入到赃页链表中。然后由一个进程（回写进程）周期性将赃页链表中的页写回到磁盘中，然后再清理“赃”页标志。</p>
<h4 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h4><p>决定缓存中什么内容将被清除的策略，被称为缓存回收策略。</p>
<p>Linux的缓存回收是通过选择干净页进行简单的替换。如果缓存中没有足够的干净页面，内核将强制地进行回写操作，以腾出更多的干净可用页。</p>
<h5 id="最近最少使用"><a href="#最近最少使用" class="headerlink" title="最近最少使用"></a>最近最少使用</h5><p>缓存回收策略通过所访问的数据特性，尽量追求预测效率。最成功的算法称作最近最少使用算法(LRU)。</p>
<p>LRU回收策略需要跟着每个页面的访问踪迹（或者至少按照访问时间为序的页链表），以便能回收最老时间戳的页面（或者回收排序链表头所指的页面）</p>
<h5 id="双链策略"><a href="#双链策略" class="headerlink" title="双链策略"></a>双链策略</h5><p>Linux实现的是一个修改过的LRU，也称为双链策略。</p>
<p>Linux维护两个链表：活跃链表和非活跃链表。处于活跃链表上的页面不会被换出，而在非活跃链表上的页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。</p>
<p>两个链表都被伪LRU规则维护：页面从尾部加入，从头部移除，如同队列。两个链表需要维持平衡——如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移回到非活跃链表中，以便能再被回收。</p>
<h3 id="Linux页高速缓存"><a href="#Linux页高速缓存" class="headerlink" title="Linux页高速缓存"></a>Linux页高速缓存</h3><p>页高速缓存缓存的是内存页面。</p>
<h4 id="address-space对象"><a href="#address-space对象" class="headerlink" title="address_space对象"></a>address_space对象</h4><p>为了维持页高速缓存的普遍性，Linux页高速缓存使用了一个新对象管理缓存项和页I/O操作，这个对象是address_space结构体，定义在文件&lt;linux/fs.h&gt;中。这个结构体是vm_area_struct的物理地址对等体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>	<span class="title">page_tree</span>;</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		tree_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_mmap_writable;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_root</span>	<span class="title">i_mmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_mmap_nonlinear</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		i_mmap_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		truncate_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrpages;</span><br><span class="line">	<span class="keyword">pgoff_t</span>			writeback_index;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		private_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">private_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">assoc_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中i_mmap字段是一个优先搜索树，它的搜索范围包括了再address_spcae中所有共享的私有映射页面。</p>
<p>address_space页总数由nrpage描述。</p>
<p>address_spcae结构体与索引节点（inode）关联，这时host域会指向该索引节点；如果关联对象不是一个索引节点的话，host域会被置为NULL。</p>
<h4 id="address-spcae操作"><a href="#address-spcae操作" class="headerlink" title="address_spcae操作"></a>address_spcae操作</h4><p>a_ops域指向地址空间对象中的操作函数表，定义在文件&lt;linux/fs.h&gt;中，由address_space_operations结构来表示。</p>
<p>每个后备存储都通过自己的address_space_operation描述自己如何与页高速缓存交互。</p>
<h4 id="基树"><a href="#基树" class="headerlink" title="基树"></a>基树</h4><p>每个address_space对象都有唯一的基树，它保存在page_tree结构体中。</p>
<p>基树是一个二叉树，只要指定了文件偏移量，就可以在基树中迅速检索到希望的页。</p>
<p>基树核心代码的通用形式可以在文件lib/radix-tree.c中找到，声明在&lt;linux/radix_tree.h&gt;中。</p>
<h3 id="缓冲区高速缓存"><a href="#缓冲区高速缓存" class="headerlink" title="缓冲区高速缓存"></a>缓冲区高速缓存</h3><p>缓存的作用是映射内存中的页面到磁盘块，从而在块I/O操作时也减少了磁盘访问。这个缓存通常称为缓冲区高速缓存</p>
<h3 id="flusher线程"><a href="#flusher线程" class="headerlink" title="flusher线程"></a>flusher线程</h3><p>当页高速缓存中的数据比后台存储的数据更新时，该数据就称作赃数据。在以下3种情况发生时，赃页被写会磁盘：</p>
<ul>
<li>当空闲内存低于一个特定的阈值时，内核必须将赃页写回磁盘以便释放内存。</li>
<li>当赃页在内存找那个驻留时间超过一个特定的阈值时，内核必须将超时的赃页写回磁盘，以确保赃页不会无限期地驻留在内存中。</li>
<li>当用户进程调用sync()和fsync()系统调用时，内核会按要求执行回写动作。</li>
</ul>
<p>在2.6内核中，由一群内核线程（flusher线程）执行这三种工作。</p>
<p>当空闲内存比阈值dirty_backgrount_ratio还低时，内核便会调用函数flusher_threads()唤醒一个或多个flusher线程。同时，flusher线程后台例程会被周期性唤醒（被定时器唤醒）。</p>
<p>系统管理员可以在/proc/sys/vm中设置回写相关的参数，也可以通过sysctl系统调用设置它们。</p>
<p>flusher线程的实现代码在文件mm/page-writeback.c和mm/backing-dev.c中，回写机制的实现代码在文件fs/fs-writeback.c中。</p>
<h4 id="膝上型计算机模式"><a href="#膝上型计算机模式" class="headerlink" title="膝上型计算机模式"></a>膝上型计算机模式</h4><p>膝上型计算机模式是一种特殊的页回写策略。该模式可通过/proc/sys/vm/laptop_mode文件进行配置，如果需要启用，则像配置文件中写入1.</p>
<p>膝上型计算机模式除了当缓存中的页面太旧时要执行回写赃页以外，flusher还会找准磁盘运转的时机，把所有其他的物理磁盘I/O、刷新赃缓冲等通通写回磁盘，以便保证不会专门为了写磁盘而去主动激活磁盘运行。</p>
<h2 id="设备与模块"><a href="#设备与模块" class="headerlink" title="设备与模块"></a>设备与模块</h2><p>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类。</p>
<p>模块：Linux内核中用于按需加载和卸载目标码的机制。</p>
<p>内核对象：内核数据结构中支持面向对象的简单操作，还支持维护对象之间的父子关系。</p>
<p>sysfs：表示系统中设备树的一个文件系统。</p>
<h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><p>在Linux以及所有Unix系统中，设备被分为以下三种类型：</p>
<ul>
<li>块设备</li>
<li>字符设备</li>
<li>网络设备</li>
</ul>
<p>块设备通常缩写为blkdev，它是可寻址的，寻址以块为单位，块大小随设备不同而不同；块设备通常支持重定位操作，也就是对数据的随机访问。块设备是通过称为“块设备节点”的特殊文件来访问的，并且通常被挂载为文件系统。</p>
<p>字符设备通常缩写为cdev，它是不可寻址的，仅提供数据的流式访问，就是一个个字符，或者一个个字节。字符设备是通过称为“字符设备节点”的特殊文件来访问的。应用程序通过直接访问设备节点与字符设备交互。</p>
<p>网络设备是通过套接字API这样的特殊接口来访问。</p>
<p>有些设备驱动是虚拟的，仅提供访问内核功能而已，我们称之为“伪设备”，如内核随机数发生器（通过/dev/random和/dev/urandom访问）、空设备（通过/dev/null访问）、零设备（通过/dev/zero访问）、满设备（通过/dev/full访问），还有内存设备（通过/dev/mem访问）。然而，大部分设备驱动是表示物理设备的。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Linux是“单块内核”的操作系统——即整个系统内核都运行于一个单独的保护域中。但Linux内核是模块化组成的，它允许内核在运行时动态地向其中插入或从中删除代码。这些代码被一并组合在一个单独的二进制镜像中，即所谓的可装载内核模块中，或简称为模块。</p>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h4><p>内核模块的Hello world!代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Godbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="comment">//MODULE_LICENSE("GPL");</span></span><br><span class="line"><span class="comment">//MODULE_AUTHOR("nuoye");</span></span><br><span class="line"><span class="comment">//MODULE_DESCRIPTION("A hello world moudle");</span></span><br></pre></td></tr></table></figure>

<h4 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h4><p>构建过程的第一步是决定在哪里管理模块源码。可以把模块源码加入到内核源代码树中，或者是作为一个补丁或者是最终把代码合并到正式的内核代码树中；；另一种可行的方式是在内核源代码树之外维护和构建模块源代码。</p>
<h5 id="放在内核源代码树中"><a href="#放在内核源代码树中" class="headerlink" title="放在内核源代码树中"></a>放在内核源代码树中</h5><p>设备驱动程序存放在内核源码树根目录下/drivers的子目录下，在其内部，设备驱动文件被进一步按照类别、类型或特殊驱动程序等更有序地组织起来。</p>
<h5 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h5><p>需要在自己的源代码树目录中建立一个Makefile文件，并加入一行指令（假设源代码文件为fishing.c）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m := fishing.o</span><br></pre></td></tr></table></figure>

<p>假如有多个文件（如fishing-main.c和fishing-line.c）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-m := fishing.o</span><br><span class="line">fishing-objs := fishing-main.o fishing-line.o</span><br></pre></td></tr></table></figure>

<p>然后就运行以下命令编译模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -C /kernel/<span class="built_in">source</span>/location SUBDIRS=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure>

<p>其中/kernel/source/location是内核源代码树。</p>
<h4 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h4><p>编译后的模块将被装入到目录/lib/modules/version/kernel/下，可以用下面的构造命令来安装编译的模块到合适的目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make module_install</span><br></pre></td></tr></table></figure>

<h4 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h4><p>模块依赖关系信息存放在/lib/modules/version/modules.dep中。</p>
<h4 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod module.ko</span><br></pre></td></tr></table></figure>

<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod module</span><br></pre></td></tr></table></figure>

<h4 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h4><h4 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h4><p>Linux允许驱动程序声明参数，从而用户可以在系统启动或者模块装载时再指定参数值，这些参数对于驱动程序属于全局变量。模块参数同时也将出现在sysfs文件系统中。</p>
<h4 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h4><p>模块被载入后，就会被动态连接到内核。导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。</p>
<h3 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h3><p>2.6内核新增了统一设备模型。设备模型提供了一个独立的机制专门来标识设备，并描述其在系统中的拓扑结构。</p>
<h5 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h5><p>设备模块的核心部分就是kobject，它由struct kobject结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<p>kobject通常是嵌入其他结构中的，当kobject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能，并且，嵌入kobject的结构体可以成为对象层次架构中的一部分。</p>
<h4 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h4><p>kobject对象呗关联到一种特殊的类型：ktype，由kobj_type结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ktype的存在是为了描述一族kobject所具有的普遍特性。</p>
<p>release指针指向在kobject引用计数减至零时要被调用的析构函数，该函数负责释放所以kobject使用的内存和其他相关清理工作。</p>
<p>sysfs_ops变量指向sysfs_ops结构体，该结构体描述了sysfs文件读写时的特性。</p>
<p>最后，default_attrs指向一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。</p>
<h4 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h4><p>kset是kobject对象的集合体。</p>
<p>具有相同的ktype的kobject可以被分组到不同的kset。</p>
<p>kobjsect中的kset指针指向kset集合。kset集合由kset结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中list连接该集合中所有的kobject对象。kobj指向的kobject对象代表了该集合的基类。uevent_ops指向一个结构体——用于处理集合中kobject对象的热插拔操作，uevent就是用户事件的缩写，提供了与用户空间热插拔信息进行通信的机制。</p>
<h4 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h4><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>初始化后，kobject的引用计数设置为1.只要引用计数不为0，那么该对象就会继续保留在内存中，任何包含对象引用的代码首先要增加该对象的引用计数，结束后则减少它的引用计数。</p>
<p>增加引用计数称之为获得对象的引用，减少引用计数称为释放对象的引用。当引用计数跌到零时，对象便可以被撤销，同时相关内存也都被释放。</p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它提供了kobject对象层次结构的视图。</p>
<p>sysfs文件系统挂载在sys目录下。</p>
<p>block目录下的每个子目录都对应着系统中的一个已注册的块设备。bus目录提供了一个系统总线视图。class目录包含了以高层逻辑功能组织起来的系统设备视图。dev目录是已注册设备节点的视图。devices目录是系统中设备拓扑结构视图，它直接映射出了内核中设备结构体的组织层次。firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。fs目录是已注册文件系统的视图。kernel目录包含内核配置项和状态信息，module目录则包含系统已加载模块的信息。power目录包含系统范围的电源管理数据。</p>
<p>其中，devices目录将设备模型导出到用户控件。</p>
<h4 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h4><p>函数定义于lib/kobject.c中，声明与&lt;linux/kobject.h&gt;中。</p>
<h4 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h4><h5 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h5><p>默认的文件集合是通过kobject和kset中的ktype字段提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同的默认文件集合。kobj_type字段含有一个字段——default_attrs，它是一个attribute结构体数组，定义于&lt;linux/sysfs.h&gt;中。这些属性负责将内核数据映射成sysfs中的文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">mode_t</span>			mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中name字段提供了该属性的名称。owner字段在存在所属模块的情况下指向其所属的module结构体；若没有该属性，那么该字段为NULL。mode字段表示了sysfs中该文件的权限。sysfs中的所有文件和目录的uid与gid标志均为零。</p>
<p>default_attrs列出了默认属性，而sysfs_ops字段则描述了如何使用它们。sysfs_ops字段指向了一个定义于文件&lt;linux/sysfs.h&gt;的同名结构体。</p>
<h5 id="创建新属性和删除新属性"><a href="#创建新属性和删除新属性" class="headerlink" title="创建新属性和删除新属性"></a>创建新属性和删除新属性</h5><p>声明在&lt;linux/kobject.h&gt;中。sysfs_create_file()和sysfs_remove_file()定义在fs/sysfs/file.c中。sysfs_create_link()和sysfs_remove_link()定义于fs/sysfs/symlink.c中。</p>
<h5 id="sysfs约定"><a href="#sysfs约定" class="headerlink" title="sysfs约定"></a>sysfs约定</h5><ol>
<li>sysfs属性应该保证每个文件只导出一个值，该值应该是文本形式而且映射为简单C类型。</li>
<li>sysfs中要以一个清晰的层次组织数据。</li>
<li>sysfs提供内核到用户空间的服务。</li>
</ol>
<h3 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h3><p>内核事件层实现了内核到用户的消息通知系统</p>
<p>内核事件把事件模拟为信号——从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。每个事件都被赋予了一个动词或动作字符串表示信号。每个事件都有一个可选的负载。相比传递任意一个表示负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。</p>
<p>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里。在内核代码向用户空间发送信号使用kobject_uevent()函数，定义于lib/kobject_uevent.c，声明在&lt;linux/kobject.h&gt;中。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h3><h4 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h4><p>printk可以指定一个日志级别，在&lt;linux/kernel.h&gt;中有简单的宏定义，如KERN_WARING等。</p>
<p>内核用这个指定的记录等级和当终端的记录等级console_loglevel来决定是不是向终端上打印。</p>
<h4 id="记录缓冲区"><a href="#记录缓冲区" class="headerlink" title="记录缓冲区"></a>记录缓冲区</h4><p>内核消息都被保存在一个LOG_BUF_LEN大小的环形队列中。</p>
<h4 id="syslogd和klogd"><a href="#syslogd和klogd" class="headerlink" title="syslogd和klogd"></a>syslogd和klogd</h4><p>在标准的Linux系统上，用户空间的守护进程klogd从记录缓存区中获取内核消息，在通过syslogd守护进程将它们保存在系统日志文件中。klogd程序既可以从/proc/kmsg文件中，也可以从syslog()系统调用中读取这些消息。默认情况下，它选择读取/proc方式实现。不管哪种方式，klogd都会阻塞，知道有新的内核消息可供读出。</p>
<p>syslogd守护进程把它接收到的所有消息添加进一个文件中，该文件默认是/var/log/messages，也可以通过/etc/syslog.conf配置文件重新指定。</p>
<p>在启动klogd的时候，可以通过指定-c标志来改变终端的记录等级。</p>
<h3 id="oops"><a href="#oops" class="headerlink" title="oops"></a>oops</h3><p>oops是内核告知用户有错误发生的最常用方式。</p>
<p>这个过程包括向终端上输出错误消息，输出寄存器中保存的信息并输出可供追踪的回溯线索。通常，发送完oops之后，内核会处于一种不稳定状态。</p>
<h4 id="ksymoops"><a href="#ksymoops" class="headerlink" title="ksymoops"></a>ksymoops</h4><p>命令ksymoops可以将回溯线索中的地址转化成有意义的符号名称。但必须提供编译内核时产生的System.map。</p>
<h4 id="kallsyms"><a href="#kallsyms" class="headerlink" title="kallsyms"></a>kallsyms</h4><h3 id="内核调试配置选项"><a href="#内核调试配置选项" class="headerlink" title="内核调试配置选项"></a>内核调试配置选项</h3><h3 id="引发bug并打印信息"><a href="#引发bug并打印信息" class="headerlink" title="引发bug并打印信息"></a>引发bug并打印信息</h3><h3 id="系统请求键"><a href="#系统请求键" class="headerlink" title="系统请求键"></a>系统请求键</h3><p>内核代码中Documentation/sysrq.txt对此有详细说明，实际的实现在drivers/char/sysrq.c中。</p>
<h3 id="内核调试器"><a href="#内核调试器" class="headerlink" title="内核调试器"></a>内核调试器</h3><h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><h4 id="kgdb"><a href="#kgdb" class="headerlink" title="kgdb"></a>kgdb</h4><p>该补丁在Documentation/目录下有很多安装说明。</p>
<h3 id="探测系统"><a href="#探测系统" class="headerlink" title="探测系统"></a>探测系统</h3><p>下面介绍几种技巧以修改来进一步探测系统从而得到答案：</p>
<ul>
<li>用UID作为选择条件</li>
<li>使用条件变量</li>
<li>使用统计量</li>
<li>重复频率限制</li>
</ul>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><h3 id="可移植性操作系统"><a href="#可移植性操作系统" class="headerlink" title="可移植性操作系统"></a>可移植性操作系统</h3><h3 id="字长和数据类型"><a href="#字长和数据类型" class="headerlink" title="字长和数据类型"></a>字长和数据类型</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="页长度"><a href="#页长度" class="headerlink" title="页长度"></a>页长度</h3><h3 id="处理器排序"><a href="#处理器排序" class="headerlink" title="处理器排序"></a>处理器排序</h3><h3 id="SMP、内核抢占、高端内存"><a href="#SMP、内核抢占、高端内存" class="headerlink" title="SMP、内核抢占、高端内存"></a>SMP、内核抢占、高端内存</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">nuoye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuoye-blog.github.io/2020/05/09/4475e869/">https://nuoye-blog.github.io/2020/05/09/4475e869/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuoye-blog.github.io" target="_blank">nuoye's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/f557d42c/"><img class="prev_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《程序员的自我修养》</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/d39fd25d/" title="《ptmalloc》"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《ptmalloc》</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/59c3f3b8/" title="《Linux二进制分析》"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《Linux二进制分析》</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/f557d42c/" title="《程序员的自我修养》"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《程序员的自我修养》</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'fbc6dbd3eda0f0b6f8ea',
  clientSecret: '97c6fa7736aa919cf681ef959433500cd4a39ccc',
  repo: 'nuoye-blog.github.io',
  owner: 'nuoye-blog',
  admin: ['nuoye-blog'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By nuoye</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/local-search.js"></script></body></html>