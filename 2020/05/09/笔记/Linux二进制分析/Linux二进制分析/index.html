<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Linux二进制分析》 | nuoye</title><meta name="description" content="Linux环境和相关工具Linux工具GDBGNU调试器 objdumpobjdump -D ELF    查看ELF文件中所有节的数据或代码 objdump -d ELF    只查看ELF文件中的程序代码 objdump -tT ELF    查看所有符号 objcopy要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令： objcopy -only-section&#x3D;."><meta name="keywords" content="笔记,linux,elf"><meta name="author" content="nuoye"><meta name="copyright" content="nuoye"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Linux二进制分析》"><meta name="twitter:description" content="Linux环境和相关工具Linux工具GDBGNU调试器 objdumpobjdump -D ELF    查看ELF文件中所有节的数据或代码 objdump -d ELF    只查看ELF文件中的程序代码 objdump -tT ELF    查看所有符号 objcopy要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令： objcopy -only-section&#x3D;."><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《Linux二进制分析》"><meta property="og:url" content="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="nuoye"><meta property="og:description" content="Linux环境和相关工具Linux工具GDBGNU调试器 objdumpobjdump -D ELF    查看ELF文件中所有节的数据或代码 objdump -d ELF    只查看ELF文件中的程序代码 objdump -tT ELF    查看所有符号 objcopy要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令： objcopy -only-section&#x3D;."><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-08T16:00:00.000Z"><meta property="article:modified_time" content="2020-05-08T17:28:58.202Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"><link rel="prev" title="《ptmalloc》" href="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/ptmalloc/ptmalloc/"><link rel="next" title="AFL-fuzz初体验" href="https://nuoye-blog.github.io/2020/05/09/%E6%96%87%E7%AB%A0/fuzzing/AFL-fuzz%E5%88%9D%E4%BD%93%E9%AA%8C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://nuoye-blog.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="nuoye" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux环境和相关工具"><span class="toc-number">1.</span> <span class="toc-text">Linux环境和相关工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux工具"><span class="toc-number">1.1.</span> <span class="toc-text">Linux工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB"><span class="toc-number">1.1.1.</span> <span class="toc-text">GDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objdump"><span class="toc-number">1.1.2.</span> <span class="toc-text">objdump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objcopy"><span class="toc-number">1.1.3.</span> <span class="toc-text">objcopy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strace"><span class="toc-number">1.1.4.</span> <span class="toc-text">strace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ltrace"><span class="toc-number">1.1.5.</span> <span class="toc-text">ltrace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ftrace"><span class="toc-number">1.1.6.</span> <span class="toc-text">ftrace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readelf"><span class="toc-number">1.1.7.</span> <span class="toc-text">readelf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ERESI"><span class="toc-number">1.1.8.</span> <span class="toc-text">ERESI</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#两篇文章："><span class="toc-number">1.1.8.0.0.1.</span> <span class="toc-text">两篇文章：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有用的设备和文件"><span class="toc-number">1.1.9.</span> <span class="toc-text">有用的设备和文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-lt-pid-gt-maps"><span class="toc-number">1.1.10.</span> <span class="toc-text">&#x2F;proc&#x2F;&lt;pid&gt;&#x2F;maps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-kcore"><span class="toc-number">1.1.11.</span> <span class="toc-text">&#x2F;proc&#x2F;kcore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boot-System-map"><span class="toc-number">1.1.12.</span> <span class="toc-text">&#x2F;boot&#x2F;System.map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-kallsyms"><span class="toc-number">1.1.13.</span> <span class="toc-text">&#x2F;proc&#x2F;kallsyms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-iomem"><span class="toc-number">1.1.14.</span> <span class="toc-text">&#x2F;proc&#x2F;iomem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECFS"><span class="toc-number">1.1.15.</span> <span class="toc-text">ECFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接器相关环境指针"><span class="toc-number">1.2.</span> <span class="toc-text">链接器相关环境指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LD-PRELOAD环境变量"><span class="toc-number">1.2.1.</span> <span class="toc-text">LD_PRELOAD环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LD-SHOW-AUXV环境变量"><span class="toc-number">1.2.2.</span> <span class="toc-text">LD_SHOW_AUXV环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接器脚本"><span class="toc-number">1.2.3.</span> <span class="toc-text">链接器脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ELF二进制格式"><span class="toc-number">2.</span> <span class="toc-text">ELF二进制格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF文件类型"><span class="toc-number">2.1.</span> <span class="toc-text">ELF文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF程序头"><span class="toc-number">2.2.</span> <span class="toc-text">ELF程序头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PT-LOAD"><span class="toc-number">2.2.1.</span> <span class="toc-text">PT_LOAD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PT-DYNAMIC"><span class="toc-number">2.2.2.</span> <span class="toc-text">PT_DYNAMIC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PT-NOTE"><span class="toc-number">2.2.3.</span> <span class="toc-text">PT_NOTE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PT-INTERP"><span class="toc-number">2.2.4.</span> <span class="toc-text">PT_INTERP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PT-PHDR"><span class="toc-number">2.2.5.</span> <span class="toc-text">PT_PHDR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF节头"><span class="toc-number">2.3.</span> <span class="toc-text">ELF节头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#段和节的区分"><span class="toc-number">2.3.1.</span> <span class="toc-text">段和节的区分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32位ELF节头的结构："><span class="toc-number">2.3.2.</span> <span class="toc-text">32位ELF节头的结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#text节"><span class="toc-number">2.3.3.</span> <span class="toc-text">.text节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rodata节"><span class="toc-number">2.3.4.</span> <span class="toc-text">.rodata节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#plt节"><span class="toc-number">2.3.5.</span> <span class="toc-text">.plt节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data节"><span class="toc-number">2.3.6.</span> <span class="toc-text">.data节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bss节"><span class="toc-number">2.3.7.</span> <span class="toc-text">.bss节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#got-plt节"><span class="toc-number">2.3.8.</span> <span class="toc-text">.got.plt节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynsym节"><span class="toc-number">2.3.9.</span> <span class="toc-text">.dynsym节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynstr节"><span class="toc-number">2.3.10.</span> <span class="toc-text">.dynstr节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rel-节"><span class="toc-number">2.3.11.</span> <span class="toc-text">.rel.*节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash节"><span class="toc-number">2.3.12.</span> <span class="toc-text">.hash节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#symtab节"><span class="toc-number">2.3.13.</span> <span class="toc-text">.symtab节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strtab节"><span class="toc-number">2.3.14.</span> <span class="toc-text">.strtab节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shstrtab节"><span class="toc-number">2.3.15.</span> <span class="toc-text">.shstrtab节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ctors和-dtors节"><span class="toc-number">2.3.16.</span> <span class="toc-text">.ctors和.dtors节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF文件布局"><span class="toc-number">2.3.17.</span> <span class="toc-text">ELF文件布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#text段："><span class="toc-number">2.3.17.1.</span> <span class="toc-text">text段：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data段："><span class="toc-number">2.3.17.2.</span> <span class="toc-text">data段：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF符号"><span class="toc-number">2.3.18.</span> <span class="toc-text">ELF符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-name"><span class="toc-number">2.3.19.</span> <span class="toc-text">st_name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-value"><span class="toc-number">2.3.20.</span> <span class="toc-text">st_value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-size"><span class="toc-number">2.3.21.</span> <span class="toc-text">st_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-other"><span class="toc-number">2.3.22.</span> <span class="toc-text">st_other</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-shndx"><span class="toc-number">2.3.23.</span> <span class="toc-text">st_shndx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#st-info"><span class="toc-number">2.3.24.</span> <span class="toc-text">st_info</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#对绑定和类型字段进行打包和解包的宏指令"><span class="toc-number">2.3.24.0.0.1.</span> <span class="toc-text">对绑定和类型字段进行打包和解包的宏指令</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF重定位"><span class="toc-number">2.4.</span> <span class="toc-text">ELF重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于二进制修补的重定位代码注入"><span class="toc-number">2.4.1.</span> <span class="toc-text">基于二进制修补的重定位代码注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF动态链接"><span class="toc-number">2.5.</span> <span class="toc-text">ELF动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助向量"><span class="toc-number">2.5.1.</span> <span class="toc-text">辅助向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOT"><span class="toc-number">2.5.2.</span> <span class="toc-text">GOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态段"><span class="toc-number">2.5.3.</span> <span class="toc-text">动态段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码一个ELF解析器"><span class="toc-number">2.6.</span> <span class="toc-text">编码一个ELF解析器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux进程追踪"><span class="toc-number">3.</span> <span class="toc-text">Linux进程追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ptrace"><span class="toc-number">3.1.</span> <span class="toc-text">ptrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程寄存器状态和标记"><span class="toc-number">3.2.</span> <span class="toc-text">进程寄存器状态和标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于ptrace的调试器示例"><span class="toc-number">3.3.</span> <span class="toc-text">基于ptrace的调试器示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存感染类型"><span class="toc-number">3.4.</span> <span class="toc-text">内存感染类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程镜像重建"><span class="toc-number">3.5.</span> <span class="toc-text">进程镜像重建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重建可执行文件的目标"><span class="toc-number">3.5.1.</span> <span class="toc-text">重建可执行文件的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重建过程算法"><span class="toc-number">3.5.2.</span> <span class="toc-text">重建过程算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ELF病毒技术"><span class="toc-number">4.</span> <span class="toc-text">ELF病毒技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF病毒技术-1"><span class="toc-number">4.1.</span> <span class="toc-text">ELF病毒技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF病毒寄生代码感染方法"><span class="toc-number">4.2.</span> <span class="toc-text">ELF病毒寄生代码感染方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Silvio填充感染"><span class="toc-number">4.2.1.</span> <span class="toc-text">Silvio填充感染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#text感染算法"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">.text感染算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆向text感染"><span class="toc-number">4.2.2.</span> <span class="toc-text">逆向text感染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逆向text感染算法"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">逆向text感染算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data段感染"><span class="toc-number">4.2.3.</span> <span class="toc-text">data段感染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data段感染算法"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">data段感染算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PT-NOTE到PT-LOAD转换感染"><span class="toc-number">4.3.</span> <span class="toc-text">PT_NOTE到PT_LOAD转换感染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PT-NOTE到PT-LOAD转换感染算法"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">PT_NOTE到PT_LOAD转换感染算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#感染控制流"><span class="toc-number">4.4.</span> <span class="toc-text">感染控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接PLT感染"><span class="toc-number">4.4.1.</span> <span class="toc-text">直接PLT感染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数蹦床"><span class="toc-number">4.4.2.</span> <span class="toc-text">函数蹦床</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写-ctors-dtors函数指针"><span class="toc-number">4.4.3.</span> <span class="toc-text">重写.ctors&#x2F;.dtors函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOT感染或PLT-GOT重定向"><span class="toc-number">4.4.4.</span> <span class="toc-text">GOT感染或PLT&#x2F;GOT重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#感染数据结构"><span class="toc-number">4.4.5.</span> <span class="toc-text">感染数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数指针重写"><span class="toc-number">4.4.6.</span> <span class="toc-text">函数指针重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程内存病毒和rootkits——远程代码注入技术"><span class="toc-number">4.5.</span> <span class="toc-text">进程内存病毒和rootkits——远程代码注入技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享库注入"><span class="toc-number">4.5.1.</span> <span class="toc-text">共享库注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#so感染-ET-DYN感染"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">.so感染&#x2F;ET_DYN感染</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#so感染——使用LD-PRELOAD"><span class="toc-number">4.5.1.1.1.</span> <span class="toc-text">.so感染——使用LD_PRELOAD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#so感染——利用open-mmap"><span class="toc-number">4.5.1.1.2.</span> <span class="toc-text">.so感染——利用open()&#x2F;mmap()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#so感染——利用dloen"><span class="toc-number">4.5.1.1.3.</span> <span class="toc-text">.so感染——利用dloen()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#so感染——使用vdso控制技术"><span class="toc-number">4.5.1.1.4.</span> <span class="toc-text">.so感染——使用vdso控制技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#text段代码注入"><span class="toc-number">4.5.2.</span> <span class="toc-text">text段代码注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可执行文件注入"><span class="toc-number">4.5.3.</span> <span class="toc-text">可执行文件注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定位代码注入——ET-REL注入"><span class="toc-number">4.5.4.</span> <span class="toc-text">重定位代码注入——ET_REL注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF反调试和封装技术"><span class="toc-number">4.6.</span> <span class="toc-text">ELF反调试和封装技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PTRACE-TRACEME技术"><span class="toc-number">4.6.1.</span> <span class="toc-text">PTRACE_TRACEME技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGTRAP处理技术"><span class="toc-number">4.6.2.</span> <span class="toc-text">SIGTRAP处理技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-self-status技术"><span class="toc-number">4.6.3.</span> <span class="toc-text">&#x2F;proc&#x2F;self&#x2F;status技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码混淆技术"><span class="toc-number">4.6.4.</span> <span class="toc-text">代码混淆技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串表转换技术"><span class="toc-number">4.6.5.</span> <span class="toc-text">字符串表转换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF病毒检测和杀毒"><span class="toc-number">4.7.</span> <span class="toc-text">ELF病毒检测和杀毒</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux二进制保护"><span class="toc-number">5.</span> <span class="toc-text">Linux二进制保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF二进制加壳器"><span class="toc-number">5.1.</span> <span class="toc-text">ELF二进制加壳器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存根机制和用户层执行"><span class="toc-number">5.2.</span> <span class="toc-text">存根机制和用户层执行</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">nuoye</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Linux二进制分析》</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-09 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-09 01:28:58"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 19 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Linux环境和相关工具"><a href="#Linux环境和相关工具" class="headerlink" title="Linux环境和相关工具"></a>Linux环境和相关工具</h1><h2 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a>Linux工具</h2><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU调试器</p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>objdump -D ELF    查看ELF文件中所有节的数据或代码</p>
<p>objdump -d ELF    只查看ELF文件中的程序代码</p>
<p>objdump -tT ELF    查看所有符号</p>
<h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><p>要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令：</p>
<p>objcopy -only-section=.data &lt;infile&gt; &lt;outfile&gt;</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>system call trace是基于ptrace(2)系统调用的一款工具。通过在一个循环中使用PTRACE_SYSCALL请求来显示运行中程序的系统调用活动相关的信息以及程序执行中捕捉到的信号量。</p>
<p>使用strace命令来跟踪一个基本程序：</p>
<p>strace /bin/ls -o ls.out</p>
<p>使用strace命令附加到一个现存的进程上：</p>
<p>strace -p &lt;pid&gt; -o daemon.out</p>
<p>原始输出将会显示每个系统调用的文件描述编号，系统调用会将文件描述符作为参数：SYS_read(3,buf,sizeof(buf))</p>
<p>如果想查看读入到文件描述符3中的所有数据，可以运行下面的命令：</p>
<p>strace -e read=3 /bin/ls</p>
<h3 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a>ltrace</h3><p>ltrace与strace非常类似。ltrace会解析共享库，并打印出用到的库函数。</p>
<h3 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h3><p>与ltrace类似，但还可以显示出二进制文件本身的函数调用。</p>
<p><a href="https://github.com/elfmaster/ftrace" target="_blank" rel="noopener">https://github.com/elfmaster/ftrace</a></p>
<h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>-h    查看ELF文件头</p>
<p>-S    查询节表头</p>
<p>-l    查询程序头表</p>
<p>-s    查询符号表</p>
<p>-e    查询ELF文件头数据</p>
<p>-r    查询重定位入口</p>
<p>-d    查询动态段</p>
<h3 id="ERESI"><a href="#ERESI" class="headerlink" title="ERESI"></a>ERESI</h3><p><a href="http://www.eresi-project.org" target="_blank" rel="noopener">http://www.eresi-project.org</a></p>
<h6 id="两篇文章："><a href="#两篇文章：" class="headerlink" title="两篇文章："></a>两篇文章：</h6><p>Cerberus ELF interface（<a href="http://www.phrack.org/archives/issues/61/8.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/61/8.txt）</a><br>Embedded ELF debugging（<a href="http://www.phrack.org/archives/issues/63/9.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/63/9.txt）</a></p>
<h3 id="有用的设备和文件"><a href="#有用的设备和文件" class="headerlink" title="有用的设备和文件"></a>有用的设备和文件</h3><h3 id="proc-lt-pid-gt-maps"><a href="#proc-lt-pid-gt-maps" class="headerlink" title="/proc/&lt;pid&gt;/maps"></a>/proc/&lt;pid&gt;/maps</h3><p>该文件保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包括可执行文件、共享库、栈、堆和VDSO等。</p>
<h3 id="proc-kcore"><a href="#proc-kcore" class="headerlink" title="/proc/kcore"></a>/proc/kcore</h3><p>是Linux内核的动态核心文件，即以ELF核心文件的形式所展现出来的原生内存转储。</p>
<h3 id="boot-System-map"><a href="#boot-System-map" class="headerlink" title="/boot/System.map"></a>/boot/System.map</h3><p>这个文件包含了整个内核的所有符号。</p>
<h3 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h3><p>与System.map类似，区别就是kallsyms是内核所属的/proc的一个入口并且可以动态更新。如果安装了新的LKM，符号会自动添加到里面去。</p>
<h3 id="proc-iomem"><a href="#proc-iomem" class="headerlink" title="/proc/iomem"></a>/proc/iomem</h3><p>与/proc/&lt;pid&gt;/maps类似，不过它是跟系统内存相关的。</p>
<h3 id="ECFS"><a href="#ECFS" class="headerlink" title="ECFS"></a>ECFS</h3><p>extended core file snapshot（扩展核心文件快照）是一项特殊的核心转储技术，专门为进程镜像的高级取证分析所设计。</p>
<p> <a href="https://github.com/elfmaster/ecfs" target="_blank" rel="noopener">https://github.com/elfmaster/ecfs</a></p>
<h2 id="链接器相关环境指针"><a href="#链接器相关环境指针" class="headerlink" title="链接器相关环境指针"></a>链接器相关环境指针</h2><h3 id="LD-PRELOAD环境变量"><a href="#LD-PRELOAD环境变量" class="headerlink" title="LD_PRELOAD环境变量"></a>LD_PRELOAD环境变量</h3><p>可以设置成一个指定的库路径，动态链接时可以比其他库有更高的优先级。</p>
<h3 id="LD-SHOW-AUXV环境变量"><a href="#LD-SHOW-AUXV环境变量" class="headerlink" title="LD_SHOW_AUXV环境变量"></a>LD_SHOW_AUXV环境变量</h3><p>能够通知程序加载器来展示程序运行时的辅助向量。</p>
<p>辅助向量是放在程序栈（通过内核的ELF常规加载方式）上的信息，附带了传递给动态链接器的程序相关的特定信息。</p>
<h3 id="链接器脚本"><a href="#链接器脚本" class="headerlink" title="链接器脚本"></a>链接器脚本</h3><p>默认的链接器脚本可以使用ld -verbose查看。</p>
<h1 id="ELF二进制格式"><a href="#ELF二进制格式" class="headerlink" title="ELF二进制格式"></a>ELF二进制格式</h1><h2 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h2><p>ET_NONE：未知类型</p>
<p>ET_REL：重定位文件</p>
<p>ET_EXEC：可执行文件</p>
<p>ET_DYN：共享目标文件</p>
<p>ET_CORE：核心文件</p>
<h2 id="ELF程序头"><a href="#ELF程序头" class="headerlink" title="ELF程序头"></a>ELF程序头</h2><p>Elf32_Phdr结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">unit32_t</span> p_type;<span class="comment">//segment type</span></span><br><span class="line">	Elf32_off p_offset;<span class="comment">//segment offset</span></span><br><span class="line">	Elf32_Addr p_vaddr;<span class="comment">//segment virtual address</span></span><br><span class="line">	Elf32_Addr p_paddr;<span class="comment">//segment physical address</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;<span class="comment">//size of segment in file</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;<span class="comment">//size of segment in memory</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;<span class="comment">//segment flags,I.E execute|read|write</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;<span class="comment">//segment alignment in memory</span></span><br><span class="line">&#125;Elf32_Phdr</span><br></pre></td></tr></table></figure>

<h3 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h3><p>一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是这种类型的段将被装载或者映射到内存中。</p>
<h3 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h3><p>动态段的Phdr。动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：</p>
<ul>
<li>运行时需要链接的共享库列表；</li>
<li>全局偏移表（GOT）的地址；</li>
<li>重定位条目的相关信息。</li>
</ul>
<p>32位ELF的动态段的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elf32_Sword d_tag;</span><br><span class="line">		<span class="keyword">union</span>&#123;</span><br><span class="line">	Elf32_Word d_val;</span><br><span class="line">	Elf32_Addr d_ptr;</span><br><span class="line">		&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>

<h3 id="PT-NOTE"><a href="#PT-NOTE" class="headerlink" title="PT_NOTE"></a>PT_NOTE</h3><p>该类型的段可能保存了与特定供应商或者系统相关的附加信息。</p>
<p>NOTE段病毒感染相关信息：<a href="http://vxheavens.com/lib/vhe06.html" target="_blank" rel="noopener">http://vxheavens.com/lib/vhe06.html</a></p>
<h3 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h3><p>PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。</p>
<h3 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h3><p>该段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr堆文件（以及内存镜像）中段的描述信息。</p>
<p>可以用readelf -l <file>命令查看文件的Phdr表</p>
<h2 id="ELF节头"><a href="#ELF节头" class="headerlink" title="ELF节头"></a>ELF节头</h2><h3 id="段和节的区分"><a href="#段和节的区分" class="headerlink" title="段和节的区分"></a>段和节的区分</h3><p>段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。</p>
<h3 id="32位ELF节头的结构："><a href="#32位ELF节头的结构：" class="headerlink" title="32位ELF节头的结构："></a>32位ELF节头的结构：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_name;<span class="comment">//offset into shdr string table for shdr name</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_type;<span class="comment">//shdr type, I.E SHT_PROGBITS</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_flags;<span class="comment">//shdr flags, I.E SHT_WRITE|SHT_ALLOC</span></span><br><span class="line">	Elf32_ADDR sh_addr;<span class="comment">//address of where section begins</span></span><br><span class="line">	Elf32_Off sh_offset;<span class="comment">//offset of shdr from beginning of file</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_size;<span class="comment">//size that section takes up on disk</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_link;<span class="comment">//points to another section</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_info;<span class="comment">//interpretation depends on section type</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_addralign;<span class="comment">//alignment for address of section</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_entsize;<span class="comment">//size of each certain entries that may be in section</span></span><br><span class="line">&#125;Elf32_Shdr</span><br></pre></td></tr></table></figure>

<h3 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h3><p>该节是保存了程序代码指令的代码节，存在于text段中。此节类型为SHT_PROGBITS</p>
<h3 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h3><p>该节保存了只读数据。存在于一个可执行文件的只读段中，即只能在text段中找到.rodata节。该节类型为SHT_PROGBITS。</p>
<h3 id="plt节"><a href="#plt节" class="headerlink" title=".plt节"></a>.plt节</h3><p>该节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。存在于text段中。此节类型为SHT_PROGBITS。</p>
<h3 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h3><p>.data节存在于data段中，保存了初始化的全局变量等数据。此节类型为SHT_PROGBITS</p>
<h3 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h3><p>保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于为保存实际的数据，此节类型为SHT_NOBITS</p>
<h3 id="got-plt节"><a href="#got-plt节" class="headerlink" title=".got.plt节"></a>.got.plt节</h3><p>.got节保存了全局偏移表。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。</p>
<h3 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h3><p>该节保存了从动态共享库导入的动态符号信息，该节保存在text段。节类型为SHT_DYNSYM</p>
<h3 id="dynstr节"><a href="#dynstr节" class="headerlink" title=".dynstr节"></a>.dynstr节</h3><p>该节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代码了符号的名称，以空字符作为终止符。</p>
<h3 id="rel-节"><a href="#rel-节" class="headerlink" title=".rel.*节"></a>.rel.*节</h3><p>重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，堆ELF目标文件的某部分内容或者进程镜像进行补充和修改。节类型为SHT_REL。</p>
<h3 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h3><p>有时也被称为.gnu.hash，保存了一个用于查找符号的散列表。</p>
<h3 id="symtab节"><a href="#symtab节" class="headerlink" title=".symtab节"></a>.symtab节</h3><p>该节保存了ElfN_Sym类型的符号信息。该节类型为SHT_SYMTAB</p>
<h3 id="strtab节"><a href="#strtab节" class="headerlink" title=".strtab节"></a>.strtab节</h3><p>该节保存的是符号字符串表，表中内容会被.symtab的ElfN_Sym结构中的st_name条目引用，此节类型为SHT_STRTAB。</p>
<h3 id="shstrtab节"><a href="#shstrtab节" class="headerlink" title=".shstrtab节"></a>.shstrtab节</h3><p>该节保存节头子符串表，该表是一个以空字符终止的字符串集合，字符串保存了每个节的节名。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。此节类型为SHT_STRTAB。</p>
<h3 id="ctors和-dtors节"><a href="#ctors和-dtors节" class="headerlink" title=".ctors和.dtors节"></a>.ctors和.dtors节</h3><p>.ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针。（构造函数即main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。）</p>
<h3 id="ELF文件布局"><a href="#ELF文件布局" class="headerlink" title="ELF文件布局"></a>ELF文件布局</h3><h4 id="text段："><a href="#text段：" class="headerlink" title="text段："></a>text段：</h4><p>[.text]：程序代码。</p>
<p>[.rodata]：只读数据。</p>
<p>[.hash]：符号散列表。</p>
<p>[.dynsym]：共享目标文件符号数据。</p>
<p>[.dynstr]：共享目标文件符号名称。</p>
<p>[.plt]：过程链接表。</p>
<p>[.rel.got]：G.O.T 重定位数据。</p>
<h4 id="data段："><a href="#data段：" class="headerlink" title="data段："></a>data段：</h4><p>[.data]：全局的初始化变量。</p>
<p>[.dynamic]：动态链接结构和对象。</p>
<p>[.got.plt]：全局偏移表。</p>
<p>[.bss]：全局未初始化变量。</p>
<h3 id="ELF符号"><a href="#ELF符号" class="headerlink" title="ELF符号"></a>ELF符号</h3><p>.dynsym保存了引用来自外部文件符号的全局符号。.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量或者代码中定义的本地函数等。</p>
<p>.dynsym是被标记了ALLOC的，而.symtab则没有被标记。ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。</p>
<p>64位ELF文件符号项的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> st_name;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">	<span class="keyword">uint16_t</span> st_shndx;</span><br><span class="line">	Elf64_Addr st_value;</span><br><span class="line">	Uint64_t st_size;</span><br><span class="line">&#125;Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>符号项保存在.symtab和.dynsym节中，因此节头项的大小与ElfN_Sym的大小相等。</p>
<h3 id="st-name"><a href="#st-name" class="headerlink" title="st_name"></a>st_name</h3><p>保存了指向符号表中字符串的偏移地址，偏移地址存放着符号的名称。</p>
<h3 id="st-value"><a href="#st-value" class="headerlink" title="st_value"></a>st_value</h3><p>存放符号的值（可能是地址或者位置偏移量）</p>
<h3 id="st-size"><a href="#st-size" class="headerlink" title="st_size"></a>st_size</h3><p>存放了一个符号的大小。</p>
<h3 id="st-other"><a href="#st-other" class="headerlink" title="st_other"></a>st_other</h3><p>定义了符号的可见性。</p>
<h3 id="st-shndx"><a href="#st-shndx" class="headerlink" title="st_shndx"></a>st_shndx</h3><p>保存了相关节头表的索引。</p>
<h3 id="st-info"><a href="#st-info" class="headerlink" title="st_info"></a>st_info</h3><p>指定符号类型及绑定属性：</p>
<p>1.符号类型：</p>
<p>STT_NOTYPE    符号类型未定义</p>
<p>STT_FUNC    表示该符号与函数或者其他可执行代码关联</p>
<p>STT_OBJECT    表示该符号与数据目标文件关联</p>
<p>2.符号绑定</p>
<p>STB_LOCAL    本地符号在目标文件之外是不可见的</p>
<p>STB_GLOBAL    全局符号对于所有要合并的目标文件来说都是可见的，一个全局符号在一个文件中进行定义后，另一个文件可以对这个符号进行引用。</p>
<p>STB_WEAK    与全局绑定类似，不过比STB_GLOBAL的优先级低。被标记为STB_WEAK的符号有可能被同名的未被标记为STB_WEAK的符号覆盖</p>
<h6 id="对绑定和类型字段进行打包和解包的宏指令"><a href="#对绑定和类型字段进行打包和解包的宏指令" class="headerlink" title="对绑定和类型字段进行打包和解包的宏指令"></a>对绑定和类型字段进行打包和解包的宏指令</h6><p>ELF32_ST_BIND(info)或者ELF64_ST_BIND(info)：从st_info值中提取出一个绑定。</p>
<p>ELF32_ST_TYPE(info)或者ELF64_ST_TYPE(info)：从st_info值中提取类型。</p>
<p>ELF32_ST_TYPE(bind,type)或者ELF64_ST_INFO(bind,type)：将一个绑定和类型转换成st_info值。</p>
<h2 id="ELF重定位"><a href="#ELF重定位" class="headerlink" title="ELF重定位"></a>ELF重定位</h2><p>要将一个偏移量计算成虚拟地址，可以用下面的公式：</p>
<p>address_of_call+offset+sizeof(addr)</p>
<h3 id="基于二进制修补的重定位代码注入"><a href="#基于二进制修补的重定位代码注入" class="headerlink" title="基于二进制修补的重定位代码注入"></a>基于二进制修补的重定位代码注入</h3><p>Eresi（<a href="http://www.eresi-project.org）" target="_blank" rel="noopener">http://www.eresi-project.org）</a></p>
<p>Quenya (<a href="http://www.bitlackeys.org/projects/quenya_32bit.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/quenya_32bit.tgz</a>)</p>
<h2 id="ELF动态链接"><a href="#ELF动态链接" class="headerlink" title="ELF动态链接"></a>ELF动态链接</h2><h3 id="辅助向量"><a href="#辅助向量" class="headerlink" title="辅助向量"></a>辅助向量</h3><p>通过系统调用 sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为辅助向量（auxv）。</p>
<p>辅助向量是一系列Elf_auxv_t结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> a_type;</span><br><span class="line">		<span class="keyword">union</span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> a_val;</span><br><span class="line">		&#125;a_un;</span><br><span class="line">&#125;Elf64_auxv_t;</span><br></pre></td></tr></table></figure>

<p>a_type指定了辅助向量的条目类型，a_val为辅助向量的值。</p>
<p>下面是动态链接器所需要的一些最重要的条目类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFD	2<span class="comment">//File descriptor of program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PATH		3<span class="comment">//Program headers for program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHENT	4<span class="comment">//Size of program header entry</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHNUM	5<span class="comment">//Number of program headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PAGESZ	6<span class="comment">//System page size</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_ENTRY	9<span class="comment">//Entry point of program	</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#deffine AT_UID		11<span class="comment">//Real uid</span></span></span><br></pre></td></tr></table></figure>

<p>程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。</p>
<h3 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h3><p>GOT的前3个偏移量</p>
<p>GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关信息。</p>
<p>GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。</p>
<p>GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。</p>
<h3 id="动态段"><a href="#动态段" class="headerlink" title="动态段"></a>动态段</h3><p>动态段保存了一个由类型为ElfN_Dyn的结构体组成的数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elf32_Sword d_tag;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		Elf32_Word d_val;</span><br><span class="line">		Elf32_Addr d_ptr;</span><br><span class="line">	&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>d_tag字段保存了类型的定义参数，下面列出常用的比较重要的类型值：</p>
<p>1.DT_NEEDED：保存了所需的共享库名的字符串表偏移量。</p>
<p>2.DT_SYMTAB：动态符号表的地址，对应的节名.dynsym。</p>
<p>3.DT_HASH：符号散列表的地址，对应的节名.hash。</p>
<p>4.DT_STRTAB：符号字符串表的地址，对应的节名.dynstr。</p>
<p>5.DT_PLTGOT：全局偏移表的地址。</p>
<p>d_val成员保存了一个整型值，可以存放各种不同的数据。</p>
<p>d_ptr成员保存了一个内存虚址，可以指向链接器所需要的各种类型的地址。</p>
<p>链接器为每个动态库生成一个link_map结构条目，并将其存入到一个链表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>&#123;</span></span><br><span class="line">	ElfW(Addr) l_addr;<span class="comment">//Base address shared object is loaded at.</span></span><br><span class="line">	<span class="keyword">char</span> *l_name;<span class="comment">//Absolute file name object was found in.</span></span><br><span class="line">	ElfW(Dyn) *l_ld;<span class="comment">//Dynamic section of the shared object.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span><span class="comment">//Chain of loaded objects.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编码一个ELF解析器"><a href="#编码一个ELF解析器" class="headerlink" title="编码一个ELF解析器"></a>编码一个ELF解析器</h2><h1 id="Linux进程追踪"><a href="#Linux进程追踪" class="headerlink" title="Linux进程追踪"></a>Linux进程追踪</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>ptrace可以附加到一个进程上并修改内存。</p>
<h2 id="进程寄存器状态和标记"><a href="#进程寄存器状态和标记" class="headerlink" title="进程寄存器状态和标记"></a>进程寄存器状态和标记</h2><h2 id="基于ptrace的调试器示例"><a href="#基于ptrace的调试器示例" class="headerlink" title="基于ptrace的调试器示例"></a>基于ptrace的调试器示例</h2><h2 id="内存感染类型"><a href="#内存感染类型" class="headerlink" title="内存感染类型"></a>内存感染类型</h2><table>
<thead>
<tr>
<th>感染技术</th>
<th>目标结果</th>
<th>寄存类型</th>
</tr>
</thead>
<tbody><tr>
<td>GOT感染</td>
<td>劫持共享库函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>过程链接表(PLT)感染</td>
<td>劫持共享库函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>.ctors/.dtors感染</td>
<td>将控制流转向恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>Function trampolines（函数蹦床）</td>
<td>劫持任意函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>共享库注入</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>重定位代码注入</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>直接修改text段</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>进程占用（将整段程序注入地址空间）</td>
<td>运行隐藏在现存进程中的完全不同的可执行文件</td>
<td>进程内存</td>
</tr>
</tbody></table>
<h2 id="进程镜像重建"><a href="#进程镜像重建" class="headerlink" title="进程镜像重建"></a>进程镜像重建</h2><h3 id="重建可执行文件的目标"><a href="#重建可执行文件的目标" class="headerlink" title="重建可执行文件的目标"></a>重建可执行文件的目标</h3><ul>
<li>进程ID作为参数，将该ID对应的进程镜像重建成对应的可执行文件。</li>
<li>构建节头的最小集，以便可以使用objdump和gdb这样的工具进行更精确的分析。</li>
</ul>
<h3 id="重建过程算法"><a href="#重建过程算法" class="headerlink" title="重建过程算法"></a>重建过程算法</h3><p>1.定位可执行文件(text段)的基址。</p>
<p>2.通过解析ELF文件头来定位程序头表。</p>
<p>3.解析程序头表，找出数据段。</p>
<p>4.将数据段读到缓存中，并定位数据段中的动态段，然后定位GOT。使用动态段中的d_tag来定位GOT。</p>
<p>5.一旦定位到GOT，就需要将GOT恢复到运行之前的装填。</p>
<p>6.需要修改为puts()保留的GOT条目，重新指向PLT存根代码，这段代码的作用是将GOT偏移地址压入栈。</p>
<p>7.选择性地重建节头表。然后将text段和data段(以及节头表)写到磁盘。</p>
<h1 id="ELF病毒技术"><a href="#ELF病毒技术" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h1><h2 id="ELF病毒技术-1"><a href="#ELF病毒技术-1" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h2><p>ELF病毒的首要目标是劫持控制流，暂时改变程序执行的路径来执行寄生病毒。</p>
<h2 id="ELF病毒寄生代码感染方法"><a href="#ELF病毒寄生代码感染方法" class="headerlink" title="ELF病毒寄生代码感染方法"></a>ELF病毒寄生代码感染方法</h2><h3 id="Silvio填充感染"><a href="#Silvio填充感染" class="headerlink" title="Silvio填充感染"></a>Silvio填充感染</h3><p>这种方法利用了内存中text段和data段之间存在的一页大小的填充空间。</p>
<p>相关论文：Unix ELF parasites and viruses(<a href="http://vxheaven.org/lib/vsc01.html" target="_blank" rel="noopener">http://vxheaven.org/lib/vsc01.html</a>)</p>
<h4 id="text感染算法"><a href="#text感染算法" class="headerlink" title=".text感染算法"></a>.text感染算法</h4><p>1.将ELF文件头中的ehdr-&gt;e_shoff增加PAGE_SIZE的大小值。</p>
<p>2.定位text段的phdr。</p>
<ul>
<li>将入口点修改为寄生代码的位置：ehdr-&gt;e_entry=phdr[TEXT].p_vaddr+phdr[TEXT].p_filesz。</li>
<li>将phdr[TEXT].p_filesz增加寄生代码的长度值。</li>
<li>将phdr[TEXT].p_memsz增加寄生代码的长度值。</li>
</ul>
<p>3.对每个phdr，如果对应的段位于寄生代码之后，则将phdr[x].p_offset增加PAGE_SIZE大小。</p>
<p>4.找到text段的最后一个shdr，将shdr[x].sh_size增加寄生代码长度值。</p>
<p>5.对每个位于寄生代码插入位置之后的shdr，将shdr[x].sh_offset增加PAGE_SIZE大小。</p>
<p>6.将真正的寄生代码插入到text段的file_base+phdr[TEXT].p_filesz。</p>
<p>相关代码示例： <a href="http://www.bitlackeys.org/projects/lpv.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/lpv.c</a></p>
<h3 id="逆向text感染"><a href="#逆向text感染" class="headerlink" title="逆向text感染"></a>逆向text感染</h3><p>前提：堆text段进行逆向扩展，在逆向扩展过程中，需要将text段的虚拟地址缩减PAGE_ALIGN(parasite_size)。</p>
<h4 id="逆向text感染算法"><a href="#逆向text感染算法" class="headerlink" title="逆向text感染算法"></a>逆向text感染算法</h4><p>1.将ehdr-&gt;e_shoff增加PAGE_ROUND(parasite_len)</p>
<p>2.找到text段和phdr，保存p_vaddr的初始值。</p>
<ul>
<li>将p_vaddr减小PAGE_ROUND(parasite_len)。</li>
<li>将p_paddr减小PAGE_ROUND(parasite_len)。</li>
<li>将p_filesz增加PAGE_ROUND(parasite_len)。</li>
<li>将p_memsz增加PAGE_ROUND(parasite_len)。</li>
</ul>
<p>3.找出所有的p_offset比text的p_offset的phdr，并将对应的p_offset增加PAGE_ROUND(parasite_len)；这步操作会将phdr前移，为逆向text扩展腾出空间。</p>
<p>4.将ehdr-&gt;e_entry设置为：</p>
<p>orig_text_vaddr - PAGE_ROUND(parasite_len) +sizeof(ElfN_Ehdr)</p>
<p>5.将ehdr_e_phoff增加PAGE_ROUND(parasite_len)。</p>
<p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p>
<p>相关代码：<a href="http://www.bitlackeys.org/projects/text-infector.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/text-infector.tgz</a> </p>
<p>相应杀毒程序：<a href="http://www.bitlackeys.org/projects/skeksi_disinfect.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/skeksi_disinfect.c</a></p>
<h3 id="data段感染"><a href="#data段感染" class="headerlink" title="data段感染"></a>data段感染</h3><h4 id="data段感染算法"><a href="#data段感染算法" class="headerlink" title="data段感染算法"></a>data段感染算法</h4><p>1.将ehdr_e_shoff增加寄生代码的长度。</p>
<p>2.定位data段phdr。</p>
<ul>
<li>将ehdr-&gt;e_entry指向寄生代码所在位置：phdr-&gt;p_vaddr + phdr-&gt;p_filesz</li>
<li>将phdr-&gt;p_filesz增加寄生代码长度</li>
<li>将phdr-&gt;p_memsz增加寄生代码的长度</li>
</ul>
<p>3.调整.bss节头，使其偏移量和地址能够反映出寄生代码的结束位置。</p>
<p>4.设置data段的权限(设置了NX-bit的系统)：</p>
<ul>
<li>phdr[DATA].p_flags != PF_X;</li>
</ul>
<p>5.（可选）使用假名为寄生代码添加一个节头。（防止有人运行了/usr/bin/strip<infected_program>，会将没有进行节头说明的寄生代码清理掉）</p>
<p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p>
<h2 id="PT-NOTE到PT-LOAD转换感染"><a href="#PT-NOTE到PT-LOAD转换感染" class="headerlink" title="PT_NOTE到PT_LOAD转换感染"></a>PT_NOTE到PT_LOAD转换感染</h2><p>原理：将PT_NOTE段的类型改为PT_LOAD，然后将段的位置移到其他所有段之后。当然，也可以通过创建一个PT_LOAD phdr条目来创建一个新的段，但是由于程序在没有PT_NOTE段时仍将执行，因此将其转换为PT_LOAD类型。</p>
<h4 id="PT-NOTE到PT-LOAD转换感染算法"><a href="#PT-NOTE到PT-LOAD转换感染算法" class="headerlink" title="PT_NOTE到PT_LOAD转换感染算法"></a>PT_NOTE到PT_LOAD转换感染算法</h4><p>1.定位data段phdr。</p>
<ul>
<li>找到data段结束的地址：ds_end_addr = phdr-&gt;p_vaddr + p_memsz</li>
<li>找到data段结束的文件偏移量：da_end_off = phdr-&gt;p_offset + p_filesz</li>
<li>获取到可加载段的对齐大小：align_size = phdr-&gt;p_align</li>
</ul>
<p>2.定位PT_NOTE phdr。</p>
<ul>
<li><p>将phdr转换成PT_LOAD：phdr-&gt;p_type = PT_LOAD；</p>
</li>
<li><p>将下面起始地址赋给phdr：ds_end_addr + align_size</p>
</li>
<li><p>将寄生代码的长度赋给phdr：phdr-&gt;p_filesz += parasite_size;  phdr-&gt;p_memsz += parasite_size</p>
</li>
</ul>
<p>3.对新建的段进行说明：ehdr-&gt;e_shoff += parasite_size。</p>
<p>4.创建一个新的二进制文件映射出ELF头的修改和新的段，插入真正的寄生代码。</p>
<h2 id="感染控制流"><a href="#感染控制流" class="headerlink" title="感染控制流"></a>感染控制流</h2><h3 id="直接PLT感染"><a href="#直接PLT感染" class="headerlink" title="直接PLT感染"></a>直接PLT感染</h3><p>修改PLT代码，使其存放一条完全不同的指令来改变控制流。</p>
<h3 id="函数蹦床"><a href="#函数蹦床" class="headerlink" title="函数蹦床"></a>函数蹦床</h3><p>使用某种能够改变控制流的分支指令重写函数代码的前5~7个字节。重写完后调用的的即为要想调用的函数。</p>
<h3 id="重写-ctors-dtors函数指针"><a href="#重写-ctors-dtors函数指针" class="headerlink" title="重写.ctors/.dtors函数指针"></a>重写.ctors/.dtors函数指针</h3><p>.ctors/.init_array 函数指针会在 main()函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。.dtors/.fini_array 函数指针在 main()函数执行完之后才被触发。</p>
<h3 id="GOT感染或PLT-GOT重定向"><a href="#GOT感染或PLT-GOT重定向" class="headerlink" title="GOT感染或PLT/GOT重定向"></a>GOT感染或PLT/GOT重定向</h3><p>相关论文： Modern Day ELF Runtime infection via GOT poisoning（<a href="http://vxheaven.org/lib/vrn00.html）" target="_blank" rel="noopener">http://vxheaven.org/lib/vrn00.html）</a></p>
<h3 id="感染数据结构"><a href="#感染数据结构" class="headerlink" title="感染数据结构"></a>感染数据结构</h3><h3 id="函数指针重写"><a href="#函数指针重写" class="headerlink" title="函数指针重写"></a>函数指针重写</h3><h2 id="进程内存病毒和rootkits——远程代码注入技术"><a href="#进程内存病毒和rootkits——远程代码注入技术" class="headerlink" title="进程内存病毒和rootkits——远程代码注入技术"></a>进程内存病毒和rootkits——远程代码注入技术</h2><h3 id="共享库注入"><a href="#共享库注入" class="headerlink" title="共享库注入"></a>共享库注入</h3><h4 id="so感染-ET-DYN感染"><a href="#so感染-ET-DYN感染" class="headerlink" title=".so感染/ET_DYN感染"></a>.so感染/ET_DYN感染</h4><p>这项技术可以用来将一个共享库注入到已存在的进程地址空间中，注入共享库后，需要通过PLT/GOT重定向、函数蹦床等将控制流使用前面的感染点之一重定向到共享库。</p>
<h5 id="so感染——使用LD-PRELOAD"><a href="#so感染——使用LD-PRELOAD" class="headerlink" title=".so感染——使用LD_PRELOAD"></a>.so感染——使用LD_PRELOAD</h5><p>通过设置LD_PRELOAD环境变量，将我们想要的共享库放在其他共享库之前加载。</p>
<h5 id="so感染——利用open-mmap"><a href="#so感染——利用open-mmap" class="headerlink" title=".so感染——利用open()/mmap()"></a>.so感染——利用open()/mmap()</h5><p>通过往已存在的进程的text段注入shellcode，并执行shellcode。利用共享库的open/mmap操作，将任何文件注入到进程的地址空间中。</p>
<h5 id="so感染——利用dloen"><a href="#so感染——利用dloen" class="headerlink" title=".so感染——利用dloen()"></a>.so感染——利用dloen()</h5><p>程序可以通过dlopen()/_libc_dlopen_mode()函数凭空加载一个共享库。</p>
<p>但在使用_libc_dlopen_mode()之前，要先得到想要感染进程中的libc基址，解析_libc_dlopen_mode()的符号，然后将符号值st_value与libc相加得到最终地址。</p>
<h5 id="so感染——使用vdso控制技术"><a href="#so感染——使用vdso控制技术" class="headerlink" title=".so感染——使用vdso控制技术"></a>.so感染——使用vdso控制技术</h5><h3 id="text段代码注入"><a href="#text段代码注入" class="headerlink" title="text段代码注入"></a>text段代码注入</h3><h3 id="可执行文件注入"><a href="#可执行文件注入" class="headerlink" title="可执行文件注入"></a>可执行文件注入</h3><p>elfdemon： <a href="http://www.bitlackeys.org/projects/elfdemon.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfdemon.tgz</a></p>
<h3 id="重定位代码注入——ET-REL注入"><a href="#重定位代码注入——ET-REL注入" class="headerlink" title="重定位代码注入——ET_REL注入"></a>重定位代码注入——ET_REL注入</h3><h2 id="ELF反调试和封装技术"><a href="#ELF反调试和封装技术" class="headerlink" title="ELF反调试和封装技术"></a>ELF反调试和封装技术</h2><h3 id="PTRACE-TRACEME技术"><a href="#PTRACE-TRACEME技术" class="headerlink" title="PTRACE_TRACEME技术"></a>PTRACE_TRACEME技术</h3><p>进程追踪有一个特性：一个程序在同一时间只能被一个进程追踪。</p>
<p>这项技术的思路就是让程序追踪自身，这样调试器就无法附加到该进程了。</p>
<h3 id="SIGTRAP处理技术"><a href="#SIGTRAP处理技术" class="headerlink" title="SIGTRAP处理技术"></a>SIGTRAP处理技术</h3><p>使用这项技术，程序可以设置一个信号处理器来捕获SIGTRAP信号，然后故意发出一个断点指令，信号处理器捕捉到SIGTRAP信号后，会将一个全局变量从0加到1。随后检查这个全局变量，如果为1，则说明未被调试；如果为0，说明正在被调试，为了防止被调试，可以终止进程或者退出。</p>
<h3 id="proc-self-status技术"><a href="#proc-self-status技术" class="headerlink" title="/proc/self/status技术"></a>/proc/self/status技术</h3><p>/proc/self/status中的”TracerPid”对应值0表示没用被追踪，如果不为0，则表明正在被追踪。</p>
<h3 id="代码混淆技术"><a href="#代码混淆技术" class="headerlink" title="代码混淆技术"></a>代码混淆技术</h3><p>通过修改汇编层的代码来引入不明确的分支指令或者未对其指令，使得反汇编程序无法正确地读取字节码文件。</p>
<h3 id="字符串表转换技术"><a href="#字符串表转换技术" class="headerlink" title="字符串表转换技术"></a>字符串表转换技术</h3><p>这项技术会打乱每个符号名和节相关信息的顺序，以致可能出现的结果就是所有的节头、函数名和符号名看上去都是乱序混在一起的。</p>
<p>相关代码：<a href="http://www.bitlackeys.org/projects/elfscure.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfscure.c</a> </p>
<h2 id="ELF病毒检测和杀毒"><a href="#ELF病毒检测和杀毒" class="headerlink" title="ELF病毒检测和杀毒"></a>ELF病毒检测和杀毒</h2><p>VMA Voodoo（<a href="http://www.bitlackeys.org/#vmavudu）" target="_blank" rel="noopener">http://www.bitlackeys.org/#vmavudu）</a><br>AVU(Anti Virus UNIX）：<a href="http://www.bitlackeys.org/projects/avu32.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/avu32.tgz</a></p>
<h1 id="Linux二进制保护"><a href="#Linux二进制保护" class="headerlink" title="Linux二进制保护"></a>Linux二进制保护</h1><h2 id="ELF二进制加壳器"><a href="#ELF二进制加壳器" class="headerlink" title="ELF二进制加壳器"></a>ELF二进制加壳器</h2><p>加壳器：用来对可执行文件进行压缩或加密，来对代码和数据进行混淆。</p>
<h2 id="存根机制和用户层执行"><a href="#存根机制和用户层执行" class="headerlink" title="存根机制和用户层执行"></a>存根机制和用户层执行</h2><p>软件保护器由以下两个程序组成：保护阶段的代码（应用到目标二进制文件上的保护程序）、运行时引擎或存根（与目标二进制文件合并在一起，负责运行时反混淆和反调试的程序。）</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">nuoye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/">https://nuoye-blog.github.io/2020/05/09/笔记/Linux二进制分析/Linux二进制分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuoye-blog.github.io" target="_blank">nuoye</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/elf/">elf</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/%E7%AC%94%E8%AE%B0/ptmalloc/ptmalloc/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《ptmalloc》</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/09/%E6%96%87%E7%AB%A0/fuzzing/AFL-fuzz%E5%88%9D%E4%BD%93%E9%AA%8C/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AFL-fuzz初体验</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/笔记/ptmalloc/ptmalloc/" title="《ptmalloc》"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《ptmalloc》</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/笔记/程序员的自我修养/程序员的自我修养/" title="《程序员的自我修养》"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《程序员的自我修养》</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/09/笔记/Linux内核设计与实现/Linux内核设计与实现/" title="《Linux内核设计与实现》"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-09</div><div class="relatedPosts_title">《Linux内核设计与实现》</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By nuoye</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>